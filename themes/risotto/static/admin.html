<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub íŒŒì¼ ì—ë””í„° (Octokit + Hugo)</title>
    <style>
        /* CSS ìŠ¤íƒ€ì¼ */
        body { font-family: sans-serif; line-height: 1.6; padding: 0px; background-color: #f4f4f4; color: #333; }
        .container {
            max-width: 900px; /* ìµœëŒ€ ë„ˆë¹„ ìœ ì§€ */
            margin: 20px auto; /* ìƒí•˜ ì—¬ë°± ë° ì¤‘ì•™ ì •ë ¬ ìœ ì§€ */
        }

        /* --- New Styles for Header --- */
        #header-container {
            display: flex; /* Enable Flexbox */
            justify-content: space-between; /* Title left, Button right */
            align-items: center; /* Vertically align items */
            margin-bottom: 20px; /* Add space below the header */
            flex-wrap: wrap; /* Allow wrapping on small screens if needed */
            gap: 10px; /* Add gap between title and button if they wrap */
            border-bottom: 1px solid #eee; /* Optional: Add a separator line */
            padding-bottom: 15px; /* Optional: Add padding below the header content */
        }

        #header-container h1 {
            margin-bottom: 0; /* Remove default bottom margin from h1 inside flex */
            margin-right: 15px; /* Add some space between title and button */
            flex-grow: 1; /* Allow title to take up available space */
            font-size: 1.8em; /* Adjust size if needed */
            color: #333; /* Match main color */
        }

        #header-container #logoutButton {
            /* Reset specific margins potentially inherited or conflicting */
            margin: 0;
            /* Adjust padding/font-size for the header */
             padding: 8px 15px;
             font-size: 0.9rem;
             white-space: nowrap; /* Prevent button text from wrapping */
             flex-shrink: 0; /* Prevent button from shrinking */
             background-color: #6c757d; /* Keep gray color */
             /* Align vertically if needed, though align-items should handle it */
             /* vertical-align: middle; */
        }
        #header-container #logoutButton:hover:not(:disabled) {
             background-color: #5a6268; /* Darker gray on hover */
        }
        /* --- End New Header Styles --- */


        .section {
            padding: 15px 20px; /* ìƒí•˜ì¢Œìš° ì—¬ë°± ì¡°ì • */
            margin-bottom: 20px; /* ì„¹ì…˜ ê°„ ê°„ê²© */
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* ì•½ê°„ì˜ ê·¸ë¦¼ì ì¶”ê°€ */
        }
        /* Keep h1 style for title, but maybe remove text-align center if header handles alignment */
        h1 { /* text-align: center; */ margin-bottom: 30px; } /* Center align removed */
        h2, h3 { color: #0056b3; }
        h2 { border-bottom: 2px solid #eee; padding-bottom: 10px; margin-bottom: 20px; /* ì—¬ë°± ì¦ê°€ */ font-size: 1.5em;}
        h3 { margin-top: 25px; margin-bottom: 15px; color: #333; font-size: 1.2em; }
        label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
        input[type="text"], input[type="password"], select, textarea {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px; /* ì—¬ë°± ì¦ê°€ */
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1rem;
        }
        textarea { height: 350px; font-family: 'Courier New', Courier, monospace; line-height: 1.5; }
        button {
            /* General button styles */
            padding: 12px 18px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px; /* Keep general right margin */
            margin-top: 10px; /* Keep general top margin */
            font-size: 1rem;
            transition: background-color 0.2s ease;
            vertical-align: middle; /* Align buttons vertically */
        }
        button:hover:not(:disabled) { background-color: #0056b3; } /* :disabled ìƒíƒœ ì œì™¸ */
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #fileList ul { list-style: none; padding: 0; margin: 0; max-height: 300px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px;}
        #fileList li { padding: 10px 12px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: center; transition: background-color 0.2s ease;}
        #fileList li:last-child { border-bottom: none; }
        #fileList li:hover { background-color: #f0f8ff; }
        #fileList li::before { margin-right: 10px; font-size: 1.1em; }
        #fileList li.dir::before { content: 'ğŸ“'; color: #ffac33; }
        #fileList li.file::before { content: 'ğŸ“„'; color: #6c757d; }
        #fileList li strong { font-weight: bold; color: #0056b3; } /* ìƒìœ„ í´ë” ë§í¬ ìŠ¤íƒ€ì¼ */
        #fileList li em { color: #888; font-style: italic; } /* ë¡œë”©, ë¹ˆ í´ë” ë©”ì‹œì§€ */
        #statusBar { margin-top: 20px; padding: 12px; background-color: #e9ecef; border-radius: 4px; color: #495057; text-align: center; font-size: 0.95em;}
        .hidden { display: none !important; } /* Use important to ensure override */
        .status-bar-error { color: #721c24 !important; background-color: #f8d7da !important; border: 1px solid #f5c6cb !important; font-weight: bold; }
        .status-bar-success { color: #155724 !important; background-color: #d4edda !important; border: 1px solid #c3e6cb !important; }
        .warning { color: #856404; background-color: #fff3cd; border-color: #ffeeba; border-left: 4px solid #ffc107; padding: 15px; border-radius: 4px; margin-bottom: 20px;}
        .error { color: #dc3545; font-weight: bold; border-left: 4px solid #dc3545; padding: 10px; background-color: #f8d7da; border-radius: 4px; margin-bottom: 15px;}
        .breadcrumb { margin-bottom: 15px; font-size: 0.95em; color: #6c757d; background-color: #f8f9fa; padding: 8px 12px; border-radius: 4px; border: 1px solid #eee;}
        .breadcrumb strong { color: #333; }
        .breadcrumb a { text-decoration: none; color: #007bff; }
        .breadcrumb a:hover { text-decoration: underline; }
        .breadcrumb span { margin: 0 5px; color: #aaa; }
        hr { margin: 25px 0; border: 0; border-top: 1px solid #eee; }
        label[for="fmTocCheckbox"] { display: inline-block; margin-right: 10px; margin-bottom: 10px; font-weight: normal; }
        input[type="checkbox"] { margin-right: 8px; vertical-align: middle; width: auto; }

        /* Control button containers (used in multiple sections) */
        .controls-container {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px; /* Use gap for spacing between items */
        }

        /* Removed specific repoSection logout button style */


        /* Responsive */
        @media (max-width: 600px) {
            .container { margin: 10px; }
             /* --- Responsive Header Adjustments --- */
             #header-container {
                 /* Could change justification or direction if needed */
                 /* justify-content: center; */
                 flex-direction: column; /* Stack title and button */
                 align-items: flex-start; /* Align items to the start */
                 padding-bottom: 10px;
             }
             #header-container h1 {
                 font-size: 1.6em; /* Adjust title size */
                 margin-right: 0; /* No right margin needed when stacked */
                 margin-bottom: 10px; /* Add space below title when stacked */
             }
              #header-container #logoutButton {
                   width: 100%; /* Make button full width when stacked */
                   margin-top: 5px; /* Add space if stacking */
                   text-align: center;
              }
             /* --- End Responsive Header Adjustments --- */

            .section { padding: 15px; }
            /* h1 { font-size: 1.8em; margin-bottom: 20px;} */ /* Already adjusted in header styles */
            h2 { font-size: 1.3em; }
            h3 { font-size: 1.1em; }

            /* General button stacking in controls containers */
            .controls-container {
                flex-direction: column; /* Stack buttons in control sections */
                align-items: stretch; /* Make buttons fill width */
            }
            .controls-container button {
                 width: 100%;
                 margin-right: 0;
                 margin-bottom: 10px;
            }
            .controls-container button:last-child {
                margin-bottom: 0; /* Remove margin from last stacked button */
            }


            input[type="text"], input[type="password"], select, textarea { padding: 10px; }
            #fileList ul { max-height: 250px; }
        }

    </style>
</head>
<body>

<div class="container">
    <!-- New Header Container -->
    <div id="header-container">
        <h1>GitHub íŒŒì¼ ì—ë””í„° (Octokit + Hugo)</h1>
        <!-- Moved Logout Button - initially hidden -->
        <button id="logoutButton" class="hidden">ë¡œê·¸ì•„ì›ƒ</button>
    </div>
    <!-- End New Header Container -->

    <!-- 1. Login Section -->
    <div id="loginSection" class="section">
        <h2>1. GitHub ë¡œê·¸ì¸ (Octokit ì‚¬ìš©)</h2>
        <!-- Updated Warning -->
        <div class="warning">
            <strong>ì£¼ì˜:</strong> Personal Access Token (PAT)ì„ ë¸Œë¼ìš°ì €ì— ì €ì¥í•˜ê±°ë‚˜ ì…ë ¥í•˜ëŠ” ê²ƒì€ ë³´ì•ˆìƒ ìœ„í—˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë°˜ë“œì‹œ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” í™˜ê²½ì—ì„œ ê°œì¸ì ì¸ ìš©ë„ë¡œë§Œ ì‚¬ìš©í•˜ê³ , í† í°ì´ ì™¸ë¶€ì— ë…¸ì¶œë˜ì§€ ì•Šë„ë¡ ê°ë³„íˆ ì£¼ì˜í•˜ì„¸ìš”. <strong>ì´ í† í°ì€ ë¸Œë¼ìš°ì €ë¥¼ ë‹«ì•„ë„ ìœ ì§€ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ (`localStorage` ì‚¬ìš©), ì‚¬ìš© í›„ì—ëŠ” ë°˜ë“œì‹œ 'ë¡œê·¸ì•„ì›ƒ í•˜ê¸°' ë²„íŠ¼ì„ ëˆ„ë¥´ê±°ë‚˜ ë¸Œë¼ìš°ì €ì˜ ì €ì¥ëœ ì‚¬ì´íŠ¸ ë°ì´í„°ë¥¼ ì§ì ‘ ì‚­ì œí•˜ì„¸ìš”.</strong> í† í°ì—ëŠ” <strong>'repo'</strong> ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.
        </div>
        <label for="patInput">Personal Access Token (PAT):</label>
        <input type="password" id="patInput" placeholder="GitHub PAT ì…ë ¥ (repo ê¶Œí•œ í•„ìš”)">
        <div class="controls-container">
             <button id="loginButton">ë¡œê·¸ì¸</button>
             <!-- Logout button is no longer here -->
        </div>
    </div>

    <!-- 2. Repository Selection -->
    <div id="repoSection" class="section hidden">
        <h2>2. ì €ì¥ì†Œ ì„ íƒ</h2>
        <label for="repoSelect">ì €ì¥ì†Œ:</label>
        <select id="repoSelect"></select>
        <div class="controls-container">
            <button id="loadRepoButton" disabled>íŒŒì¼ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°</button>
            <!-- Logout button is no longer here -->
        </div>
    </div>

    <!-- 3. File Browser -->
    <div id="fileBrowserSection" class="section hidden">
        <h2>3. íŒŒì¼ íƒìƒ‰ê¸°</h2>
        <div><strong>í˜„ì¬ ì €ì¥ì†Œ:</strong> <span id="currentRepo"></span></div>
        <div class="breadcrumb"><strong>ê²½ë¡œ:</strong> <span id="currentPathBreadcrumb">/</span></div>
        <div id="fileList">
            <ul></ul>
        </div>
         <div class="controls-container"> <!-- Wrap button in container for consistency -->
            <button id="createNewFileButton">ìƒˆ íŒŒì¼ ë§Œë“¤ê¸° (Hugo)</button>
        </div>
    </div>

    <!-- 4. File Editor -->
    <div id="editorSection" class="section hidden">
        <h2>4. íŒŒì¼ í¸ì§‘ê¸° / Front Matter (TOML)</h2>
        <input type="hidden" id="currentFileSha">
        <input type="hidden" id="currentFilePathInput">

         <label for="fmTitleInput">Title (í•„ìˆ˜, íŒŒì¼ëª… ìƒì„±ì— ì‚¬ìš©):</label>
         <input type="text" id="fmTitleInput" placeholder="ê²Œì‹œë¬¼ ì œëª©">

         <label for="fileNameInput">íŒŒì¼ ì´ë¦„ (ìë™ ìƒì„±/í¸ì§‘ ê°€ëŠ¥, í™•ì¥ì .md ê³ ì •):</label>
         <input type="text" id="fileNameInput" placeholder="my-new-post.md (Title ì…ë ¥ ì‹œ ìë™ ìƒì„±)">

        <hr>
        <h3>Hugo Front Matter (TOML)</h3>
        <label for="fmAuthorInput">Author:</label>
        <input type="text" id="fmAuthorInput" placeholder="ì‘ì„±ì (ì„ íƒ ì‚¬í•­)">

        <label for="fmDateInput">Date (í•„ìˆ˜, YYYY-MM-DDTHH:MM:SSZ í˜•ì‹ ê¶Œì¥):</label>
        <input type="text" id="fmDateInput" placeholder="ì˜ˆ: 2023-10-27T15:04:05+09:00 ë˜ëŠ” 2023-10-27T06:04:05Z">

        <label for="fmDescriptionInput">Description:</label>
        <input type="text" id="fmDescriptionInput" placeholder="ê°„ë‹¨í•œ ì„¤ëª… (ì„ íƒ ì‚¬í•­)">

        <label for="fmTagsInput">Tags (ì‰¼í‘œë¡œ êµ¬ë¶„):</label>
        <input type="text" id="fmTagsInput" placeholder="ì˜ˆ: web, development, github">

        <label for="fmCategoriesInput">Categories (ì‰¼í‘œë¡œ êµ¬ë¶„):</label>
        <input type="text" id="fmCategoriesInput" placeholder="ì˜ˆ: tech, programming">

        <div>
             <input type="checkbox" id="fmTocCheckbox">
             <label for="fmTocCheckbox">Table of Contents (TOC) ìƒì„±</label>
        </div>
        <hr>

        <label for="fileContentInput">íŒŒì¼ ë‚´ìš© (ë³¸ë¬¸ - Markdown ë“±):</label>
        <textarea id="fileContentInput" placeholder="ì—¬ê¸°ì— Markdown ë³¸ë¬¸ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”..."></textarea>

        <hr>
        <label for="commitMessageInput">ì»¤ë°‹ ë©”ì‹œì§€ (ìë™ ìƒì„±/í¸ì§‘ ê°€ëŠ¥):</label>
        <input type="text" id="commitMessageInput" placeholder="ìë™ ìƒì„± ë˜ëŠ” ì§ì ‘ ì…ë ¥">

        <div class="controls-container"> <!-- Container for editor buttons -->
            <button id="saveFileButton">ì €ì¥ (ìƒì„±/ìˆ˜ì •)</button>
            <button id="deleteFileButton" style="background-color: #dc3545;">ì‚­ì œ</button>
            <button id="cancelEditButton" style="background-color: #6c757d;">ì·¨ì†Œ</button>
        </div>
    </div>


    <!-- Status Bar -->
    <div id="statusBar">ìƒíƒœ: ëŒ€ê¸° ì¤‘...</div>

</div>

<script type="module">
    // Import Octokit via CDN (esm.sh)
    import { Octokit } from "https://esm.sh/octokit";

    // --- Global Variables ---
    let octokit = null;
    let selectedOwner = null;
    let selectedRepo = null;
    let currentPath = '';
    let currentFiles = [];
    let currentBranch = 'main'; // Or your default branch
    const PAT_STORAGE_KEY = 'githubPat'; // Use localStorage

    // --- DOM Elements ---
    const patInput = document.getElementById('patInput');
    const loginButton = document.getElementById('loginButton');
    const logoutButton = document.getElementById('logoutButton'); // Reference remains valid
    const repoSelect = document.getElementById('repoSelect');
    const loadRepoButton = document.getElementById('loadRepoButton');
    const fileListUl = document.querySelector('#fileList ul');
    const currentRepoSpan = document.getElementById('currentRepo');
    const currentPathBreadcrumb = document.getElementById('currentPathBreadcrumb');
    const fileNameInput = document.getElementById('fileNameInput');
    const fmTitleInput = document.getElementById('fmTitleInput');
    const fmAuthorInput = document.getElementById('fmAuthorInput');
    const fmDateInput = document.getElementById('fmDateInput');
    const fmDescriptionInput = document.getElementById('fmDescriptionInput');
    const fmTagsInput = document.getElementById('fmTagsInput');
    const fmCategoriesInput = document.getElementById('fmCategoriesInput');
    const fmTocCheckbox = document.getElementById('fmTocCheckbox');
    const fileContentInput = document.getElementById('fileContentInput');
    const commitMessageInput = document.getElementById('commitMessageInput');
    const currentFileShaInput = document.getElementById('currentFileSha');
    const currentFilePathInput = document.getElementById('currentFilePathInput');
    const saveFileButton = document.getElementById('saveFileButton');
    const deleteFileButton = document.getElementById('deleteFileButton');
    const cancelEditButton = document.getElementById('cancelEditButton');
    const createNewFileButton = document.getElementById('createNewFileButton');
    const statusBar = document.getElementById('statusBar');
    const loginSection = document.getElementById('loginSection');
    const repoSection = document.getElementById('repoSection');
    const fileBrowserSection = document.getElementById('fileBrowserSection');
    const editorSection = document.getElementById('editorSection');


    // --- Helper Functions ---
     /**
     * Updates the status bar message and style.
     * @param {string} message - The message to display.
     * @param {boolean} [isError=false] - True if the message is an error.
     * @param {boolean} [isSuccess=false] - True if the message is a success indicator.
     */
     function updateStatus(message, isError = false, isSuccess = false) {
        statusBar.textContent = `ìƒíƒœ: ${message}`;
        statusBar.className = ''; // Reset classes first
        statusBar.classList.add('status-bar'); // Add base class
        if (isError) {
            statusBar.classList.add('status-bar-error');
        } else if (isSuccess) {
            statusBar.classList.add('status-bar-success');
        }
        console[isError ? 'error' : 'log'](`Status Update: ${message}`);
    }

    /**
     * Shows the specified section and hides others.
     * @param {HTMLElement | null} sectionToShow - The section element to show, or null to hide all.
     */
    function showSection(sectionToShow) {
        [loginSection, repoSection, fileBrowserSection, editorSection].forEach(section => {
            if (section) section.classList.add('hidden');
        });
        if (sectionToShow) {
            sectionToShow.classList.remove('hidden');
        }
    }

    /**
     * Encodes a string to Base64, supporting Unicode characters.
     * @param {string} str - The string to encode.
     * @returns {string} The Base64 encoded string.
     * @throws {Error} If encoding fails.
     */
    function b64EncodeUnicode(str) {
        try {
            // Use TextEncoder to get UTF-8 bytes, then convert to binary string for btoa
            const bytes = new TextEncoder().encode(str);
            let binary = '';
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        } catch (e) {
             console.error("Base64 ì¸ì½”ë”© ì‹¤íŒ¨:", e);
             updateStatus("Base64 ì¸ì½”ë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ.", true);
             throw new Error("Base64 ì¸ì½”ë”© ì‹¤íŒ¨");
        }
    }

   /**
     * Decodes a Base64 string, supporting Unicode characters (UTF-8).
     * @param {string} str - The Base64 encoded string.
     * @returns {string} The decoded string.
     * @throws {Error} If decoding fails or results in invalid UTF-8.
     */
    function b64DecodeUnicode(str) {
        try {
            const binary_string = atob(str);
            const bytes = new Uint8Array(binary_string.length);
            for (let i = 0; i < binary_string.length; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            // Use TextDecoder with fatal option to catch invalid UTF-8 sequences
            return new TextDecoder('utf-8', { fatal: true }).decode(bytes);
        } catch (e) {
            // Handle potential errors from atob (invalid base64) or TextDecoder (invalid UTF-8)
            console.error("Base64/UTF-8 ë””ì½”ë”© ì‹¤íŒ¨:", e);
            updateStatus('Base64 ë˜ëŠ” UTF-8 ë””ì½”ë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ. íŒŒì¼ ë‚´ìš©ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ UTF-8 ì¸ì½”ë”©ì´ ì•„ë‹ ìˆ˜ ìˆìŠµë‹ˆë‹¤.', true);
            throw new Error("Base64/UTF-8 ë””ì½”ë”© ì‹¤íŒ¨: " + e.message);
        }
    }


    // --- Hugo Front Matter Parsing/Formatting ---
     /**
     * Parses Hugo TOML front matter and separates it from the body content.
     * Handles basic string, boolean, and array (tags, categories) types.
     * @param {string} content - The full file content.
     * @returns {object} An object containing parsed front matter fields and the body content.
     */
     function parseFrontMatter(content) {
        const fm = {
            title: '', author: '', date: '', description: '',
            tags: [], categories: [], toc: undefined, // Use undefined to distinguish from explicit false
            body: content // Default body is the whole content if no FM found
        };
        // Regex to find TOML block (+++ ... +++) and capture FM block and body
        const fmRegex = /^\+\+\+\s*([\s\S]*?)\s*\+\+\+([\s\S]*)/;
        const match = content.match(fmRegex);

        if (match && match[1] && match[2] !== undefined) {
            // Found FM block
            const frontMatterBlock = match[1].trim();
            fm.body = match[2].trimStart(); // Keep leading whitespace in body if desired
            const lines = frontMatterBlock.split('\n');
            let currentKey = null;
            let accumulatingArrayContent = null; // For multi-line arrays

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();

                // Skip empty lines and comments
                if (!trimmedLine || trimmedLine.startsWith('#')) continue;

                // Continue accumulating multi-line array content
                if (accumulatingArrayContent !== null) {
                    accumulatingArrayContent += "\n" + line; // Re-add newline for parsing context if needed
                    if (line.includes(']')) { // End of multi-line array detected
                        try {
                            // Find the full array string from '[' to ']'
                            const startIndex = accumulatingArrayContent.indexOf('[');
                            const endIndex = accumulatingArrayContent.lastIndexOf(']');
                            if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                                let arrayString = accumulatingArrayContent.substring(startIndex + 1, endIndex).trim();
                                // Parse the items inside the array string
                                let values = [];
                                if (arrayString) {
                                    // Split by comma, trim, filter comments/empty, remove quotes
                                    values = arrayString.split(',')
                                        .map(item => item.trim())
                                        .filter(item => item && !item.startsWith('#')) // Filter out comments within array lines
                                        .map(item => {
                                            if (item.startsWith('"') && item.endsWith('"')) return item.substring(1, item.length - 1).replace(/\\"/g, '"');
                                            if (item.startsWith("'") && item.endsWith("'")) return item.substring(1, item.length - 1).replace(/\\'/g, "'");
                                            return item; // Return as is if not quoted
                                        });
                                }
                                if (currentKey === 'tags' || currentKey === 'categories') {
                                    fm[currentKey] = values;
                                }
                            } else {
                                // This could happen if brackets are mismatched or nested incorrectly
                                throw new Error("Invalid or mismatched closing bracket ']'");
                            }
                        } catch (e) {
                            console.error(`Error parsing accumulated multi-line array for key ${currentKey}:`, accumulatingArrayContent, e);
                            updateStatus(`Front matter multi-line ë°°ì—´ êµ¬ë¬¸ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (${currentKey}): ${e.message}`, true);
                             // Reset to empty array on error
                            if (currentKey && (currentKey === 'tags' || currentKey === 'categories')) fm[currentKey] = [];
                        } finally {
                            accumulatingArrayContent = null; // Reset accumulator
                            currentKey = null; // Reset current key
                        }
                    }
                    // If ']' not found yet, continue accumulating on next iteration
                } else { // Not currently accumulating an array
                    // Look for 'key = value'
                    const eqIndex = trimmedLine.indexOf('=');
                    if (eqIndex > 0) {
                        const key = trimmedLine.substring(0, eqIndex).trim();
                        let valuePart = trimmedLine.substring(eqIndex + 1).trim();

                        // Handle arrays (single line or start of multi-line)
                        if ((key === 'tags' || key === 'categories') && valuePart.startsWith('[')) {
                             if (valuePart.includes(']') && valuePart.lastIndexOf(']') > valuePart.indexOf('[')) { // Single-line array
                                try {
                                    const startIndex = valuePart.indexOf('[');
                                    const endIndex = valuePart.lastIndexOf(']');
                                    let arrayString = valuePart.substring(startIndex + 1, endIndex).trim();
                                    let values = [];
                                    if (arrayString) {
                                        values = arrayString.split(',')
                                            .map(item => item.trim())
                                            .filter(item => item && !item.startsWith('#'))
                                            .map(item => {
                                                if (item.startsWith('"') && item.endsWith('"')) return item.substring(1, item.length - 1).replace(/\\"/g, '"');
                                                if (item.startsWith("'") && item.endsWith("'")) return item.substring(1, item.length - 1).replace(/\\'/g, "'");
                                                return item;
                                            });
                                    }
                                    fm[key] = values;
                                } catch(e) {
                                    console.error(`Error parsing single-line array for key ${key}:`, valuePart, e);
                                    updateStatus(`Front matter ë°°ì—´ êµ¬ë¬¸ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (${key}): ${e.message}`, true);
                                    fm[key] = []; // Reset on error
                                }
                            } else { // Start of a multi-line array
                                currentKey = key;
                                accumulatingArrayContent = valuePart; // Start accumulating
                            }
                        } else { // Handle simple values (string, boolean)
                            try {
                                let parsedValue = valuePart;
                                // Remove surrounding quotes and unescape internal quotes
                                if (parsedValue.startsWith('"') && parsedValue.endsWith('"')) {
                                    parsedValue = parsedValue.substring(1, parsedValue.length - 1).replace(/\\"/g, '"');
                                } else if (parsedValue.startsWith("'") && parsedValue.endsWith("'")) {
                                     parsedValue = parsedValue.substring(1, parsedValue.length - 1).replace(/\\'/g, "'");
                                } else if (parsedValue === 'true') { // Parse boolean true
                                    parsedValue = true;
                                } else if (parsedValue === 'false') { // Parse boolean false
                                    parsedValue = false;
                                }
                                // Assign to known fm fields
                                if (['title', 'author', 'date', 'description', 'toc'].includes(key)) {
                                     if (key === 'toc') {
                                         // Only assign if it's explicitly true or false
                                         if (typeof parsedValue === 'boolean') {
                                             fm[key] = parsedValue;
                                         } else {
                                             // Warn if toc has a non-boolean value, maybe set to default?
                                             console.warn(`FM parsing: Expected boolean for 'toc', got:`, parsedValue);
                                         }
                                     } else {
                                        // Assign others as strings (even if originally numbers, keep as string)
                                        fm[key] = String(parsedValue);
                                     }
                                }
                                // Ignore unknown keys or handle them if needed
                            } catch (parseError) {
                                 console.error(`Error parsing simple front matter line: "${line}"`, parseError);
                                 updateStatus(`Front matter êµ¬ë¬¸ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${line}`, true);
                            }
                        }
                    } else {
                        // Line doesn't contain '=', might be part of a multi-line string or invalid
                        console.warn(`Invalid front matter line (no '=' found, ignoring): "${trimmedLine}"`);
                    }
                }
            } // End of line loop

            // Check if we ended while still accumulating an array (means ']' was missing)
            if (accumulatingArrayContent !== null) {
                console.error(`Front matter parsing ended unexpectedly inside an unclosed array for key: ${currentKey}`);
                updateStatus(`Front matter ì˜¤ë¥˜: ${currentKey} ë°°ì—´ì´ ë‹«íˆì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`, true);
                // Reset the incomplete array
                if (currentKey && (currentKey === 'tags' || currentKey === 'categories')) {
                     fm[currentKey] = [];
                }
            }
        } else {
            // No match for FM regex, treat entire content as body
            // fm.body is already set to content by default
            console.log("No TOML front matter detected or block is malformed.");
        }
        return fm;
    }


    /**
     * Formats the front matter data object back into a TOML string.
     * Ensures strings are properly quoted and escaped.
     * @param {object} fmData - The front matter data object from the form.
     * @returns {string} The formatted TOML front matter string, ready to prepend to the body.
     */
    function formatFrontMatter(fmData) {
        let fmString = '+++\n';
        // Helper to format TOML strings (quote and escape)
        const formatTomlString = (str) => `"${String(str).replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
        // Helper to format TOML arrays
        const formatTomlArray = (arr) => `[${arr.map(formatTomlString).join(', ')}]`;

        // Add fields only if they have a value
        if (fmData.title) fmString += `title = ${formatTomlString(fmData.title)}\n`;
        if (fmData.date) fmString += `date = ${formatTomlString(fmData.date)}\n`; // Dates are typically strings in TOML FM
        if (fmData.author) fmString += `author = ${formatTomlString(fmData.author)}\n`;
        if (fmData.description) fmString += `description = ${formatTomlString(fmData.description)}\n`;
        if (fmData.categories && fmData.categories.length > 0) fmString += `categories = ${formatTomlArray(fmData.categories)}\n`;
        if (fmData.tags && fmData.tags.length > 0) fmString += `tags = ${formatTomlArray(fmData.tags)}\n`;

        // Only include 'toc' if it's explicitly set to true
        if (fmData.toc === true) {
            fmString += `toc = true\n`;
        }
        // Note: If toc is false or undefined, it's omitted, which is Hugo's default behavior (usually no TOC).

        fmString += '+++\n\n'; // Closing delimiter and blank line separator
        return fmString;
    }


    // --- UI Helper Functions ---
    /**
     * Generates a Hugo-friendly filename from a title string.
     * Replaces spaces with hyphens, removes special characters, converts to lowercase.
     * @param {string} title - The input title.
     * @returns {string} The generated filename with .md extension.
     */
     function generateHugoFilename(title) {
        if (!title || !title.trim()) return 'untitled.md';
        // Remove leading/trailing spaces, convert to lowercase
        const cleanedTitle = title.trim().toLowerCase()
            // Replace problematic characters (adjust list as needed) with nothing
            .replace(/[\\/:\?\*"<>\|#;\$'\{\}\+=~@%^&\(\)\[\]\.!,`]/g, '')
            // Replace one or more whitespace characters with a single hyphen
            .replace(/\s+/g, '-')
            // Remove leading/trailing hyphens that might result from replacements
            .replace(/^-+|-+$/g, '');
        // If cleaning resulted in an empty string, default to 'untitled'
        return (cleanedTitle || 'untitled') + '.md';
    }

    /**
     * Updates the commit message input field based on the current filename and operation type.
     */
    function updateCommitMessage() {
        const filename = fileNameInput.value.trim();
        const isUpdate = !!currentFileShaInput.value; // True if editing an existing file (has SHA)
        if (filename) {
             // Suggest a default commit message
             commitMessageInput.value = isUpdate ? `Update content for ${filename}` : `Create ${filename}`;
             // Update placeholder to show the example
             commitMessageInput.placeholder = `ì˜ˆ: ${commitMessageInput.value}`;
        } else {
             // Clear if no filename
             commitMessageInput.value = '';
             commitMessageInput.placeholder = 'ìë™ ìƒì„± ë˜ëŠ” ì§ì ‘ ì…ë ¥';
        }
    }

    /**
     * Generates and updates the breadcrumb navigation based on `currentPath`.
     */
    function updateBreadcrumb() {
        currentPathBreadcrumb.innerHTML = ''; // Clear previous breadcrumb
        // Add root link
        const rootLink = document.createElement('a');
        rootLink.href = '#';
        rootLink.textContent = 'root';
        rootLink.onclick = (e) => { e.preventDefault(); fetchContents(''); };
        currentPathBreadcrumb.appendChild(rootLink);

        const pathParts = currentPath.split('/').filter(p => p); // Split path and remove empty parts
        let accumulatedPath = '';
        pathParts.forEach((part, index) => {
            // Build the path incrementally for each part's link
            accumulatedPath += (index > 0 ? '/' : '') + part;
            // Add separator
            const pathSeparator = document.createElement('span');
            pathSeparator.textContent = ' / ';
            currentPathBreadcrumb.appendChild(pathSeparator);

            // Add link for the path part
            const partLink = document.createElement('a');
            partLink.href = '#';
            partLink.textContent = part;
            // Need to capture the path for this link's specific scope
            const currentAccumulatedPath = accumulatedPath;
            partLink.onclick = (e) => { e.preventDefault(); fetchContents(currentAccumulatedPath); };
            currentPathBreadcrumb.appendChild(partLink);
        });

        // Make the last part of the breadcrumb (current directory) non-clickable bold text
        if (pathParts.length > 0) {
            const lastPartElement = currentPathBreadcrumb.lastChild; // Get the last element (should be the link)
            if (lastPartElement && lastPartElement.tagName === 'A') {
                // Replace the last link with strong text
                const currentPartStrong = document.createElement('strong');
                currentPartStrong.textContent = lastPartElement.textContent;
                currentPathBreadcrumb.replaceChild(currentPartStrong, lastPartElement);
            }
        } else {
            // If at root, make 'root' bold instead of a link
             rootLink.outerHTML = '<strong>root</strong>'; // Replace the root link element
        }
    }

    /**
     * Adds a '..' (Parent Directory) link to the top of the file list if not at root.
     * @param {string} currentDirPath - The current directory path being listed.
     */
    function addParentDirectoryLink(currentDirPath) {
         if (currentDirPath && currentDirPath !== '') { // Only add if not at the root
             // Calculate parent path
             const parentPath = currentDirPath.includes('/') ? currentDirPath.substring(0, currentDirPath.lastIndexOf('/')) : ''; // Go to root if it's a top-level dir
             const li = document.createElement('li');
             li.innerHTML = '<strong>â¬†ï¸ .. (ìƒìœ„ í´ë”)</strong>'; // Use bold or specific class
             li.style.cursor = 'pointer';
             li.title = `ìƒìœ„ í´ë”ë¡œ ì´ë™: /${parentPath}`;
             li.onclick = () => fetchContents(parentPath);
             // Add it to the beginning of the list
             if (fileListUl.firstChild) {
                 fileListUl.insertBefore(li, fileListUl.firstChild);
             } else {
                 fileListUl.appendChild(li);
             }
         }
    }

    /**
     * Clears all fields in the editor form and resets related state variables.
     */
     function clearEditorFields() {
        fileNameInput.value = '';
        fmTitleInput.value = '';
        fmAuthorInput.value = '';
        fmDateInput.value = '';
        fmDescriptionInput.value = '';
        fmTagsInput.value = '';
        fmCategoriesInput.value = '';
        fmTocCheckbox.checked = false;
        fileContentInput.value = '';
        commitMessageInput.value = '';
        commitMessageInput.placeholder = 'ìë™ ìƒì„± ë˜ëŠ” ì§ì ‘ ì…ë ¥';
        currentFileShaInput.value = '';   // Clear SHA (indicates new file or no file selected)
        currentFilePathInput.value = ''; // Clear path
        // Disable buttons that require a file context
        saveFileButton.disabled = true;
        saveFileButton.textContent = 'ì €ì¥ (ìƒì„±/ìˆ˜ì •)'; // Reset text
        deleteFileButton.disabled = true;
        cancelEditButton.disabled = true; // Usually enabled when editor shown, but good practice to reset
    }


    // --- Logout Function ---
    /**
     * Handles the logout process: clears stored PAT, resets Octokit instance,
     * and reloads the page to ensure a clean state.
     */
    function handleLogout() {
        console.log("Logging out: Clearing PAT and reloading...");
        localStorage.removeItem(PAT_STORAGE_KEY); // Clear PAT from storage
        octokit = null; // Clear the Octokit instance
        // No need to explicitly hide logoutButton here, as the page reload
        // will reset it to its initial hidden state from the HTML.
        location.reload();
    }


    // --- Core Authentication and Repo Loading ---
    /**
     * Attempts to authenticate with GitHub using the provided PAT, fetches user repositories,
     * populates the repository dropdown, and updates the UI. Stores PAT in localStorage on success.
     * Controls visibility of the global logout button.
     * @param {string} token - The GitHub Personal Access Token.
     * @param {boolean} [isAutoLogin=false] - Indicates if this is an automatic attempt on page load using stored PAT.
     */
     async function authenticateAndLoadRepos(token, isAutoLogin = false) {
        if (!token) {
            console.error("Authentication attempt with no token provided.");
            if (!isAutoLogin) {
                 resetToLoginScreen();
                 updateStatus('ì˜¤ë¥˜: GitHub PATê°€ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.', true);
            } else {
                showSection(loginSection);
            }
            return;
        }

        // --- UI updates during login ---
        patInput.disabled = true;
        loginButton.disabled = true;
        loginButton.textContent = 'ë¡œë”© ì¤‘...';
        // Hide logout button during the attempt
        logoutButton.classList.add('hidden'); // Ensure hidden during login process
        repoSelect.disabled = true;
        loadRepoButton.disabled = true;

        const statusMsg = isAutoLogin
            ? 'ì €ì¥ëœ PATë¡œ ì¸ì¦ ë° ì €ì¥ì†Œ ëª©ë¡ ë¡œë”© ì¤‘...'
            : 'GitHub ì¸ì¦ ë° ì €ì¥ì†Œ ëª©ë¡ ë¡œë”© ì¤‘...';
        updateStatus(statusMsg);
        let clearToken = false; // Flag for specific errors like 401

        try {
            // 1. Initialize Octokit
            octokit = new Octokit({ auth: token });

            // 2. Verify authentication
            const { data: user } = await octokit.rest.users.getAuthenticated();
            console.log("Authenticated successfully as user:", user.login);

            // --- SUCCESSFUL AUTHENTICATION ---
            // Show the logout button now that authentication is confirmed
            logoutButton.classList.remove('hidden'); // <<<--- SHOW LOGOUT BUTTON

            // 3. Fetch repositories
            updateStatus(`ì‚¬ìš©ì '${user.login}' ì¸ì¦ ì™„ë£Œ. ì €ì¥ì†Œ ëª©ë¡ ë¡œë”© ì¤‘...`);
            const repos = await octokit.paginate(octokit.rest.repos.listForAuthenticatedUser, {
                affiliation: 'owner,collaborator',
                per_page: 100,
                sort: 'updated',
            });

            // 4. Populate repository select
            repoSelect.innerHTML = '<option value="">-- ì €ì¥ì†Œ ì„ íƒ --</option>';

            if (repos && repos.length > 0) {
                repos.forEach(repo => {
                    const option = document.createElement('option');
                    option.value = `${repo.owner.login}/${repo.name}`;
                    option.textContent = `${repo.full_name} (${repo.private ? 'Private' : 'Public'})`;
                    repoSelect.appendChild(option);
                });
                localStorage.setItem(PAT_STORAGE_KEY, token); // Store PAT on success

                // --- UI updates after successful login and repo load ---
                showSection(repoSection);
                repoSelect.disabled = false;
                if (repoSelect.options.length > 1) {
                    repoSelect.selectedIndex = 1;
                    loadRepoButton.disabled = false;
                    updateStatus(`${repos.length}ê°œì˜ ì ‘ê·¼ ê°€ëŠ¥í•œ ì €ì¥ì†Œ ë¡œë“œ ì™„ë£Œ. ì²«ë²ˆì§¸ ì €ì¥ì†Œê°€ ìë™ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤.`, false, true);
                } else {
                    loadRepoButton.disabled = true;
                    updateStatus('ì ‘ê·¼ ê°€ëŠ¥í•œ ì €ì¥ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. PAT ê¶Œí•œì´ë‚˜ ì €ì¥ì†Œ ìœ ë¬´ë¥¼ í™•ì¸í•˜ì„¸ìš”.', true);
                }
                // Update login section appearance (already authenticated)
                patInput.value = '********';
                patInput.disabled = true;
                loginButton.textContent = 'ì¸ì¦ ì™„ë£Œ';
                loginButton.disabled = true;
            } else {
                // User authenticated, but no accessible repositories found
                updateStatus('ì¸ì¦ ì„±ê³µ, í•˜ì§€ë§Œ ì ‘ê·¼ ê°€ëŠ¥í•œ ì €ì¥ì†Œê°€ ì—†ìŠµë‹ˆë‹¤. PATì— `repo` ê¶Œí•œì´ ìˆëŠ”ì§€, ì €ì¥ì†Œê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.', true);
                localStorage.setItem(PAT_STORAGE_KEY, token); // Store PAT even if no repos
                showSection(repoSection);
                repoSelect.disabled = true;
                loadRepoButton.disabled = true;
                 // Update login section appearance (already authenticated)
                patInput.value = '********';
                patInput.disabled = true;
                loginButton.textContent = 'ì¸ì¦ ì™„ë£Œ';
                loginButton.disabled = true;
                 // Logout button remains visible here because auth was successful
            }
        } catch (error) {
            console.error("Authentication or Repository Fetch Error:", error);
            let errorMsg = `ì¸ì¦ ë˜ëŠ” ì €ì¥ì†Œ ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error.message}`;

            if (error.status === 401) {
                errorMsg = `GitHub API ì¸ì¦ ì˜¤ë¥˜ (401): PATê°€ ìœ íš¨í•˜ì§€ ì•Šê±°ë‚˜ í•„ìš”í•œ 'repo' ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. PATë¥¼ í™•ì¸í•˜ê³  ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.`;
                clearToken = true;
            } else if (error.status === 403) {
                errorMsg = `GitHub API ì ‘ê·¼ ì˜¤ë¥˜ (403): ê¶Œí•œ ë¬¸ì œ ë˜ëŠ” API ì†ë„ ì œí•œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ GitHub ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.`;
            } else if (error.status === 404) {
                 errorMsg = `GitHub API ì—”ë“œí¬ì¸íŠ¸ ì˜¤ë¥˜ (404): ì‚¬ìš©ì ë˜ëŠ” ì¸ì¦ ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ë“œë¬¸ ê²½ìš°)`;
            } else {
                errorMsg = `GitHub API í†µì‹  ì˜¤ë¥˜ (${error.status || 'Network Error'}): ${error.message}. ì¸í„°ë„· ì—°ê²° ë° GitHub ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”.`;
            }

            updateStatus(errorMsg, true);

            if (clearToken) { localStorage.removeItem(PAT_STORAGE_KEY); }
            octokit = null;
             // --- AUTHENTICATION FAILED ---
             // Ensure logout button is hidden on failure
             logoutButton.classList.add('hidden'); // <<<--- ENSURE LOGOUT HIDDEN ON ERROR
            resetToLoginScreen((clearToken || isAutoLogin) ? '' : token); // Reset UI to login
        }
    }

    // --- Function to Reset UI to Logged-Out State (without page reload) ---
    /**
     * Resets the UI to the initial login screen state. Hides the global logout button.
     * @param {string} [tokenToKeepInInput=''] - Optional token to keep in input field.
     */
    function resetToLoginScreen(tokenToKeepInInput = '') {
         showSection(loginSection); // Show only the login section
         // Reset login section controls
         patInput.disabled = false;
         patInput.value = tokenToKeepInInput;
         if (!patInput.value) patInput.placeholder = "GitHub PAT ì…ë ¥ (repo ê¶Œí•œ í•„ìš”)";
         loginButton.disabled = false;
         loginButton.textContent = 'ë¡œê·¸ì¸í•˜ê¸°';
         // --- Explicitly hide the global logout button when resetting to login ---
         logoutButton.classList.add('hidden'); // <<<--- HIDE LOGOUT BUTTON
         // Ensure repo section controls are reset
         repoSelect.innerHTML = '';
         repoSelect.disabled = true;
         loadRepoButton.disabled = true;
         // Ensure file browser/editor buttons are disabled/reset
         createNewFileButton.disabled = true;
         // Clear potential leftover state variables
         selectedOwner = null;
         selectedRepo = null;
         currentPath = '';
         currentFiles = [];
         if (currentRepoSpan) currentRepoSpan.textContent = '';
         if (currentPathBreadcrumb) updateBreadcrumb(); // Reset breadcrumb
         if (fileListUl) fileListUl.innerHTML = '';
         // Important: Ensure Octokit instance is nullified
         octokit = null;
         // Clear editor fields as well
         clearEditorFields();
    }


    // --- Event Handlers ---

    /** Login Button Click Event */
    loginButton.addEventListener('click', () => {
        const tokenFromInput = patInput.value.trim();
        if (!tokenFromInput) {
            updateStatus('ì˜¤ë¥˜: GitHub Personal Access Token (PAT)ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.', true);
            patInput.focus();
            return;
        }
        authenticateAndLoadRepos(tokenFromInput, false);
    });

    /** Logout Button Click Event */
    logoutButton.addEventListener('click', handleLogout);

    /** Repository Selection Change Event */
    repoSelect.addEventListener('change', () => {
        loadRepoButton.disabled = repoSelect.value === '';
    });

    /** Load Repository Button Click Event */
    loadRepoButton.addEventListener('click', () => {
        const selectedRepoFullName = repoSelect.value;
        if (!selectedRepoFullName || !selectedRepoFullName.includes('/')) {
            updateStatus("ì˜¤ë¥˜: ìœ íš¨í•œ ì €ì¥ì†Œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.", true);
            return;
        };
        if (!octokit || !localStorage.getItem(PAT_STORAGE_KEY)) {
            updateStatus("ì˜¤ë¥˜: ì¸ì¦ ì •ë³´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.", true);
            handleLogout();
            return;
        }

        [selectedOwner, selectedRepo] = selectedRepoFullName.split('/');
        if(currentRepoSpan) currentRepoSpan.textContent = selectedRepoFullName;

        updateStatus(`'${selectedRepoFullName}' ì €ì¥ì†Œì˜ ë£¨íŠ¸ í´ë” ë¡œë”© ì¤‘...`);
        repoSelect.disabled = true;
        loadRepoButton.disabled = true;
        // logoutButton.disabled = true; // No longer disable global logout here

        showSection(fileBrowserSection);
        fetchContents('');
    });

    /** Fetch Directory Contents */
    async function fetchContents(path) {
         // --- Pre-API Call Checks ---
         const token = localStorage.getItem(PAT_STORAGE_KEY);
         if (!token || !octokit) {
             updateStatus("ì˜¤ë¥˜: ì¸ì¦ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¡œê·¸ì•„ì›ƒí•©ë‹ˆë‹¤.", true);
             handleLogout();
             return;
         }
         if (!selectedOwner || !selectedRepo) {
             updateStatus("ì˜¤ë¥˜: ì €ì¥ì†Œ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì €ì¥ì†Œë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.", true);
             showSection(repoSection);
             repoSelect.disabled = false;
             loadRepoButton.disabled = repoSelect.value === '';
             // logout button state is independent
             return;
         }

        // --- UI Update for Loading State ---
        currentPath = path;
        updateBreadcrumb();
        fileListUl.innerHTML = `<li><em><center>í´ë” ë‚´ìš© ë¡œë”© ì¤‘...</center></em></li>`;
        showSection(fileBrowserSection);
        editorSection.classList.add('hidden');
        createNewFileButton.disabled = true;
        updateStatus(`'${selectedOwner}/${selectedRepo}/${path || 'root'}' ë‚´ìš© ë¡œë”© ì¤‘...`);
        // No need to disable repo controls or global logout here usually

        try {
            // --- GitHub API Call ---
            const { data: contents } = await octokit.rest.repos.getContent({
                owner: selectedOwner, repo: selectedRepo, path: path, ref: currentBranch,
                 // cache bust
                // headers: { 'If-None-Match': '' } // More robust cache busting if needed
            });

            const contentList = Array.isArray(contents) ? contents : [contents];
            currentFiles = contentList
                .filter(item => item.type === 'file' || item.type === 'dir')
                .sort((a, b) => {
                    if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                    return a.name.localeCompare(b.name, 'ko', { sensitivity: 'base' });
                });

            // --- Update File List UI ---
            fileListUl.innerHTML = '';
            addParentDirectoryLink(path);

            if (currentFiles.length > 0) {
                currentFiles.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item.name;
                    li.classList.add(item.type);
                    li.dataset.path = item.path;
                    li.dataset.type = item.type;
                    li.dataset.sha = item.sha;

                    if (item.type === 'dir') {
                        li.onclick = () => fetchContents(item.path);
                        li.title = `í´ë” ì—´ê¸°: ${item.path}`;
                    } else if (item.type === 'file') {
                        const isEditable = /\.md$/i.test(item.name);
                        if (isEditable) {
                             li.title = `íŒŒì¼ ìˆ˜ì •: ${item.path}`;
                             li.onclick = () => fetchFileContent(item.path, item.sha);
                        } else {
                             li.style.cursor = 'default'; li.style.color = '#888';
                             li.title = `ì´ ì—ë””í„°ëŠ” Hugo .md íŒŒì¼ë§Œ í¸ì§‘ ê°€ëŠ¥ (${item.name})`;
                             li.onclick = (e) => e.stopPropagation();
                        }
                    }
                    fileListUl.appendChild(li);
                });
             } else {
                 const li = document.createElement('li');
                 li.innerHTML = `<em><center>${path === '' ? '(ì €ì¥ì†Œ ë£¨íŠ¸ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤)' : '(í´ë”ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤)'}</center></em>`;
                 li.style.cursor = 'default';
                 fileListUl.appendChild(li);
             }
             updateStatus(`'${selectedOwner}/${selectedRepo}/${path || 'root'}' ë¡œë“œ ì™„ë£Œ.`, false, true);

        } catch (error) {
             // --- Error Handling ---
             console.error("Fetch Contents Error:", error);
             let errorMsg = `í´ë” ë‚´ìš© ë¡œë“œ ì‹¤íŒ¨ (${path || 'root'}): ${error.message}`;
              if (error.status === 404) errorMsg = `ê²½ë¡œ '${path || 'root'}'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (404).`;
              else if (error.status === 403) errorMsg = `ì´ ì €ì¥ì†Œ ë˜ëŠ” ê²½ë¡œì— ì ‘ê·¼í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤ (403).`;
              else if (error.status === 401) {
                  errorMsg = `GitHub API ì¸ì¦ ì˜¤ë¥˜ (401): PATê°€ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¡œê·¸ì•„ì›ƒí•©ë‹ˆë‹¤.`;
                  updateStatus(errorMsg, true);
                  handleLogout(); // Force logout on 401
                  return;
              }
             updateStatus(errorMsg, true);
             fileListUl.innerHTML = ''; // Clear loading
             addParentDirectoryLink(path); // Still show parent link
             const errorLi = document.createElement('li');
             errorLi.className = 'error'; errorLi.style.cursor = 'default';
             errorLi.style.backgroundColor = '#f8d7da'; errorLi.style.color = '#721c24'; errorLi.style.padding = '10px';
             errorLi.textContent = `ì˜¤ë¥˜: í´ë” ë‚´ìš©ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (${error.message})`;
             fileListUl.appendChild(errorLi);
        } finally {
             // --- Final UI State Update ---
             if (octokit) { // Check if still authenticated
                 createNewFileButton.disabled = false;
                 repoSelect.disabled = false; // Re-enable repo controls if they were disabled
                 loadRepoButton.disabled = repoSelect.value === '';
                 // logoutButton state handled by auth functions
             }
             if (fileListUl) fileListUl.style.pointerEvents = 'auto';
        }
    }


    /** Fetch File Content for Editing */
    async function fetchFileContent(filePath, fileSha) {
         // --- Pre-API Call Checks ---
         if (!octokit) { handleLogout(); return; }
         if (!selectedOwner || !selectedRepo) {
             updateStatus("ì˜¤ë¥˜: ì €ì¥ì†Œ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", true);
             showSection(repoSection); return;
         }

        // --- UI Update for Loading State ---
        updateStatus(`'${filePath}' íŒŒì¼ ë‚´ìš© ë¡œë”© ì¤‘...`);
        createNewFileButton.disabled = true;
        if (fileListUl) fileListUl.style.pointerEvents = 'none';
        clearEditorFields();
        showSection(null); // Hide sections temporarily

        try {
            // --- GitHub API Call ---
             const { data: blobData } = await octokit.rest.git.getBlob({
                owner: selectedOwner, repo: selectedRepo, file_sha: fileSha
            });

            // --- Validate API Response ---
            if (!blobData || typeof blobData.content === 'undefined' || blobData.encoding !== 'base64' || !blobData.sha) {
                 throw new Error('API ì‘ë‹µ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤ (Blob).');
            }
            const sizeLimit = 1 * 1024 * 1024; // 1 MB
            if (blobData.size > sizeLimit) {
                 updateStatus(`ê²½ê³ : íŒŒì¼ í¬ê¸°(${(blobData.size / 1024 / 1024).toFixed(2)} MB)ê°€ í½ë‹ˆë‹¤.`, false);
            }

            // --- Decode and Parse Content ---
            const decodedContent = b64DecodeUnicode(blobData.content);
            const parsedData = parseFrontMatter(decodedContent);

            // --- Populate Editor Fields ---
            fileNameInput.value = filePath.substring(filePath.lastIndexOf('/') + 1);
            fmTitleInput.value = parsedData.title || '';
            fmAuthorInput.value = parsedData.author || '';
            fmDateInput.value = parsedData.date || '';
            fmDescriptionInput.value = parsedData.description || '';
            fmTagsInput.value = (parsedData.tags || []).join(', ');
            fmCategoriesInput.value = (parsedData.categories || []).join(', ');
            fmTocCheckbox.checked = (parsedData.toc === true);
            fileContentInput.value = parsedData.body || '';
            currentFileShaInput.value = blobData.sha;
            currentFilePathInput.value = filePath;

            // --- Update UI for Editor View ---
            saveFileButton.textContent = 'ì €ì¥ (ìˆ˜ì •)';
            saveFileButton.disabled = false;
            deleteFileButton.disabled = false;
            cancelEditButton.disabled = false;
            updateCommitMessage();
            updateStatus(`'${filePath}' ë¡œë“œ ì™„ë£Œ. í¸ì§‘ ê°€ëŠ¥í•©ë‹ˆë‹¤.`, false, true);
            showSection(editorSection);

        } catch (error) {
            // --- Error Handling ---
            console.error(`Fetch File Content Error (${filePath}):`, error);
            let errorMsg = `íŒŒì¼ ë‚´ìš© ë¡œë”© ì‹¤íŒ¨ (${filePath}): ${error.message}`;
             if (error.status === 404) errorMsg = `íŒŒì¼ Blob (SHA: ${fileSha})ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (404).`;
             else if (error.status === 403) errorMsg = `ì´ íŒŒì¼ì— ì ‘ê·¼í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤ (403).`;
             else if (error.status === 422) errorMsg = `ì˜ëª»ëœ ìš”ì²­ (422): SHA í˜•ì‹ ì˜¤ë¥˜ ê°€ëŠ¥ì„±.`;
             else if (error.message.includes('Base64') || error.message.includes('UTF-8')) errorMsg = `íŒŒì¼ ë””ì½”ë”© ì‹¤íŒ¨: ${error.message}`;
             else if (error.message.includes('Blob is too big')) errorMsg = `GitHub API ì˜¤ë¥˜: íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤.`;
             else if (error.status === 401) {
                  errorMsg = `GitHub API ì¸ì¦ ì˜¤ë¥˜ (401): PAT ë§Œë£Œë¨. ë¡œê·¸ì•„ì›ƒí•©ë‹ˆë‹¤.`;
                  updateStatus(errorMsg, true);
                  handleLogout();
                  return;
             }
            updateStatus(errorMsg, true);
            showSection(fileBrowserSection); // Go back to browser on error

        } finally {
             // --- Final UI State Update ---
             if (octokit) {
                 createNewFileButton.disabled = false;
                 if (fileListUl) fileListUl.style.pointerEvents = 'auto';
                 // Repo controls re-enabled in fetchContents finally block if needed
             }
        }
    }

    // --- Editor Actions (Create, Save, Delete, Cancel) ---

    /** Create New File Button Click */
     createNewFileButton.addEventListener('click', () => {
        if (!octokit) { handleLogout(); return; }
        clearEditorFields();

        try { // Default Date
            const now = new Date();
            const offsetMinutes = now.getTimezoneOffset();
            const offsetSign = offsetMinutes <= 0 ? '+' : '-';
            const offsetHours = Math.abs(offsetMinutes / 60);
            const offsetMins = Math.abs(offsetMinutes % 60);
            const timezoneString = offsetMinutes === 0 ? 'Z' : `${offsetSign}${String(Math.floor(offsetHours)).padStart(2, '0')}:${String(offsetMins).padStart(2, '0')}`;
            const pad = (num) => String(num).padStart(2, '0');
            const localISOString = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}T${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}${timezoneString}`;
            fmDateInput.value = localISOString;
        } catch (e) { console.error("Error generating default date:", e); }

        currentFileShaInput.value = '';
        currentFilePathInput.value = '';
        deleteFileButton.disabled = true;
        saveFileButton.textContent = 'ì €ì¥ (ìƒì„±)';
        saveFileButton.disabled = false;
        cancelEditButton.disabled = false;
        updateCommitMessage();
        updateStatus('ìƒˆ íŒŒì¼ ìƒì„± ì¤€ë¹„ ì™„ë£Œ. Title ì…ë ¥ ì‹œ íŒŒì¼ëª…/ì»¤ë°‹ ìë™ ìƒì„±.');
        showSection(editorSection);
        fmTitleInput.focus();
    });

    /** Save File Button Click (Handles both Create and Update) */
    saveFileButton.addEventListener('click', async () => {
        if (!octokit) { handleLogout(); return; }
        if (!selectedOwner || !selectedRepo) {
            updateStatus("ì˜¤ë¥˜: ì €ì¥í•  ì €ì¥ì†Œê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", true);
            showSection(repoSection); return;
        }

        let fileName = fileNameInput.value.trim();
        const fileBodyContent = fileContentInput.value;
        let commitMessage = commitMessageInput.value.trim();
        const existingBlobSha = currentFileShaInput.value;
        const originalFullPath = currentFilePathInput.value;
        const isUpdateOperation = !!existingBlobSha && !!originalFullPath;

        // --- Input Validation ---
        const titleValue = fmTitleInput.value.trim();
        if (!titleValue) { updateStatus("ì˜¤ë¥˜: Front Matter 'Title'ì€ í•„ìˆ˜.", true); fmTitleInput.focus(); return; }
        if (!fileName) {
            fileName = generateHugoFilename(titleValue); fileNameInput.value = fileName;
            if (!fileName || fileName === '.md') { updateStatus('ì˜¤ë¥˜: ìœ íš¨í•œ íŒŒì¼ ì´ë¦„ ìƒì„± ë¶ˆê°€.', true); fileNameInput.focus(); return; }
            updateCommitMessage(); commitMessage = commitMessageInput.value.trim();
        }
        if (fileName.includes('/')) { updateStatus("ì˜¤ë¥˜: íŒŒì¼ ì´ë¦„ì— ìŠ¬ë˜ì‹œ('/') í¬í•¨ ë¶ˆê°€.", true); fileNameInput.focus(); return; }
        if (!fileName.toLowerCase().endsWith('.md')) {
              fileName += '.md'; fileNameInput.value = fileName;
              updateStatus("ê²½ê³ : '.md' í™•ì¥ì ì¶”ê°€ë¨.", false);
              updateCommitMessage(); commitMessage = commitMessageInput.value.trim();
        }
         const dateValue = fmDateInput.value.trim();
         if (!dateValue) { updateStatus("ì˜¤ë¥˜: Front Matter 'Date'ëŠ” í•„ìˆ˜.", true); fmDateInput.focus(); return; }
         if (!/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2})$/i.test(dateValue)) {
              updateStatus("ì˜¤ë¥˜: 'Date' í˜•ì‹ ì˜¤ë¥˜ (YYYY-MM-DDTHH:MM:SSZ ê¶Œì¥).", true); fmDateInput.focus(); return;
         }
         const defaultCreateMsg = `Create ${fileName}`;
         const defaultUpdateMsg = `Update content for ${fileName}`;
         if (!commitMessage || commitMessage === defaultCreateMsg || commitMessage === defaultUpdateMsg) {
             updateCommitMessage(); commitMessage = commitMessageInput.value.trim();
         }
         if (!commitMessage) { updateStatus("ì˜¤ë¥˜: ì»¤ë°‹ ë©”ì‹œì§€ í•„ìš”.", true); commitMessageInput.focus(); return; }

        // --- Prepare File Content ---
        const fmData = {
            title: titleValue, author: fmAuthorInput.value.trim(), date: dateValue,
            description: fmDescriptionInput.value.trim(),
            tags: fmTagsInput.value.split(',').map(t => t.trim()).filter(t => t),
            categories: fmCategoriesInput.value.split(',').map(c => c.trim()).filter(c => c),
            toc: fmTocCheckbox.checked
        };
        let finalContent;
        try { finalContent = formatFrontMatter(fmData) + fileBodyContent; }
        catch (formatError) { updateStatus(`Front Matter ìƒì„± ì˜¤ë¥˜: ${formatError.message}`, true); return; }

        // --- Handle Rename ---
        const targetBasePath = currentPath ? currentPath + '/' : '';
        const targetFullPath = targetBasePath + fileName;
        const isRename = isUpdateOperation && (targetFullPath !== originalFullPath);
        if (isRename) {
             if (!confirm(`íŒŒì¼ ì´ë¦„/ê²½ë¡œ ë³€ê²½ë¨.\n\nê¸°ì¡´: '${originalFullPath}'\n   ìƒˆ ê²½ë¡œ: '${targetFullPath}'\n\nìƒˆ ê²½ë¡œì— íŒŒì¼ ìƒì„± (ê¸°ì¡´ íŒŒì¼ ì‚­ì œ ì•ˆ í•¨).\nê³„ì†?`)) {
                 updateStatus("ì´ë¦„ ë³€ê²½/íŒŒì¼ ìƒì„± ì‘ì—… ì·¨ì†Œë¨.", false); return;
             }
             const oldFilenameOnly = originalFullPath.substring(originalFullPath.lastIndexOf('/') + 1);
             const defaultRenameCommit = `Create ${fileName} (renamed from ${oldFilenameOnly})`;
             if (commitMessage === `Update content for ${oldFilenameOnly}`) {
                 commitMessageInput.value = defaultRenameCommit; commitMessage = defaultRenameCommit;
             }
             updateStatus("íŒŒì¼ ì´ë¦„ ë³€ê²½ í™•ì¸ë¨. ìƒˆ ê²½ë¡œì— ìƒì„± ì¤‘...", false);
        }

        // --- UI Update for Saving State ---
        updateStatus(`'${targetFullPath}' ì €ì¥ ì¤‘...`);
        saveFileButton.disabled = true; cancelEditButton.disabled = true; deleteFileButton.disabled = true;

        // --- Encode Content ---
        let encodedContent;
        try { encodedContent = b64EncodeUnicode(finalContent); }
        catch(encodeError) {
            updateStatus(`íŒŒì¼ ë‚´ìš© ì¸ì½”ë”© ì‹¤íŒ¨: ${encodeError.message}`, true);
            saveFileButton.disabled = false; cancelEditButton.disabled = false;
            deleteFileButton.disabled = !(isUpdateOperation && !isRename);
            return;
        }

        try {
            // --- GitHub API Call: Create or Update File ---
            const params = { owner: selectedOwner, repo: selectedRepo, path: targetFullPath,
                             message: commitMessage, content: encodedContent, branch: currentBranch };
            if (isUpdateOperation && !isRename) { params.sha = existingBlobSha; } // Provide SHA for updates only

            const { data: result } = await octokit.rest.repos.createOrUpdateFileContents(params);

            // --- Post-Save Success Actions ---
            const action = isUpdateOperation ? (isRename ? 'ì´ë¦„ ë³€ê²½ìœ¼ë¡œ ìƒì„±' : 'ìˆ˜ì •') : 'ìƒì„±';
            updateStatus(`'${targetFullPath}' ${action} ì™„ë£Œ. ì»¤ë°‹ SHA: ${result?.commit?.sha?.substring(0, 7)}`, false, true);
            clearEditorFields(); showSection(fileBrowserSection);
            const refreshPath = targetBasePath.endsWith('/') ? targetBasePath.slice(0, -1) : targetBasePath;
            fetchContents(refreshPath); // Refresh the directory
            if (isRename) {
                 alert(`íŒŒì¼ '${targetFullPath}' ìƒì„±(ì´ë¦„ ë³€ê²½) ì„±ê³µ.\n\nì•Œë¦¼: ê¸°ì¡´ íŒŒì¼ '${originalFullPath}'ì€(ëŠ”) ì‚­ì œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
            }

        } catch (error) {
            // --- Error Handling for API Call ---
            console.error("Save File Error:", error);
            let errorMsg = `íŒŒì¼ ì €ì¥ ì‹¤íŒ¨ (${targetFullPath}): ${error.message}`;
            if (error.status === 409) errorMsg = `íŒŒì¼ ì €ì¥ ì¶©ëŒ (409): ì„œë²„ íŒŒì¼ ë³€ê²½ë¨. ìƒˆë¡œê³ ì¹¨ í›„ ì¬ì‹œë„.`;
            else if (error.status === 422) errorMsg = `ì˜ëª»ëœ ìš”ì²­ (422): ì»¤ë°‹ ë©”ì‹œì§€/ê²½ë¡œ/SHA ë“± ë¬¸ì œ ê°€ëŠ¥ì„±.`;
            else if (error.status === 404 && isUpdateOperation && !isRename) errorMsg = `ì—…ë°ì´íŠ¸ ëŒ€ìƒ íŒŒì¼ ì—†ìŒ (404): '${originalFullPath}' ì‚­ì œë¨?`;
            else if (error.status === 403) errorMsg = `íŒŒì¼ ì €ì¥ ê¶Œí•œ ì˜¤ë¥˜ (403).`;
            else if (error.status === 401) {
                  errorMsg = `GitHub API ì¸ì¦ ì˜¤ë¥˜ (401): PAT ë§Œë£Œë¨. ë¡œê·¸ì•„ì›ƒí•©ë‹ˆë‹¤.`;
                  updateStatus(errorMsg, true); handleLogout(); return;
             }
            updateStatus(errorMsg, true);
            // Re-enable buttons on failure
            saveFileButton.disabled = false; cancelEditButton.disabled = false;
            deleteFileButton.disabled = !(isUpdateOperation && !isRename); // Re-enable delete if it was possible before
        }
    });

    /** Delete File Button Click */
     deleteFileButton.addEventListener('click', async () => {
         if (!octokit) { handleLogout(); return; }
         if (!selectedOwner || !selectedRepo) {
             updateStatus("ì˜¤ë¥˜: ì‚­ì œí•  ì €ì¥ì†Œê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", true); showSection(repoSection); return;
         }
        const filePathToDelete = currentFilePathInput.value;
        const fileShaToDelete = currentFileShaInput.value; // Blob SHA needed
        const filenameOnly = filePathToDelete ? filePathToDelete.substring(filePathToDelete.lastIndexOf('/') + 1) : 'ì•Œ ìˆ˜ ì—†ëŠ” íŒŒì¼';

        if (!filePathToDelete || !fileShaToDelete) { updateStatus("ì˜¤ë¥˜: ì‚­ì œí•  íŒŒì¼ ì •ë³´ ë¶€ì¡±.", true); return; }
        if (!confirm(`ì •ë§ë¡œ '${filenameOnly}' íŒŒì¼ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\në˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`)) {
             updateStatus("íŒŒì¼ ì‚­ì œ ì‘ì—… ì·¨ì†Œë¨.", false); return;
        }

        let commitMessage = commitMessageInput.value.trim();
        if (!commitMessage || commitMessage.toLowerCase().startsWith('update ') || commitMessage.toLowerCase().startsWith('create ')) {
            commitMessage = `Delete ${filenameOnly}`; commitMessageInput.value = commitMessage;
        }
         if (!commitMessage) { updateStatus("ì˜¤ë¥˜: ì‚­ì œ ì»¤ë°‹ ë©”ì‹œì§€ í•„ìš”.", true); commitMessageInput.focus(); return; }

        updateStatus(`'${filePathToDelete}' ì‚­ì œ ì¤‘...`);
        saveFileButton.disabled = true; cancelEditButton.disabled = true; deleteFileButton.disabled = true;

        try {
            // --- GitHub API Call: Delete File ---
            await octokit.rest.repos.deleteFile({
                owner: selectedOwner, repo: selectedRepo, path: filePathToDelete,
                message: commitMessage, sha: fileShaToDelete, branch: currentBranch
            });

            // --- Post-Delete Success Actions ---
            updateStatus(`'${filePathToDelete}' ì‚­ì œ ì™„ë£Œ.`, false, true);
            clearEditorFields(); showSection(fileBrowserSection);
            fetchContents(currentPath); // Refresh current directory

        } catch (error) {
            // --- Error Handling ---
            console.error("Delete File Error:", error);
            let errorMsg = `íŒŒì¼ ì‚­ì œ ì‹¤íŒ¨ (${filePathToDelete}): ${error.message}`;
             if (error.status === 404) errorMsg = `ì‚­ì œí•  íŒŒì¼ ì—†ìŒ (404) ë˜ëŠ” ë³€ê²½ë¨ (SHA: ${fileShaToDelete}). ìƒˆë¡œê³ ì¹¨ í›„ ì¬ì‹œë„.`;
             else if (error.status === 409) errorMsg = `ì‚­ì œ ì¤‘ ì¶©ëŒ ë°œìƒ (409).`;
             else if (error.status === 422) errorMsg = `ì˜ëª»ëœ ìš”ì²­ (422): ì •ë³´ ë¶€ì¡±?`;
             else if (error.status === 403) errorMsg = `íŒŒì¼ ì‚­ì œ ê¶Œí•œ ì˜¤ë¥˜ (403).`;
             else if (error.status === 401) {
                  errorMsg = `GitHub API ì¸ì¦ ì˜¤ë¥˜ (401): PAT ë§Œë£Œë¨. ë¡œê·¸ì•„ì›ƒí•©ë‹ˆë‹¤.`;
                   updateStatus(errorMsg, true); handleLogout(); return;
             }
            updateStatus(errorMsg, true);
            // Re-enable buttons on failure
             saveFileButton.disabled = true; // Keep save disabled
             cancelEditButton.disabled = false;
             deleteFileButton.disabled = (error.status === 404); // Re-enable only if file might still exist
        }
    });

    /** Cancel Button Click */
     cancelEditButton.addEventListener('click', () => {
        if (!octokit) { resetToLoginScreen(); return; }

        const hasUnsavedContent = fmTitleInput.value.trim() || fileContentInput.value.trim() || (!currentFileShaInput.value && fileNameInput.value.trim());
        let confirmed = true;
        if (hasUnsavedContent) {
             confirmed = confirm("í¸ì§‘ ì¤‘ì¸ ë‚´ìš©ì´ ìˆìŠµë‹ˆë‹¤. ì €ì¥í•˜ì§€ ì•Šê³  ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?");
        }
        if (confirmed) {
            clearEditorFields();
            updateStatus('í¸ì§‘ ì‘ì—… ì·¨ì†Œë¨.');
            showSection(fileBrowserSection);
             // fetchContents(currentPath); // Optional refresh
        } else {
             updateStatus('ì·¨ì†Œ ì‘ì—… ì¤‘ë‹¨ë¨.');
        }
    });

    // --- Input Change Handlers ---
     /** Auto-gen filename/commit msg when Title changes */
     fmTitleInput.addEventListener('input', () => {
         const title = fmTitleInput.value;
         if (!currentFileShaInput.value || !fileNameInput.value.trim()) { // Only for new files or if filename empty
             if (title.trim()) { fileNameInput.value = generateHugoFilename(title); }
         }
         updateCommitMessage();
    });

    /** Update commit msg if filename is manually changed */
    fileNameInput.addEventListener('input', () => {
         updateCommitMessage();
    });


    // --- Initial State Setup ---
    /**
     * Initializes the application on page load. Checks for stored PAT and attempts auto-login.
     * Manages initial visibility of the global logout button.
     */
    function initializeApp() {
        console.log("Initializing GitHub Editor...");
        clearEditorFields();
        // Ensure logout is hidden on initial load before checking PAT
        logoutButton.classList.add('hidden'); // <<<--- ENSURE HIDDEN INITIALLY

        const storedPat = localStorage.getItem(PAT_STORAGE_KEY);

        if (storedPat) {
            console.log("Stored PAT found. Attempting auto-login...");
            patInput.value = '********';
            patInput.disabled = true;
            loginButton.disabled = true;
            loginButton.textContent = 'ìë™ ë¡œê·¸ì¸ ì¤‘...';
            // logoutButton remains hidden until authenticateAndLoadRepos confirms auth
            authenticateAndLoadRepos(storedPat, true);
        } else {
            console.log("No stored PAT found. Displaying login screen.");
            resetToLoginScreen(); // resetToLoginScreen ensures logout button is hidden
            updateStatus('ì‹œì‘: GitHub Personal Access Token (PAT)ë¥¼ ì…ë ¥í•˜ê³  ë¡œê·¸ì¸í•˜ì„¸ìš”.');
        }
    }

    // --- Storage Event Listener for Multi-Tab Logout Synchronization ---
    /**
     * Listens for localStorage changes to sync logout across tabs.
     */
    window.addEventListener('storage', (event) => {
        if (event.key === PAT_STORAGE_KEY) {
            // If PAT removed elsewhere AND we are currently logged in
            if (event.newValue === null && octokit) {
                console.log('Logout detected from another tab via storage event.');
                updateStatus('ë‹¤ë¥¸ íƒ­ ë˜ëŠ” ì°½ì—ì„œ ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤. ì´ ì°½ë„ ë¡œê·¸ì•„ì›ƒë©ë‹ˆë‹¤.', false);
                 handleLogout(); // Reloads, naturally hides button
            }
        }
    });

    // --- Run Initialization ---
    initializeApp();

</script>

</body>
</html>