<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub íŒŒì¼ ì—ë””í„° (Octokit + Hugo)</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 900px; margin: 20px auto; background-color: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .section { margin-bottom: 25px; padding: 20px; border: 1px solid #ddd; border-radius: 5px; background-color: #fff; }
        h1, h2, h3 { color: #0056b3; }
        h1 { text-align: center; margin-bottom: 30px; }
        h2 { border-bottom: 2px solid #eee; padding-bottom: 10px; margin-bottom: 15px; }
        h3 { margin-top: 20px; margin-bottom: 10px; color: #333; }
        label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
        input[type="text"], input[type="password"], select, textarea {
            width: 100%; /* Use 100% width */
            padding: 12px;
            margin-bottom: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
            font-size: 1rem;
        }
        textarea { height: 350px; font-family: 'Courier New', Courier, monospace; line-height: 1.5; }
        button {
            padding: 12px 18px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            margin-top: 10px; /* Add some top margin */
            font-size: 1rem;
            transition: background-color 0.2s ease;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #fileList ul { list-style: none; padding: 0; margin: 0; max-height: 300px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px;}
        #fileList li { padding: 10px 12px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: center; transition: background-color 0.2s ease;}
        #fileList li:last-child { border-bottom: none; }
        #fileList li:hover { background-color: #f0f8ff; } /* Light blue hover */
        #fileList li::before { margin-right: 10px; font-size: 1.1em; }
        #fileList li.dir::before { content: 'ğŸ“'; color: #ffac33; } /* Folder color */
        #fileList li.file::before { content: 'ğŸ“„'; color: #6c757d; } /* File color */
        #fileList li strong { font-weight: bold; color: #0056b3; } /* For '..' link */
        #statusBar { margin-top: 20px; padding: 10px; background-color: #e9ecef; border-radius: 4px; color: #495057; font-style: italic; text-align: center;}
        .hidden { display: none; }
        .status-bar-error { color: #721c24 !important; background-color: #f8d7da !important; border: 1px solid #f5c6cb !important; font-weight: bold; }
        .status-bar-success { color: #155724 !important; background-color: #d4edda !important; border: 1px solid #c3e6cb !important; }
        .warning { color: #856404; background-color: #fff3cd; border-color: #ffeeba; border-left: 4px solid #ffc107; padding: 10px; border-radius: 4px; margin-bottom: 15px;}
        .error { color: #dc3545; font-weight: bold; border-left: 4px solid #dc3545; padding: 10px; background-color: #f8d7da; border-radius: 4px; margin-bottom: 15px;}
        .breadcrumb { margin-bottom: 15px; font-size: 0.95em; color: #6c757d; }
        .breadcrumb strong { color: #333; }
        .breadcrumb a { text-decoration: none; color: #007bff; }
        .breadcrumb a:hover { text-decoration: underline; }
        .breadcrumb span { margin: 0 5px; color: #aaa; }
        hr { margin: 25px 0; border: 0; border-top: 1px solid #eee; }
        /* Style for inline checkbox label */
        label[for="fmTocCheckbox"] { display: inline-block; margin-right: 10px; margin-bottom: 10px; font-weight: normal; }
        input[type="checkbox"] { margin-right: 8px; vertical-align: middle; width: auto; /* Override default width */ }
        /* Responsive */
        @media (max-width: 600px) {
            .container { padding: 15px; }
            button { width: 100%; margin-right: 0; margin-bottom: 10px; }
            input[type="text"], input[type="password"], select, textarea { padding: 10px; }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>GitHub íŒŒì¼ ì—ë””í„° (Octokit + Hugo)</h1>

    <!-- 1. Login Section -->
    <div id="loginSection" class="section">
        <h2>1. GitHub ë¡œê·¸ì¸ (Octokit ì‚¬ìš©)</h2>
        <div class="warning"> <!-- Changed to warning class -->
            <strong>ì£¼ì˜:</strong> Personal Access Token (PAT)ì„ ë¸Œë¼ìš°ì €ì— ì €ì¥í•˜ê±°ë‚˜ ì…ë ¥í•˜ëŠ” ê²ƒì€ ë³´ì•ˆìƒ ìœ„í—˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë°˜ë“œì‹œ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” í™˜ê²½ì—ì„œ ê°œì¸ì ì¸ ìš©ë„ë¡œë§Œ ì‚¬ìš©í•˜ê³ , í† í°ì´ ì™¸ë¶€ì— ë…¸ì¶œë˜ì§€ ì•Šë„ë¡ ê°ë³„íˆ ì£¼ì˜í•˜ì„¸ìš”. ì‚¬ìš© í›„ì—ëŠ” ë¸Œë¼ìš°ì € ìºì‹œë¥¼ ì§€ìš°ê±°ë‚˜ ì‹œí¬ë¦¿ ëª¨ë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. í† í°ì—ëŠ” <strong>'repo'</strong> ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.
        </div>
        <label for="patInput">Personal Access Token (PAT):</label>
        <input type="password" id="patInput" placeholder="GitHub PAT ì…ë ¥ (repo ê¶Œí•œ í•„ìš”)">
        <button id="loginButton">ì €ì¥ì†Œ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°</button>
    </div>

    <!-- 2. Repository Selection -->
    <div id="repoSection" class="section hidden">
        <h2>2. ì €ì¥ì†Œ ì„ íƒ</h2>
        <label for="repoSelect">ì €ì¥ì†Œ:</label>
        <select id="repoSelect"></select>
        <button id="loadRepoButton" disabled>íŒŒì¼ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°</button>
    </div>

    <!-- 3. File Browser -->
    <div id="fileBrowserSection" class="section hidden">
        <h2>3. íŒŒì¼ íƒìƒ‰ê¸°</h2>
        <div><strong>í˜„ì¬ ì €ì¥ì†Œ:</strong> <span id="currentRepo"></span></div>
        <div class="breadcrumb"><strong>ê²½ë¡œ:</strong> <span id="currentPathBreadcrumb">/</span></div>
        <div id="fileList">
            <ul></ul>
        </div>
        <button id="createNewFileButton">ìƒˆ íŒŒì¼ ë§Œë“¤ê¸° (Hugo)</button>
    </div>

    <!-- 4. File Editor -->
    <div id="editorSection" class="section hidden">
        <h2>4. íŒŒì¼ í¸ì§‘ê¸° / Front Matter (TOML)</h2>
        <input type="hidden" id="currentFileSha">
        <input type="hidden" id="currentFilePathInput">

         <label for="fmTitleInput">Title (í•„ìˆ˜, íŒŒì¼ëª… ìƒì„±ì— ì‚¬ìš©):</label>
         <input type="text" id="fmTitleInput" placeholder="ê²Œì‹œë¬¼ ì œëª©">

         <label for="fileNameInput">íŒŒì¼ ì´ë¦„ (ìë™ ìƒì„±/í¸ì§‘ ê°€ëŠ¥, í™•ì¥ì .md ê³ ì •):</label>
         <input type="text" id="fileNameInput" placeholder="my-new-post.md (Title ì…ë ¥ ì‹œ ìë™ ìƒì„±)">

        <hr>
        <h3>Hugo Front Matter (TOML)</h3>
        <!-- Title input moved above -->
        <label for="fmAuthorInput">Author:</label>
        <input type="text" id="fmAuthorInput" placeholder="ì‘ì„±ì (ì„ íƒ ì‚¬í•­)">

        <label for="fmDateInput">Date (í•„ìˆ˜, YYYY-MM-DDTHH:MM:SSZ):</label>
        <input type="text" id="fmDateInput" placeholder="ì˜ˆ: 2023-10-27T15:04:05+09:00">

        <label for="fmDescriptionInput">Description:</label>
        <input type="text" id="fmDescriptionInput" placeholder="ê°„ë‹¨í•œ ì„¤ëª… (ì„ íƒ ì‚¬í•­)">

        <label for="fmTagsInput">Tags (ì‰¼í‘œë¡œ êµ¬ë¶„):</label>
        <input type="text" id="fmTagsInput" placeholder="ì˜ˆ: web, development, github">

        <label for="fmCategoriesInput">Categories (ì‰¼í‘œë¡œ êµ¬ë¶„):</label>
        <input type="text" id="fmCategoriesInput" placeholder="ì˜ˆ: tech, programming">

        <div>
             <input type="checkbox" id="fmTocCheckbox">
             <label for="fmTocCheckbox">Table of Contents (TOC) ìƒì„±</label>
        </div>
        <hr>

        <label for="fileContentInput">íŒŒì¼ ë‚´ìš© (ë³¸ë¬¸ - Markdown ë“±):</label>
        <textarea id="fileContentInput" placeholder="ì—¬ê¸°ì— Markdown ë³¸ë¬¸ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”..."></textarea>

        <hr>
        <label for="commitMessageInput">ì»¤ë°‹ ë©”ì‹œì§€ (ìë™ ìƒì„±/í¸ì§‘ ê°€ëŠ¥):</label>
        <input type="text" id="commitMessageInput" placeholder="ìë™ ìƒì„± ë˜ëŠ” ì§ì ‘ ì…ë ¥">

        <button id="saveFileButton">ì €ì¥ (ìƒì„±/ìˆ˜ì •)</button>
        <button id="deleteFileButton" style="background-color: #dc3545;">ì‚­ì œ</button>
        <button id="cancelEditButton" style="background-color: #6c757d;">ì·¨ì†Œ</button>
    </div>

    <!-- Status Bar -->
    <div id="statusBar">ìƒíƒœ: ëŒ€ê¸° ì¤‘...</div>

</div>

<script type="module">
    // Import Octokit
    import { Octokit } from "https://esm.sh/octokit";

    // --- Global Variables ---
    let octokit = null; // Initialize Octokit instance here
    let githubToken = null; // Keep token for reference if needed, but octokit instance is primary
    let selectedOwner = null;
    let selectedRepo = null;
    let currentPath = ''; // í˜„ì¬ íƒìƒ‰ ì¤‘ì¸ ê²½ë¡œ
    let currentFiles = []; // í˜„ì¬ ê²½ë¡œì˜ íŒŒì¼/í´ë” ëª©ë¡ ìºì‹œ
    let currentBranch = 'main'; // TODO: Make this configurable later if needed

    // --- DOM Elements ---
    const patInput = document.getElementById('patInput');
    const loginButton = document.getElementById('loginButton');
    const repoSelect = document.getElementById('repoSelect');
    const loadRepoButton = document.getElementById('loadRepoButton');
    const fileListUl = document.querySelector('#fileList ul');
    const currentRepoSpan = document.getElementById('currentRepo');
    const currentPathBreadcrumb = document.getElementById('currentPathBreadcrumb');
    const fileNameInput = document.getElementById('fileNameInput');
    // Front Matter Inputs
    const fmTitleInput = document.getElementById('fmTitleInput');
    const fmAuthorInput = document.getElementById('fmAuthorInput');
    const fmDateInput = document.getElementById('fmDateInput');
    const fmDescriptionInput = document.getElementById('fmDescriptionInput');
    const fmTagsInput = document.getElementById('fmTagsInput');
    const fmCategoriesInput = document.getElementById('fmCategoriesInput');
    const fmTocCheckbox = document.getElementById('fmTocCheckbox');
    // ---
    const fileContentInput = document.getElementById('fileContentInput'); // Body content
    const commitMessageInput = document.getElementById('commitMessageInput');
    const currentFileShaInput = document.getElementById('currentFileSha');
    const currentFilePathInput = document.getElementById('currentFilePathInput');
    const saveFileButton = document.getElementById('saveFileButton');
    const deleteFileButton = document.getElementById('deleteFileButton');
    const cancelEditButton = document.getElementById('cancelEditButton');
    const createNewFileButton = document.getElementById('createNewFileButton');
    const statusBar = document.getElementById('statusBar');

    // --- Sections ---
    const loginSection = document.getElementById('loginSection');
    const repoSection = document.getElementById('repoSection');
    const fileBrowserSection = document.getElementById('fileBrowserSection');
    const editorSection = document.getElementById('editorSection');

    // --- Helper Functions ---
    function updateStatus(message, isError = false, isSuccess = false) {
        statusBar.textContent = `ìƒíƒœ: ${message}`;
        statusBar.classList.remove('status-bar-error', 'status-bar-success'); // Remove existing classes
        if (isError) {
            statusBar.classList.add('status-bar-error');
        } else if (isSuccess) {
             statusBar.classList.add('status-bar-success');
        } else {
            // Default styling (neutral)
            statusBar.style.color = '#495057';
            statusBar.style.backgroundColor = '#e9ecef';
            statusBar.style.border = 'none';
            statusBar.style.fontWeight = 'normal';
        }
        console[isError ? 'error' : 'log'](message); // Log to console
    }

    function showSection(sectionToShow) {
        [loginSection, repoSection, fileBrowserSection, editorSection].forEach(section => {
            section.classList.add('hidden');
        });
        if (sectionToShow) {
            sectionToShow.classList.remove('hidden');
        }
    }

    // Base64 ì¸ì½”ë”©/ë””ì½”ë”© (UTF-8 ì§€ì›) - Kept as Octokit requires/returns Base64
    function b64EncodeUnicode(str) {
        try {
            return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
                return String.fromCharCode(parseInt(p1, 16));
            }));
        } catch (e) {
             console.error("Base64 ì¸ì½”ë”© ì‹¤íŒ¨:", e);
             updateStatus("Base64 ì¸ì½”ë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ.", true);
             throw new Error("Base64 ì¸ì½”ë”© ì‹¤íŒ¨"); // Re-throw to stop the process
        }
    }

    function b64DecodeUnicode(str) {
        let decoded_string;
        try {
             if (typeof TextDecoder !== 'undefined') {
                 // Modern browsers: Use TextDecoder for robust UTF-8 decoding
                 const bytes = Uint8Array.from(atob(str), c => c.charCodeAt(0));
                 decoded_string = new TextDecoder('utf-8', { fatal: true }).decode(bytes); // Throw error on invalid UTF-8
                 return decoded_string;
             } else {
                 // Fallback for older environments (less robust)
                 decoded_string = decodeURIComponent(escape(atob(str)));
                 return decoded_string;
             }
        } catch (e) {
             console.error("Base64/UTF-8 ë””ì½”ë”© ì‹¤íŒ¨:", e);
             updateStatus('Base64 ë˜ëŠ” UTF-8 ë””ì½”ë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ. íŒŒì¼ ë‚´ìš©ì´ ì†ìƒë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.', true);
             // Try simple atob as a last resort, might work for non-UTF-8 or partially corrupt data
             try {
                 return atob(str);
             } catch (atobError) {
                  console.error("atob fallback ì‹¤íŒ¨:", atobError);
                  throw new Error("Base64/UTF-8 ë””ì½”ë”© ì™„ì „ ì‹¤íŒ¨"); // Re-throw
             }
        }
    }

    // --- Hugo Front Matter Parsing/Formatting --- (No changes needed here, assuming it's working)
    function parseFrontMatter(content) {
        const fm = {
            tags: [],
            categories: [],
            body: content,
            toc: undefined // Explicitly undefined initially
        };
        const fmRegex = /^\+\+\+\s*([\s\S]*?)\s*\+\+\+([\s\S]*)/;
        const match = content.match(fmRegex);

        if (match && match[1] && match[2] !== undefined) {
            const frontMatterBlock = match[1].trim();
            fm.body = match[2].trimStart(); // Keep leading whitespace for body if user intended

            const lines = frontMatterBlock.split('\n');
            let currentKey = null;
            let accumulatingArrayContent = null;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();

                if (accumulatingArrayContent !== null) {
                    accumulatingArrayContent += "\n" + line;
                    if (line.includes(']')) {
                        try {
                            const startIndex = accumulatingArrayContent.indexOf('[');
                            const endIndex = accumulatingArrayContent.lastIndexOf(']');
                            if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                                let arrayString = accumulatingArrayContent.substring(startIndex + 1, endIndex).trim();
                                let values = [];
                                if (arrayString) {
                                     values = arrayString.split(',')
                                        .map(item => item.trim())
                                        .filter(item => item && !item.startsWith('#')) // Filter comments in array lines too
                                        .map(item => {
                                             // Remove quotes carefully
                                             if (item.startsWith('"') && item.endsWith('"')) return item.substring(1, item.length - 1).replace(/\\"/g, '"');
                                             if (item.startsWith("'") && item.endsWith("'")) return item.substring(1, item.length - 1).replace(/\\'/g, "'");
                                             return item;
                                        });
                                }
                                if (currentKey === 'tags' || currentKey === 'categories') {
                                     fm[currentKey] = values;
                                } else {
                                     console.warn(`Parsed multiline array for unexpected key '${currentKey}' from front matter.`);
                                }
                            } else {
                                console.error(`Could not find valid brackets in accumulated array content for key ${currentKey}:`, accumulatingArrayContent);
                                updateStatus(`Front matter ë°°ì—´ êµ¬ë¬¸ ë¶„ì„ ì˜¤ë¥˜ (${currentKey}): ëŒ€ê´„í˜¸ ì°¾ê¸° ì‹¤íŒ¨`, true);
                            }
                        } catch (e) {
                            console.error(`Error parsing accumulated array for key ${currentKey}:`, accumulatingArrayContent, e);
                            updateStatus(`Front matter ë°°ì—´ êµ¬ë¬¸ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (${currentKey})`, true);
                        } finally {
                            accumulatingArrayContent = null;
                            currentKey = null;
                        }
                    }
                } else {
                    if (!trimmedLine || trimmedLine.startsWith('#')) {
                        continue; // Skip empty lines and comments
                    }

                    const eqIndex = trimmedLine.indexOf('=');
                    if (eqIndex > 0) {
                        const key = trimmedLine.substring(0, eqIndex).trim();
                        let valuePart = trimmedLine.substring(eqIndex + 1).trim();

                        // Handle arrays (potentially multiline)
                        if ((key === 'tags' || key === 'categories') && valuePart.startsWith('[')) {
                             if (valuePart.includes(']') && valuePart.lastIndexOf(']') > valuePart.indexOf('[')) { // Check if closes on same line
                                try {
                                    const startIndex = valuePart.indexOf('[');
                                    const endIndex = valuePart.lastIndexOf(']');
                                    let arrayString = valuePart.substring(startIndex + 1, endIndex).trim();
                                    let values = [];
                                    if (arrayString) {
                                        values = arrayString.split(',')
                                            .map(item => item.trim())
                                            .filter(item => item && !item.startsWith('#')) // Filter comments
                                            .map(item => {
                                                // Remove quotes carefully
                                                if (item.startsWith('"') && item.endsWith('"')) return item.substring(1, item.length - 1).replace(/\\"/g, '"');
                                                if (item.startsWith("'") && item.endsWith("'")) return item.substring(1, item.length - 1).replace(/\\'/g, "'");
                                                return item;
                                            });
                                    }
                                    fm[key] = values;
                                } catch(e) {
                                    console.error(`Error parsing single-line array for key ${key}:`, valuePart, e);
                                    updateStatus(`Front matter ë°°ì—´ êµ¬ë¬¸ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (${key})`, true);
                                    fm[key] = []; // Default to empty on error
                                }
                            } else { // Start of a multiline array
                                currentKey = key;
                                accumulatingArrayContent = valuePart;
                                // Check if it somehow closes immediately after opening bracket (e.g., '[ ]')
                                if (accumulatingArrayContent.includes(']')) {
                                     try {
                                        const startIndex = accumulatingArrayContent.indexOf('[');
                                        const endIndex = accumulatingArrayContent.lastIndexOf(']');
                                        if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                                            let arrayString = accumulatingArrayContent.substring(startIndex + 1, endIndex).trim();
                                            let values = [];
                                            if (arrayString) {
                                                values = arrayString.split(',')
                                                    .map(item => item.trim()).filter(item => item && !item.startsWith('#'))
                                                    .map(item => {
                                                        if (item.startsWith('"') && item.endsWith('"')) return item.substring(1, item.length - 1).replace(/\\"/g, '"');
                                                        if (item.startsWith("'") && item.endsWith("'")) return item.substring(1, item.length - 1).replace(/\\'/g, "'");
                                                        return item;
                                                    });
                                            }
                                            fm[key] = values;
                                        } else { throw new Error("Brackets not found correctly."); }
                                     } catch (e) {
                                         console.error(`Error parsing potential single-line array disguised as multi-line for key ${key}:`, accumulatingArrayContent, e);
                                         updateStatus(`Front matter ë°°ì—´ êµ¬ë¬¸ ë¶„ì„ ì˜¤ë¥˜ (${key}): ë‹¨ì¼ ë¼ì¸ ì²˜ë¦¬ ì‹¤íŒ¨`, true);
                                         fm[key] = [];
                                     } finally {
                                        accumulatingArrayContent = null;
                                        currentKey = null;
                                     }
                                }
                            }
                        } else { // Handle simple key-value pairs
                            try {
                                let parsedValue = valuePart;
                                // Remove surrounding quotes (handle escaped quotes within)
                                if (parsedValue.startsWith('"') && parsedValue.endsWith('"')) {
                                    parsedValue = parsedValue.substring(1, parsedValue.length - 1).replace(/\\"/g, '"');
                                } else if (parsedValue.startsWith("'") && parsedValue.endsWith("'")) {
                                     parsedValue = parsedValue.substring(1, parsedValue.length - 1).replace(/\\'/g, "'");
                                } else if (parsedValue === 'true') {
                                    parsedValue = true;
                                } else if (parsedValue === 'false') {
                                    parsedValue = false;
                                }
                                // Assign known keys, including 'toc'
                                if (['title', 'author', 'date', 'description', 'toc'].includes(key)) {
                                     // Special check for toc: only assign if it's explicitly true or false
                                     if (key === 'toc') {
                                         if (typeof parsedValue === 'boolean') {
                                            fm[key] = parsedValue;
                                         } else {
                                             console.warn(`Front matter parsing: Expected boolean for 'toc', got:`, parsedValue, "- Ignoring.");
                                             // Do not assign fm.toc if it's not boolean
                                         }
                                     } else {
                                        fm[key] = parsedValue; // Assign other keys normally
                                     }
                                } else {
                                    // console.log(`Unknown front matter key found: ${key}`); // Keep this commented unless debugging FM
                                }
                            } catch (parseError) {
                                 console.error(`Error parsing simple front matter line: "${line}"`, parseError);
                                 updateStatus(`Front matter êµ¬ë¬¸ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${line}`, true);
                            }
                        }
                    } else {
                        // Line does not contain '=', might be part of a multiline string (not handled here) or invalid TOML
                        console.warn(`Invalid front matter line (no '=' found, not inside array): "${trimmedLine}"`);
                    }
                }
            } // End for loop

            // Handle case where file ends mid-array
            if (accumulatingArrayContent !== null) {
                console.error(`Front matter parsing ended while still inside an unclosed array for key: ${currentKey}`);
                updateStatus(`Front matter ì˜¤ë¥˜: ${currentKey} ë°°ì—´ì´ ë‹«íˆì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í•´ë‹¹ í•„ë“œëŠ” ë¹„ì–´ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`, true);
                if (currentKey && (currentKey === 'tags' || currentKey === 'categories')) {
                     fm[currentKey] = []; // Default to empty
                }
            }
        } // End if (match)

        // If 'toc' was never assigned (not found or invalid value), fm.toc remains undefined.
        // The checkbox logic later should handle 'undefined' as false.
        return fm;
    }

    function formatFrontMatter(fmData) {
        let fmString = '+++\n';
        // Helper to ensure strings are properly quoted and escaped for TOML
        const formatTomlString = (str) => `"${String(str).replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
        // Helper to format arrays
        const formatTomlArray = (arr) => `[${arr.map(formatTomlString).join(', ')}]`;

        if (fmData.title) fmString += `title = ${formatTomlString(fmData.title)}\n`;
        if (fmData.date) fmString += `date = ${formatTomlString(fmData.date)}\n`; // TOML dates are strings
        if (fmData.author) fmString += `author = ${formatTomlString(fmData.author)}\n`;
        if (fmData.description) fmString += `description = ${formatTomlString(fmData.description)}\n`;
        if (fmData.categories && fmData.categories.length > 0) fmString += `categories = ${formatTomlArray(fmData.categories)}\n`;
        if (fmData.tags && fmData.tags.length > 0) fmString += `tags = ${formatTomlArray(fmData.tags)}\n`;

        // Add toc = true or toc = false ONLY if the checkbox was checked (true)
        // If unchecked, we omit the line entirely, which Hugo usually defaults to false.
        if (fmData.toc === true) {
             fmString += `toc = true\n`;
        } else if (fmData.toc === false) {
            // Optionally add toc = false explicitly if needed, otherwise omit it.
            // fmString += `toc = false\n`;
        }

        fmString += '+++\n\n'; // Closing delimiter and two newlines before body
        return fmString;
    }


    // --- Hugo Filename Generation --- (No changes needed)
    function generateHugoFilename(title) {
        if (!title || !title.trim()) {
            return 'untitled.md';
        }
        // More aggressive cleaning for various symbols, keeping Korean characters
        const cleanedTitle = title
            .trim()
            .toLowerCase()
            // Remove specific punctuation and symbols, allow Hangul, alphanumeric, and hyphen/underscore
            .replace(/[\\/:\?\"\'\`\*<>\|;#\${},\+=~@%^&\(\)\[\]\.!]/g, '')
            // Replace whitespace (including multiple spaces) with a single hyphen
            .replace(/\s+/g, '-')
            // Remove leading/trailing hyphens that might result
            .replace(/^-+|-+$/g, '');

        return (cleanedTitle || 'untitled') + '.md';
    }

    // --- Commit Message Generation --- (No changes needed)
    function updateCommitMessage() {
        const filename = fileNameInput.value.trim();
        const isUpdate = !!currentFileShaInput.value; // Check if SHA exists (indicates update)

        if (filename) {
             commitMessageInput.value = isUpdate ? `Update ${filename}` : `Create ${filename}`;
        } else {
             commitMessageInput.value = ''; // Clear if filename is empty
        }
    }

    // ê²½ë¡œ Breadcrumb ìƒì„± (No changes needed)
    function updateBreadcrumb() {
        currentPathBreadcrumb.innerHTML = ''; // Clear existing
        const rootLink = document.createElement('a');
        rootLink.href = '#';
        rootLink.textContent = 'root';
        rootLink.onclick = (e) => { e.preventDefault(); fetchContents(''); };
        currentPathBreadcrumb.appendChild(rootLink);

        const pathParts = currentPath.split('/').filter(p => p);
        let accumulatedPath = '';
        pathParts.forEach((part) => {
            accumulatedPath += (accumulatedPath ? '/' : '') + part;
            const pathSeparator = document.createElement('span');
            pathSeparator.textContent = ' / '; // Use slash as separator
            currentPathBreadcrumb.appendChild(pathSeparator);

            const partLink = document.createElement('a');
            partLink.href = '#';
            partLink.textContent = part;
            const currentAccumulatedPath = accumulatedPath; // Capture path for closure
            partLink.onclick = (e) => { e.preventDefault(); fetchContents(currentAccumulatedPath); };
            currentPathBreadcrumb.appendChild(partLink);
        });
    }

    // Helper to add the '..' (Parent Directory) link (No changes needed)
    function addParentDirectoryLink(currentPath) {
         const parentPath = currentPath.includes('/') ? currentPath.substring(0, currentPath.lastIndexOf('/')) : '';
         const li = document.createElement('li');
         li.innerHTML = '<strong>â¬†ï¸ .. (ìƒìœ„ í´ë”)</strong>';
         li.style.cursor = 'pointer';
         li.title = `ìƒìœ„ í´ë”ë¡œ ì´ë™: /${parentPath}`;
         li.onclick = () => fetchContents(parentPath);
         if (fileListUl.firstChild) {
             fileListUl.insertBefore(li, fileListUl.firstChild);
         } else {
             fileListUl.appendChild(li);
         }
    }

    // Helper function to clear editor fields and state (No changes needed)
     function clearEditorFields() {
        fileNameInput.value = '';
        fmTitleInput.value = '';
        fmAuthorInput.value = '';
        fmDateInput.value = '';
        fmDescriptionInput.value = '';
        fmTagsInput.value = '';
        fmCategoriesInput.value = '';
        fmTocCheckbox.checked = false; // Default to unchecked
        fileContentInput.value = '';
        commitMessageInput.value = '';
        commitMessageInput.placeholder = 'ìë™ ìƒì„± ë˜ëŠ” ì§ì ‘ ì…ë ¥';
        currentFileShaInput.value = '';
        currentFilePathInput.value = '';

        // Disable buttons initially, enable as needed
        saveFileButton.disabled = true;
        deleteFileButton.disabled = true;
        cancelEditButton.disabled = true;
    }


    // --- Event Handlers ---

    // 1. Login (*** MODIFIED for Octokit Error Handling ***)
    loginButton.addEventListener('click', async () => {
        githubToken = patInput.value.trim();
        if (!githubToken) {
            updateStatus('ì˜¤ë¥˜: GitHub Personal Access Token (PAT)ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.', true);
            patInput.focus();
            return;
        }

        // Initialize Octokit
        try {
            octokit = new Octokit({
                auth: githubToken,
                // Optional: Add custom user agent
                // userAgent: 'hugo-editor-octokit/v1.0',
            });
            updateStatus('Octokit ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì™„ë£Œ. ì‚¬ìš©ì ì •ë³´ í™•ì¸ ì¤‘...');
        } catch (err) {
            // This catch is for Octokit constructor errors, unlikely but possible
            updateStatus(`Octokit ì´ˆê¸°í™” ì˜¤ë¥˜: ${err.message}`, true);
            octokit = null; // Ensure octokit is null on failure
            return;
        }

        patInput.disabled = true;
        loginButton.disabled = true;
        loginButton.textContent = 'ë¡œë”© ì¤‘...'; // Indicate activity
        loadRepoButton.disabled = true;
        updateStatus('ì €ì¥ì†Œ ëª©ë¡ ë¡œë”© ì¤‘...');

        try {
            // 1. Fetch user info to validate PAT and permissions early
            const { data: user } = await octokit.rest.users.getAuthenticated();
            console.log("Authenticated user:", user.login); // Good for debugging

            // 2. Fetch repositories
            // Use pagination for users with many repos (though 100 is usually enough)
            const repos = await octokit.paginate(octokit.rest.repos.listForAuthenticatedUser, {
                 affiliation: 'owner,collaborator', // Limit scope slightly if desired
                 per_page: 100,
                 sort: 'updated',
            });

            repoSelect.innerHTML = '<option value="">-- ì €ì¥ì†Œ ì„ íƒ --</option>'; // Reset dropdown

            if (repos && repos.length > 0) {
                 repos.forEach(repo => {
                    const option = document.createElement('option');
                    option.value = `${repo.owner.login}/${repo.name}`;
                    // Include visibility (Private/Public)
                    option.textContent = `${repo.full_name} (${repo.private ? 'Private' : 'Public'})`;
                    repoSelect.appendChild(option);
                });
                repoSelect.selectedIndex = 0; // Reset selection
                loadRepoButton.disabled = true; // Disable until a repo is selected
                updateStatus(`${repos.length}ê°œì˜ ì €ì¥ì†Œ ëª©ë¡ ë¡œë“œ ì™„ë£Œ. ëª©ë¡ì—ì„œ ì„ íƒí•˜ì„¸ìš”.`, false, true); // Use success styling
                showSection(repoSection);
            } else {
                updateStatus('ì ‘ê·¼ ê°€ëŠ¥í•œ ì €ì¥ì†Œê°€ ì—†ê±°ë‚˜ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. PAT ê¶Œí•œ(repo)ì„ í™•ì¸í•˜ì„¸ìš”.', true);
                // Don't reset octokit here, token might be valid but just have no repos
                showSection(loginSection); // Stay on login section
            }
        } catch (error) {
             console.error("Login/Repo Fetch Error:", error);
             let errorMsg = `ì €ì¥ì†Œ ëª©ë¡ ë¡œë”© ì‹¤íŒ¨: ${error.message}`;
             if (error.status === 401) {
                 errorMsg = `GitHub API ì¸ì¦ ì˜¤ë¥˜ (${error.status}): PATê°€ ìœ íš¨í•˜ì§€ ì•Šê±°ë‚˜ í•„ìš”í•œ ê¶Œí•œ('repo')ì´ ì—†ìŠµë‹ˆë‹¤.`;
             } else if (error.status === 403) {
                 // Could be rate limit or other permission issue
                 errorMsg = `GitHub API ê¶Œí•œ ì˜¤ë¥˜ (${error.status}): API ì†ë„ ì œí•œ ë˜ëŠ” ê¶Œí•œ ë¶€ì¡±ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (${error.message})`;
             }
             updateStatus(errorMsg, true);
             octokit = null; // Reset octokit instance on critical failure like auth
             showSection(loginSection);
        } finally {
            // Re-enable login elements ONLY if Octokit failed completely or auth failed
            if (!octokit || error?.status === 401) {
                 patInput.disabled = false;
                 loginButton.disabled = false;
                 loginButton.textContent = 'ì €ì¥ì†Œ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°';
            } else if (octokit) {
                // If octokit is valid but repo list failed for other reasons, keep login disabled
                loginButton.textContent = 'ì €ì¥ì†Œ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°'; // Reset text anyway
            }
        }
    });

    // 2. Repository Selection Change (No changes needed)
    repoSelect.addEventListener('change', () => {
        loadRepoButton.disabled = repoSelect.value === '';
    });

    // 3. Load Repository Button Click (No changes needed conceptually)
    loadRepoButton.addEventListener('click', () => {
        const selectedRepoFullName = repoSelect.value;
        if (!selectedRepoFullName) return;

        [selectedOwner, selectedRepo] = selectedRepoFullName.split('/');
        currentRepoSpan.textContent = selectedRepoFullName;
        updateStatus(`'${selectedRepoFullName}' ì €ì¥ì†Œ ë¡œë”© ì¤‘...`);
        // Disable repo selection while loading files
        repoSelect.disabled = true;
        loadRepoButton.disabled = true;
        showSection(fileBrowserSection);
        fetchContents(''); // Fetch root contents
    });

    // 4. Fetch Repository Contents (Files/Dirs) (*** MODIFIED for Octokit Error Handling ***)
    async function fetchContents(path) {
        if (!octokit || !selectedOwner || !selectedRepo) {
             updateStatus("ì˜¤ë¥˜: Octokitì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì €ì¥ì†Œê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", true);
             // Re-enable repo selection if something went wrong before loading
             repoSelect.disabled = false;
             loadRepoButton.disabled = repoSelect.value === '';
             return;
        }
        currentPath = path;
        updateBreadcrumb();
        fileListUl.innerHTML = '<li><em><center>ë¡œë”© ì¤‘...</center></em></li>';
        showSection(fileBrowserSection);
        editorSection.classList.add('hidden'); // Hide editor when browsing
        // Disable 'New File' button while loading directory
        createNewFileButton.disabled = true;
        updateStatus(`'${selectedOwner}/${selectedRepo}/${path || 'root'}' ë¡œë”© ì¤‘...`);

        try {
            // Use octokit.rest.repos.getContent
            const { data: contents } = await octokit.rest.repos.getContent({
                owner: selectedOwner,
                repo: selectedRepo,
                path: path,
                ref: currentBranch, // Use the configured branch
                 // Add cache-busting parameter to try and avoid stale results after save/delete
                 // GitHub's caching can be aggressive. This isn't foolproof.
                 random: Date.now()
            });

            // Ensure contents is always an array (GitHub returns an object for single file paths)
            const contentList = Array.isArray(contents) ? contents : [contents];

            // Filter out non-file/dir types (like submodules, symlinks) and sort
            currentFiles = contentList
                .filter(item => item.type === 'file' || item.type === 'dir')
                .sort((a, b) => {
                    if (a.type === b.type) return a.name.localeCompare(b.name, 'ko', { sensitivity: 'base' });
                    return a.type === 'dir' ? -1 : 1; // Dirs first
                });

            fileListUl.innerHTML = ''; // Clear loading message

            // Add parent directory link if not at root
            if (path !== '') {
                addParentDirectoryLink(path);
            }

            // Populate file list
            if (currentFiles.length > 0) {
                currentFiles.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item.name;
                    li.classList.add(item.type); // 'file' or 'dir'
                    li.dataset.path = item.path;
                    li.dataset.type = item.type;
                    li.dataset.sha = item.sha; // SHA is available for both files and dirs

                    if (item.type === 'dir') {
                        li.onclick = () => fetchContents(item.path);
                        li.title = `í´ë” ì—´ê¸°: ${item.path}`;
                    } else if (item.type === 'file') {
                        // Allow editing only .md files
                        const isEditable = /\.md$/i.test(item.name);
                        if (isEditable) {
                             li.title = `íŒŒì¼ ìˆ˜ì •: ${item.path}`;
                             // Pass the file SHA (blob SHA) for fetching content
                             li.onclick = () => fetchFileContent(item.path, item.sha);
                        } else {
                             li.style.cursor = 'default';
                             li.style.color = '#888';
                             li.title = `Hugo .md íŒŒì¼ë§Œ í¸ì§‘ ì§€ì›`;
                             li.onclick = (e) => e.stopPropagation(); // Prevent potential bubbling
                        }
                    }
                    fileListUl.appendChild(li);
                });
             } else if (path === '' && contentList.length === 0) { // Check contentList length for root specifically
                 // Root directory is empty
                 const li = document.createElement('li');
                 li.textContent = '(ì €ì¥ì†Œ ë£¨íŠ¸ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤)';
                 li.style.fontStyle = 'italic'; li.style.color = '#888'; li.style.cursor = 'default';
                 fileListUl.appendChild(li);
             } else if (path !== '' && currentFiles.length === 0) {
                 // Non-root directory is empty
                 const li = document.createElement('li');
                 li.textContent = '(í´ë”ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤)';
                 li.style.fontStyle = 'italic'; li.style.color = '#888'; li.style.cursor = 'default';
                 fileListUl.appendChild(li);
             }

             updateStatus(`'${selectedOwner}/${selectedRepo}/${path || 'root'}' ë¡œë“œ ì™„ë£Œ.`, false, true); // Success

        } catch (error) {
             console.error("Fetch Contents Error:", error);
             let errorMsg = `í´ë” ë‚´ìš© ë¡œë“œ ì‹¤íŒ¨: ${error.message}`;
              if (error.status === 404) {
                  errorMsg = `ê²½ë¡œ '${path || 'root'}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (${error.status}). ì €ì¥ì†Œ ë˜ëŠ” ê²½ë¡œë¥¼ í™•ì¸í•˜ì„¸ìš”.`;
              } else if (error.status === 403) {
                  // Could be rate limit, or PAT lacks permission for this specific repo/path
                  errorMsg = `ì €ì¥ì†Œ ì ‘ê·¼ ê¶Œí•œ ì˜¤ë¥˜ (${error.status}). PAT ê¶Œí•œì´ë‚˜ API ì œí•œì„ í™•ì¸í•˜ì„¸ìš”.`;
              } else if (error.status === 401) {
                  errorMsg = `GitHub API ì¸ì¦ ì˜¤ë¥˜ (${error.status}): PATê°€ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`;
                  // Force re-login
                  octokit = null;
                  showSection(loginSection);
                  patInput.disabled = false;
                  loginButton.disabled = false;
                  repoSelect.disabled = false; // Re-enable repo select
                  loadRepoButton.disabled = true; // But disable load button
                  return; // Exit function early
              }
             updateStatus(errorMsg, true);
             fileListUl.innerHTML = `<li class="error" style="cursor: default; background-color: #f8d7da; color: #721c24; padding: 10px;">ì˜¤ë¥˜: í´ë” ë‚´ìš©ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (${error.message})</li>`;
             // Still add parent link if possible on error, even if listing failed
             if (path !== '') {
                 addParentDirectoryLink(path);
             }
        } finally {
             // Re-enable 'New File' button after loading completes (success or error)
             createNewFileButton.disabled = false;
             // Re-enable repo selection controls
             repoSelect.disabled = false;
             loadRepoButton.disabled = repoSelect.value === '';
        }
    }


    // 5. Fetch File Content for Editor (*** MODIFIED for Octokit Error Handling ***)
    async function fetchFileContent(filePath, fileSha) {
        if (!octokit || !selectedOwner || !selectedRepo) {
             updateStatus("ì˜¤ë¥˜: Octokitì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì €ì¥ì†Œê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", true);
             return;
        }
        updateStatus(`'${filePath}' íŒŒì¼ ë‚´ìš© ë¡œë”© ì¤‘...`);
        // Disable potentially conflicting actions
        createNewFileButton.disabled = true;
        fileListUl.style.pointerEvents = 'none'; // Prevent clicking other files
        // Ensure editor buttons are disabled initially
        saveFileButton.disabled = true;
        deleteFileButton.disabled = true;
        cancelEditButton.disabled = true;
        showSection(null); // Hide sections while loading

        try {
            // Use octokit.rest.git.getBlob using the SHA from getContent
            // This is generally preferred for raw file content.
            const { data: blobData } = await octokit.rest.git.getBlob({
                owner: selectedOwner,
                repo: selectedRepo,
                file_sha: fileSha // Use the sha passed from the file list item
            });

            // Basic validation of blob data
            if (!blobData || !blobData.sha || blobData.encoding !== 'base64' || typeof blobData.content === 'undefined') {
                 throw new Error('API ì‘ë‹µ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤ (Blob). Content, SHA, ë˜ëŠ” Encoding ëˆ„ë½.');
            }

            // Check for truncation (GitHub blob API limit is 1MB for direct content)
            const sizeLimit = 1 * 1024 * 1024; // 1 MB
            if (blobData.size > sizeLimit) {
                 // Display a warning but still try to load. The b64Decode might fail or show partial content.
                 updateStatus(`ê²½ê³ : íŒŒì¼ ë‚´ìš©ì´ í½ë‹ˆë‹¤ (${(blobData.size / 1024 / 1024).toFixed(2)} MB > 1MB). ì „ì²´ ë‚´ìš©ì´ ë¡œë“œë˜ì§€ ì•Šê±°ë‚˜ í¸ì§‘ ì¤‘ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`, true); // Use error style for high visibility
                 // Optionally: alert(`íŒŒì¼ í¬ê¸°ê°€ 1MBë¥¼ ì´ˆê³¼í•˜ì—¬(${blobData.size} bytes) ë¡œë“œ/í¸ì§‘ì´ ë¶ˆì•ˆì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
            }

            let decodedContent;
            try {
                 decodedContent = b64DecodeUnicode(blobData.content);
            } catch (decodeError) {
                 // Handle potential decoding error specifically
                 updateStatus(`íŒŒì¼ ë””ì½”ë”© ì‹¤íŒ¨ (${filePath}): ${decodeError.message}. íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ UTF-8 ì¸ì½”ë”©ì´ ì•„ë‹ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`, true);
                 showSection(fileBrowserSection); // Go back to browser
                 return; // Stop further processing
            }

            const parsedData = parseFrontMatter(decodedContent);

            // Populate editor fields
            fileNameInput.value = filePath.substring(filePath.lastIndexOf('/') + 1);
            fmTitleInput.value = parsedData.title || '';
            fmAuthorInput.value = parsedData.author || '';
            fmDateInput.value = parsedData.date || '';
            fmDescriptionInput.value = parsedData.description || '';
            fmTagsInput.value = (parsedData.tags || []).join(', ');
            fmCategoriesInput.value = (parsedData.categories || []).join(', ');
            // Handle 'toc': checked if true, unchecked if false or undefined
            fmTocCheckbox.checked = (parsedData.toc === true);
            fileContentInput.value = parsedData.body || '';

            // Store the actual blob SHA and full path
            currentFileShaInput.value = blobData.sha; // Use the SHA returned by getBlob
            currentFilePathInput.value = filePath;

            // Enable buttons for editing/deleting existing file
            saveFileButton.textContent = 'ì €ì¥ (ìˆ˜ì •)';
            saveFileButton.disabled = false;
            deleteFileButton.disabled = false;
            cancelEditButton.disabled = false;

            updateCommitMessage(); // Generate default commit message for update

            updateStatus(`'${filePath}' ë¡œë“œ ì™„ë£Œ. í¸ì§‘ ê°€ëŠ¥.`, false, true); // Success
            showSection(editorSection);

        } catch (error) {
            console.error("Fetch File Content Error:", error);
            let errorMsg = `íŒŒì¼ ë‚´ìš© ë¡œë”© ì‹¤íŒ¨ (${filePath}): ${error.message}`;
             if (error.status === 404) {
                 errorMsg = `íŒŒì¼ Blob (SHA: ${fileSha})ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (${error.status}). íŒŒì¼ì´ ì´ë™, ì‚­ì œ ë˜ëŠ” ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;
             } else if (error.status === 403) {
                 errorMsg = `íŒŒì¼ ì ‘ê·¼ ê¶Œí•œ ì˜¤ë¥˜ (${error.status}).`;
             } else if (error.status === 422) { // Unprocessable Entity, maybe bad SHA format?
                 errorMsg = `ì˜ëª»ëœ ìš”ì²­ (${error.status}): SHA í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (${error.message})`;
             } else if (error.status === 401) {
                  errorMsg = `GitHub API ì¸ì¦ ì˜¤ë¥˜ (${error.status}): PATê°€ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`;
                  octokit = null; showSection(loginSection); patInput.disabled = false; loginButton.disabled = false;
             } else if (error.message.includes('Blob is too big')) {
                 // Catch potential explicit "too big" errors from Octokit/API if they occur
                 errorMsg = `íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤ (${filePath}). GitHub APIê°€ ë‚´ìš©ì„ ë°˜í™˜í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.`;
             }
            updateStatus(errorMsg, true);
            showSection(fileBrowserSection); // Go back to browser on error
        } finally {
            // Re-enable file browser interactions regardless of success/failure
            createNewFileButton.disabled = false;
            fileListUl.style.pointerEvents = 'auto';
        }
    }

    // 6. Show Create New File Form (Minor changes for consistency)
    createNewFileButton.addEventListener('click', () => {
        clearEditorFields(); // Clear fields first

        // Set default date to current local time in ISO 8601 format with timezone
        const now = new Date();
        const offset = -now.getTimezoneOffset(); // Offset in minutes from UTC
        const sign = offset >= 0 ? '+' : '-';
        const pad = (num, width = 2) => String(num).padStart(width, '0');
        const offsetHours = pad(Math.floor(Math.abs(offset) / 60));
        const offsetMinutes = pad(Math.abs(offset) % 60);
        // Format: YYYY-MM-DDTHH:MM:SS+HH:MM or Z for UTC
        const timezoneString = (offset === 0) ? 'Z' : `${sign}${offsetHours}:${offsetMinutes}`;
        const localISOString = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}T${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}${timezoneString}`;
        fmDateInput.value = localISOString;

        // Update state for new file
        deleteFileButton.disabled = true; // Cannot delete a new file
        saveFileButton.textContent = 'ì €ì¥ (ìƒì„±)';
        // Enable save/cancel only after title is potentially entered
        saveFileButton.disabled = false; // Let's enable it, validation will catch missing title
        cancelEditButton.disabled = false;

        updateCommitMessage(); // Generate initial (empty) commit message based on empty filename

        updateStatus('ìƒˆ íŒŒì¼ ìƒì„± ì¤€ë¹„ ì™„ë£Œ. Titleì„ ì…ë ¥í•˜ë©´ íŒŒì¼ëª…ê³¼ ì»¤ë°‹ ë©”ì‹œì§€ê°€ ìë™ ìƒì„±ë©ë‹ˆë‹¤.');
        showSection(editorSection);
        fmTitleInput.focus(); // Focus on Title first
    });


    // 7. Save File (Handles Create or Update/Rename) (*** MODIFIED for Octokit Error Handling ***)
    saveFileButton.addEventListener('click', async () => {
        if (!octokit || !selectedOwner || !selectedRepo) {
             updateStatus("ì˜¤ë¥˜: Octokitì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì €ì¥ì†Œê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", true);
             return;
        }

        // --- Read data from form ---
        let fileName = fileNameInput.value.trim();
        const fileBodyContent = fileContentInput.value; // Keep as is
        let commitMessage = commitMessageInput.value.trim();
        const existingSha = currentFileShaInput.value; // SHA of the blob being edited (if any)
        const existingFullPath = currentFilePathInput.value; // Full path of the file being edited (if any)
        const isUpdate = !!existingSha && !!existingFullPath; // More robust check for update

        // --- Input Validation ---
        const titleValue = fmTitleInput.value.trim();
        if (!titleValue) {
             updateStatus("ì˜¤ë¥˜: Front Matterì˜ 'Title'ì€ í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.", true);
             fmTitleInput.focus(); return;
        }
        if (!fileName) {
            updateStatus('ì˜¤ë¥˜: íŒŒì¼ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”. Titleì„ ì…ë ¥í•˜ë©´ ìë™ ìƒì„±ë©ë‹ˆë‹¤.', true);
            fileNameInput.focus(); return;
        }
        if (fileName.includes('/')) {
             updateStatus("ì˜¤ë¥˜: íŒŒì¼ ì´ë¦„ì—ëŠ” ìŠ¬ë˜ì‹œ('/')ë¥¼ í¬í•¨í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê²½ë¡œëŠ” íƒìƒ‰ê¸°ì—ì„œ ì´ë™í•˜ì—¬ ê²°ì •ë©ë‹ˆë‹¤.", true);
             fileNameInput.focus(); return;
        }
        if (!fileName.toLowerCase().endsWith('.md')) {
              // Let's auto-correct or warn more strongly
              fileName += '.md';
              fileNameInput.value = fileName; // Update the input field
              updateStatus("ê²½ê³ : íŒŒì¼ í™•ì¥ìê°€ .mdê°€ ì•„ë‹ˆë¯€ë¡œ '.md'ë¥¼ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.", false); // Use neutral status
              // return; // Or just proceed with the corrected name
         }
         if (!fmDateInput.value.trim()) {
             updateStatus("ì˜¤ë¥˜: Front Matterì˜ 'Date'ëŠ” í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.", true);
             fmDateInput.focus(); return;
         }
         // Stricter regex for date validation (including Z or offset)
         if (!/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2})$/.test(fmDateInput.value.trim())) {
              updateStatus("ì˜¤ë¥˜: 'Date' í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤ (YYYY-MM-DDTHH:MM:SSZ ë˜ëŠ” YYYY-MM-DDTHH:MM:SS+/-HH:MM).", true);
              fmDateInput.focus(); return;
         }
         // Regenerate commit message if empty or default, *before* final check
         if (!commitMessage || commitMessage === `Update ${fileName}` || commitMessage === `Create ${fileName}` ) {
             updateCommitMessage(); // Ensure it's up-to-date based on current filename
             commitMessage = commitMessageInput.value.trim(); // Re-read
         }
         if (!commitMessage) {
             // If still empty after update, prompt user
             updateStatus("ì˜¤ë¥˜: ì»¤ë°‹ ë©”ì‹œì§€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.", true);
             commitMessageInput.focus(); return;
         }
        // --- End Validation ---

        // Construct Front Matter Data Object
        const fmData = {
            title: titleValue, author: fmAuthorInput.value.trim(), date: fmDateInput.value.trim(),
            description: fmDescriptionInput.value.trim(),
            tags: fmTagsInput.value.split(',').map(t => t.trim()).filter(t => t),
            categories: fmCategoriesInput.value.split(',').map(c => c.trim()).filter(c => c),
            toc: fmTocCheckbox.checked // Pass boolean directly
        };

        let finalContent;
        try {
            const frontMatterString = formatFrontMatter(fmData);
            finalContent = frontMatterString + fileBodyContent; // Combine FM + Body
        } catch (formatError) {
             updateStatus(`Front Matter ìƒì„± ì˜¤ë¥˜: ${formatError.message}`, true);
             return;
        }

        const targetBasePath = currentPath ? currentPath + '/' : ''; // Base path from browser
        const targetFullPath = targetBasePath + fileName; // The final path where the file should be saved

        // *** Handle potential rename ***
        // A rename occurs if it's an update operation AND the target path is different from the original path.
        const isRename = isUpdate && (targetFullPath !== existingFullPath);
        let userWarnedAboutRename = false;
        if (isRename) {
             // Warn the user that this creates a new file and doesn't delete the old one.
             if (!confirm(`íŒŒì¼ ì´ë¦„ ë˜ëŠ” ê²½ë¡œê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.\n\nê¸°ì¡´ íŒŒì¼: '${existingFullPath}'\nìƒˆ íŒŒì¼: '${targetFullPath}'\n\nGitHub APIëŠ” ì§ì ‘ì ì¸ ì´ë¦„ ë³€ê²½ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒˆ ê²½ë¡œì— íŒŒì¼ì„ ìƒì„±í•˜ê²Œ ë©ë‹ˆë‹¤.\n\nâš ï¸ ê¸°ì¡´ íŒŒì¼ ('${existingFullPath}')ì€ ìë™ìœ¼ë¡œ ì‚­ì œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤! ìˆ˜ë™ìœ¼ë¡œ ì‚­ì œí•´ì•¼ í•©ë‹ˆë‹¤.\n\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                 updateStatus("ì´ë¦„ ë³€ê²½ ì‘ì—… ì·¨ì†Œë¨.", false);
                 return; // Stop the save operation
             }
             userWarnedAboutRename = true;
             // Adjust commit message for clarity if using the default
             const oldFilenameOnly = existingFullPath.substring(existingFullPath.lastIndexOf('/') + 1);
             if (commitMessage === `Update ${oldFilenameOnly}`) {
                 commitMessageInput.value = `Create ${fileName} (renamed from ${oldFilenameOnly})`;
                 commitMessage = commitMessageInput.value; // Re-read the updated message
             }
        }

        updateStatus(`'${targetFullPath}' ì €ì¥ ì¤‘...`);
        // Disable all editor buttons during save
        saveFileButton.disabled = true;
        cancelEditButton.disabled = true;
        deleteFileButton.disabled = true;

        let encodedContent;
        try {
            encodedContent = b64EncodeUnicode(finalContent); // Encode the final content
        } catch(encodeError) {
            updateStatus(`íŒŒì¼ ë‚´ìš© ì¸ì½”ë”© ì‹¤íŒ¨: ${encodeError.message}`, true);
            saveFileButton.disabled = false; // Re-enable buttons on early failure
            cancelEditButton.disabled = false;
            deleteFileButton.disabled = !isUpdate; // Re-enable delete only if it was an update attempt
            return;
        }

        try {
            // Prepare parameters for Octokit
            const params = {
                owner: selectedOwner,
                repo: selectedRepo,
                path: targetFullPath,
                message: commitMessage,
                content: encodedContent,
                branch: currentBranch
            };

            // *** Add SHA only if updating the SAME file ***
            // If it's a rename (isRename = true), do NOT provide SHA, as we are creating a new file at a new path.
            // If it's a create (isUpdate = false), do NOT provide SHA.
            if (isUpdate && !isRename) {
                params.sha = existingSha; // Required SHA for updating existing file at the *same* path
            }

            // Use octokit.rest.repos.createOrUpdateFileContents
            const { data: result } = await octokit.rest.repos.createOrUpdateFileContents(params);

            const action = isUpdate ? (isRename ? 'ì´ë¦„ ë³€ê²½ìœ¼ë¡œ ìƒì„±' : 'ìˆ˜ì •') : 'ìƒì„±';
            updateStatus(`'${targetFullPath}' ${action} ì™„ë£Œ. SHA: ${result?.content?.sha}`, false, true); // Success

            // Clear editor and go back to browser
            clearEditorFields();
            showSection(fileBrowserSection);
            fetchContents(currentPath); // Refresh file list in the *current* directory

            // If it was a rename, remind the user about the old file
            if (isRename) {
                 alert(`íŒŒì¼ '${targetFullPath}'ì´(ê°€) ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.\n\nì•Œë¦¼: ê¸°ì¡´ íŒŒì¼ '${existingFullPath}'ì€(ëŠ”) ì‚­ì œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í•„ìš”í•˜ë‹¤ë©´ ìˆ˜ë™ìœ¼ë¡œ ì‚­ì œí•´ì£¼ì„¸ìš”.`);
            }

        } catch (error) {
            console.error("Save File Error:", error);
            let errorMsg = `íŒŒì¼ ì €ì¥ ì‹¤íŒ¨ (${targetFullPath}): ${error.message}`;
            if (error.status === 409) { // Conflict (SHA mismatch, branch out of date)
                errorMsg = `íŒŒì¼ ì €ì¥ ì¶©ëŒ (${error.status}): íŒŒì¼ì´ ì„œë²„ì—ì„œ ë³€ê²½ë˜ì—ˆê±°ë‚˜ ë¸Œëœì¹˜ê°€ ìµœì‹  ìƒíƒœê°€ ì•„ë‹ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ê³  ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”. (${error.message})`;
            } else if (error.status === 422) { // Unprocessable Entity (validation error on GitHub's side)
                errorMsg = `ì˜ëª»ëœ ìš”ì²­ ë°ì´í„° (${error.status}): ${error.message}. `;
                // Try to get more specific error details from Octokit's response
                if (error.response?.data?.message) {
                     errorMsg += `GitHub ë©”ì‹œì§€: ${error.response.data.message}`;
                }
                 if (error.response?.data?.errors) {
                     errorMsg += ` ì„¸ë¶€ ì •ë³´: ${error.response.data.errors.map(e => `${e.resource} ${e.field || ''}: ${e.code} ${e.message || ''}`).join(', ')}`;
                 }
            } else if (error.status === 404 && isUpdate && !isRename) {
                 // Trying to update a file (with correct path) but SHA is not found
                 errorMsg = `íŒŒì¼ ìˆ˜ì • ì‹¤íŒ¨ (${error.status}): ì›ë³¸ íŒŒì¼(SHA: ${existingSha})ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‚­ì œë˜ì—ˆê±°ë‚˜ íŒŒì¼ ë‚´ìš©ì´ ë³€ê²½ë˜ì–´ SHAê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.`;
            } else if (error.status === 403) {
                  errorMsg = `íŒŒì¼ ì €ì¥ ê¶Œí•œ ì˜¤ë¥˜ (${error.status}): ì´ ì €ì¥ì†Œ ë˜ëŠ” ê²½ë¡œì— íŒŒì¼ì„ ì“°ê±°ë‚˜ ìˆ˜ì •í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.`;
            } else if (error.status === 401) {
                  errorMsg = `GitHub API ì¸ì¦ ì˜¤ë¥˜ (${error.status}): PATê°€ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`;
                  octokit = null; showSection(loginSection); patInput.disabled = false; loginButton.disabled = false;
                  return; // Exit early
            }
            updateStatus(errorMsg, true);

            // Re-enable buttons on failure, allowing user to retry or cancel
            saveFileButton.disabled = false;
            cancelEditButton.disabled = false;
            // Only re-enable delete if it was an update attempt (not rename or create) that failed
            deleteFileButton.disabled = !(isUpdate && !isRename);
        }
    });

    // 8. Delete File (*** MODIFIED for Octokit Error Handling ***)
    deleteFileButton.addEventListener('click', async () => {
        if (!octokit || !selectedOwner || !selectedRepo) {
             updateStatus("ì˜¤ë¥˜: Octokitì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì €ì¥ì†Œê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", true);
             return;
        }

        const filePathToDelete = currentFilePathInput.value;
        const fileShaToDelete = currentFileShaInput.value; // This is the blob SHA, required for deletion API
        const filenameOnly = filePathToDelete ? filePathToDelete.substring(filePathToDelete.lastIndexOf('/') + 1) : 'ì•Œ ìˆ˜ ì—†ëŠ” íŒŒì¼';

        if (!filePathToDelete || !fileShaToDelete) {
            updateStatus('ì˜¤ë¥˜: ì‚­ì œí•  íŒŒì¼ ì •ë³´(ê²½ë¡œ ë˜ëŠ” SHA)ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. íŒŒì¼ì„ ë‹¤ì‹œ ë¡œë“œí•´ì£¼ì„¸ìš”.', true);
            return;
        }

        // Confirmation dialog
        if (!confirm(`ì •ë§ë¡œ '${filenameOnly}' íŒŒì¼ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nê²½ë¡œ: ${filePathToDelete}\n\nâš ï¸ ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤! GitHub ì €ì¥ì†Œì—ì„œ íŒŒì¼ì´ ì˜êµ¬ì ìœ¼ë¡œ ì œê±°ë©ë‹ˆë‹¤.`)) {
            updateStatus('íŒŒì¼ ì‚­ì œ ì‘ì—… ì·¨ì†Œë¨.', false);
            return;
        }

        let commitMessage = commitMessageInput.value.trim();
         // Use a standard delete message if the current one seems inappropriate (e.g., left over from editing)
         if (!commitMessage || commitMessage.toLowerCase().startsWith('update ') || commitMessage.toLowerCase().startsWith('create ') || commitMessage.length < 5) {
             commitMessage = `Delete ${filenameOnly} via web editor`;
             commitMessageInput.value = commitMessage; // Update field for clarity, though it won't be saved
         }

        updateStatus(`'${filePathToDelete}' ì‚­ì œ ì¤‘...`);
        // Disable all editor buttons during deletion
        saveFileButton.disabled = true;
        cancelEditButton.disabled = true;
        deleteFileButton.disabled = true;

        try {
            // Use octokit.rest.repos.deleteFile
            await octokit.rest.repos.deleteFile({
                owner: selectedOwner,
                repo: selectedRepo,
                path: filePathToDelete,
                message: commitMessage,
                sha: fileShaToDelete, // SHA of the blob being deleted is REQUIRED
                branch: currentBranch
            });

            updateStatus(`'${filePathToDelete}' ì‚­ì œ ì™„ë£Œ.`, false, true); // Success
            clearEditorFields();
            showSection(fileBrowserSection); // Go back to browser
            fetchContents(currentPath); // Refresh file list

        } catch (error) {
            console.error("Delete File Error:", error);
            let errorMsg = `íŒŒì¼ ì‚­ì œ ì‹¤íŒ¨ (${filePathToDelete}): ${error.message}`;
             if (error.status === 404) {
                 errorMsg = `ì‚­ì œí•  íŒŒì¼ '${filePathToDelete}' (SHA: ${fileShaToDelete})ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (${error.status}). ì´ë¯¸ ì‚­ì œë˜ì—ˆê±°ë‚˜ íŒŒì¼ ë‚´ìš©ì´ ë³€ê²½ë˜ì–´ SHAê°€ ì¼ì¹˜í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;
             } else if (error.status === 409) { // Conflict (SHA mismatch)
                 errorMsg = `íŒŒì¼ ì‚­ì œ ì¶©ëŒ (${error.status}): íŒŒì¼ì´ ì„œë²„ì—ì„œ ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤ (SHA ë¶ˆì¼ì¹˜). í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ê³  ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”. (${error.message})`;
             } else if (error.status === 422) { // Unprocessable Entity (e.g., missing SHA in request)
                  errorMsg = `ì˜ëª»ëœ ì‚­ì œ ìš”ì²­ (${error.status}): í•„ìˆ˜ íŒŒë¼ë¯¸í„°(SHA ë“±)ê°€ ëˆ„ë½ë˜ì—ˆê±°ë‚˜ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (${error.message})`;
             } else if (error.status === 403) {
                  errorMsg = `íŒŒì¼ ì‚­ì œ ê¶Œí•œ ì˜¤ë¥˜ (${error.status}): ì´ íŒŒì¼ì„ ì‚­ì œí•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.`;
             } else if (error.status === 401) {
                  errorMsg = `GitHub API ì¸ì¦ ì˜¤ë¥˜ (${error.status}): PATê°€ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`;
                  octokit = null; showSection(loginSection); patInput.disabled = false; loginButton.disabled = false;
                  return; // Exit early
             }
            updateStatus(errorMsg, true);

            // On delete failure, the file might still exist. Allow cancelling back to the editor or retrying delete.
            // Don't re-enable save, as the state is uncertain.
            cancelEditButton.disabled = false;
            // Re-enable delete only if it wasn't a 404 (already deleted)
            deleteFileButton.disabled = (error.status === 404);
        }
    });

    // 9. Cancel Edit / Clear Editor (No changes needed)
    cancelEditButton.addEventListener('click', () => {
        // Ask for confirmation if content has potentially changed (simple check)
        // A more sophisticated check would compare initial content vs current content.
        const hasContent = fmTitleInput.value || fileContentInput.value || currentFileShaInput.value;
        if (hasContent) {
             if (!confirm("í¸ì§‘ ì¤‘ì¸ ë‚´ìš©ì´ ìˆìŠµë‹ˆë‹¤. ì €ì¥í•˜ì§€ ì•Šê³  ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                 return;
             }
        }
        clearEditorFields();
        updateStatus('í¸ì§‘ ì‘ì—… ì·¨ì†Œë¨.');
        showSection(fileBrowserSection);
        // Optionally refresh the current folder view in case the user was creating a new file
        // fetchContents(currentPath); // Uncomment if needed, but might be slow
    });

    // --- Event listeners for automatic updates --- (No changes needed)
    fmTitleInput.addEventListener('input', () => {
         const generatedFilename = generateHugoFilename(fmTitleInput.value);
         fileNameInput.value = generatedFilename;
         updateCommitMessage(); // Update commit message based on new filename/title
    });

    fileNameInput.addEventListener('input', () => {
         updateCommitMessage(); // Update commit message if user manually edits filename
    });

    // Prevent accidental form submission if wrapped in a <form> tag (though not currently the case)
    // document.querySelectorAll('input, textarea, select').forEach(el => {
    //     el.addEventListener('keydown', (e) => {
    //         if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
    //             e.preventDefault(); // Prevent Enter key from submitting forms accidentally
    //         }
    //     });
    // });


    // --- Initial State ---
    clearEditorFields(); // Ensure editor is clear initially
    showSection(loginSection);
    updateStatus('ì‹œì‘: GitHub PATë¥¼ ì…ë ¥í•˜ê³  ì €ì¥ì†Œë¥¼ ì„ íƒí•˜ì„¸ìš”.');

</script>

</body>
</html>