<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub 파일 에디터 (Octokit + Hugo)</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 0px; background-color: #f4f4f4; color: #333; }
        .container {
        max-width: 900px; /* 최대 너비 유지 */
        margin: 20px auto; /* 상하 여백 및 중앙 정렬 유지 */
        }

        .section {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        }
        h1, h2, h3 { color: #0056b3; }
        h1 { text-align: center; margin-bottom: 30px; }
        h2 { border-bottom: 2px solid #eee; padding-bottom: 10px; margin-bottom: 15px; }
        h3 { margin-top: 20px; margin-bottom: 10px; color: #333; }
        label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
        input[type="text"], input[type="password"], select, textarea {
            width: 100%;
            padding: 12px;
            margin-bottom: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1rem;
        }
        textarea { height: 350px; font-family: 'Courier New', Courier, monospace; line-height: 1.5; }
        button {
            padding: 12px 18px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            margin-top: 10px;
            font-size: 1rem;
            transition: background-color 0.2s ease;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #fileList ul { list-style: none; padding: 0; margin: 0; max-height: 300px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px;}
        #fileList li { padding: 10px 12px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: center; transition: background-color 0.2s ease;}
        #fileList li:last-child { border-bottom: none; }
        #fileList li:hover { background-color: #f0f8ff; }
        #fileList li::before { margin-right: 10px; font-size: 1.1em; }
        #fileList li.dir::before { content: '📁'; color: #ffac33; }
        #fileList li.file::before { content: '📄'; color: #6c757d; }
        #fileList li strong { font-weight: bold; color: #0056b3; }
        #statusBar { margin-top: 20px; padding: 10px; background-color: #e9ecef; border-radius: 4px; color: #495057; font-style: italic; text-align: center;}
        .hidden { display: none; }
        .status-bar-error { color: #721c24 !important; background-color: #f8d7da !important; border: 1px solid #f5c6cb !important; font-weight: bold; }
        .status-bar-success { color: #155724 !important; background-color: #d4edda !important; border: 1px solid #c3e6cb !important; }
        .warning { color: #856404; background-color: #fff3cd; border-color: #ffeeba; border-left: 4px solid #ffc107; padding: 10px; border-radius: 4px; margin-bottom: 15px;}
        .error { color: #dc3545; font-weight: bold; border-left: 4px solid #dc3545; padding: 10px; background-color: #f8d7da; border-radius: 4px; margin-bottom: 15px;}
        .breadcrumb { margin-bottom: 15px; font-size: 0.95em; color: #6c757d; }
        .breadcrumb strong { color: #333; }
        .breadcrumb a { text-decoration: none; color: #007bff; }
        .breadcrumb a:hover { text-decoration: underline; }
        .breadcrumb span { margin: 0 5px; color: #aaa; }
        hr { margin: 25px 0; border: 0; border-top: 1px solid #eee; }
        label[for="fmTocCheckbox"] { display: inline-block; margin-right: 10px; margin-bottom: 10px; font-weight: normal; }
        input[type="checkbox"] { margin-right: 8px; vertical-align: middle; width: auto; }
    
        /* Responsive */
        @media (max-width: 600px) {
            /* .section 에 대한 별도 마진 설정 제거 -> 기본값(좌우 1%)이 적용됨 */
            button { width: 100%; margin-right: 0; margin-bottom: 10px; }
            input[type="text"], input[type="password"], select, textarea { padding: 10px; }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>GitHub 파일 에디터 (Octokit + Hugo)</h1>

    <!-- 1. Login Section -->
    <div id="loginSection" class="section">
        <h2>1. GitHub 로그인 (Octokit 사용)</h2>
        <div class="warning"> <!-- Changed to warning class -->
            <strong>주의:</strong> Personal Access Token (PAT)을 브라우저에 저장하거나 입력하는 것은 보안상 위험할 수 있습니다. 반드시 신뢰할 수 있는 환경에서 개인적인 용도로만 사용하고, 토큰이 외부에 노출되지 않도록 각별히 주의하세요. 사용 후에는 브라우저 캐시를 지우거나 시크릿 모드를 사용하는 것이 좋습니다. 토큰에는 <strong>'repo'</strong> 권한이 필요합니다.
        </div>
        <label for="patInput">Personal Access Token (PAT):</label>
        <input type="password" id="patInput" placeholder="GitHub PAT 입력 (repo 권한 필요)">
        <button id="loginButton">저장소 목록 불러오기</button>
    </div>

    <!-- 2. Repository Selection -->
    <div id="repoSection" class="section hidden">
        <h2>2. 저장소 선택</h2>
        <label for="repoSelect">저장소:</label>
        <select id="repoSelect"></select>
        <button id="loadRepoButton" disabled>파일 목록 불러오기</button>
    </div>

    <!-- 3. File Browser -->
    <div id="fileBrowserSection" class="section hidden">
        <h2>3. 파일 탐색기</h2>
        <div><strong>현재 저장소:</strong> <span id="currentRepo"></span></div>
        <div class="breadcrumb"><strong>경로:</strong> <span id="currentPathBreadcrumb">/</span></div>
        <div id="fileList">
            <ul></ul>
        </div>
        <button id="createNewFileButton">새 파일 만들기 (Hugo)</button>
    </div>

    <!-- 4. File Editor -->
    <div id="editorSection" class="section hidden">
        <h2>4. 파일 편집기 / Front Matter (TOML)</h2>
        <input type="hidden" id="currentFileSha">
        <input type="hidden" id="currentFilePathInput">

         <label for="fmTitleInput">Title (필수, 파일명 생성에 사용):</label>
         <input type="text" id="fmTitleInput" placeholder="게시물 제목">

         <label for="fileNameInput">파일 이름 (자동 생성/편집 가능, 확장자 .md 고정):</label>
         <input type="text" id="fileNameInput" placeholder="my-new-post.md (Title 입력 시 자동 생성)">

        <hr>
        <h3>Hugo Front Matter (TOML)</h3>
        <!-- Title input moved above -->
        <label for="fmAuthorInput">Author:</label>
        <input type="text" id="fmAuthorInput" placeholder="작성자 (선택 사항)">

        <label for="fmDateInput">Date (필수, YYYY-MM-DDTHH:MM:SSZ 형식 권장):</label>
        <input type="text" id="fmDateInput" placeholder="예: 2023-10-27T15:04:05+09:00 또는 2023-10-27T06:04:05Z">

        <label for="fmDescriptionInput">Description:</label>
        <input type="text" id="fmDescriptionInput" placeholder="간단한 설명 (선택 사항)">

        <label for="fmTagsInput">Tags (쉼표로 구분):</label>
        <input type="text" id="fmTagsInput" placeholder="예: web, development, github">

        <label for="fmCategoriesInput">Categories (쉼표로 구분):</label>
        <input type="text" id="fmCategoriesInput" placeholder="예: tech, programming">

        <div>
             <input type="checkbox" id="fmTocCheckbox">
             <label for="fmTocCheckbox">Table of Contents (TOC) 생성</label>
        </div>
        <hr>

        <label for="fileContentInput">파일 내용 (본문 - Markdown 등):</label>
        <textarea id="fileContentInput" placeholder="여기에 Markdown 본문 내용을 입력하세요..."></textarea>

        <hr>
        <label for="commitMessageInput">커밋 메시지 (자동 생성/편집 가능):</label>
        <input type="text" id="commitMessageInput" placeholder="자동 생성 또는 직접 입력">

        <button id="saveFileButton">저장 (생성/수정)</button>
        <button id="deleteFileButton" style="background-color: #dc3545;">삭제</button>
        <button id="cancelEditButton" style="background-color: #6c757d;">취소</button>
    </div>

    <!-- Status Bar -->
    <div id="statusBar">상태: 대기 중...</div>

</div>

<script type="module">
    // Import Octokit via CDN (esm.sh)
    import { Octokit } from "https://esm.sh/octokit";

    // --- Global Variables ---
    let octokit = null; // Octokit instance
    let githubToken = null; // Store token temporarily if needed, but rely on `octokit` instance
    let selectedOwner = null;
    let selectedRepo = null;
    let currentPath = ''; // Current browsing path
    let currentFiles = []; // Cache of files/dirs in current path
    let currentBranch = 'main'; // Default branch, consider making this configurable if needed

    // --- DOM Elements ---
    const patInput = document.getElementById('patInput');
    const loginButton = document.getElementById('loginButton');
    const repoSelect = document.getElementById('repoSelect');
    const loadRepoButton = document.getElementById('loadRepoButton');
    const fileListUl = document.querySelector('#fileList ul');
    const currentRepoSpan = document.getElementById('currentRepo');
    const currentPathBreadcrumb = document.getElementById('currentPathBreadcrumb');
    const fileNameInput = document.getElementById('fileNameInput');
    // Front Matter Inputs
    const fmTitleInput = document.getElementById('fmTitleInput');
    const fmAuthorInput = document.getElementById('fmAuthorInput');
    const fmDateInput = document.getElementById('fmDateInput');
    const fmDescriptionInput = document.getElementById('fmDescriptionInput');
    const fmTagsInput = document.getElementById('fmTagsInput');
    const fmCategoriesInput = document.getElementById('fmCategoriesInput');
    const fmTocCheckbox = document.getElementById('fmTocCheckbox');
    // ---
    const fileContentInput = document.getElementById('fileContentInput'); // Body content
    const commitMessageInput = document.getElementById('commitMessageInput');
    const currentFileShaInput = document.getElementById('currentFileSha'); // Stores blob SHA for update/delete
    const currentFilePathInput = document.getElementById('currentFilePathInput'); // Stores full path for update/delete/rename detection
    const saveFileButton = document.getElementById('saveFileButton');
    const deleteFileButton = document.getElementById('deleteFileButton');
    const cancelEditButton = document.getElementById('cancelEditButton');
    const createNewFileButton = document.getElementById('createNewFileButton');
    const statusBar = document.getElementById('statusBar');

    // --- Sections ---
    const loginSection = document.getElementById('loginSection');
    const repoSection = document.getElementById('repoSection');
    const fileBrowserSection = document.getElementById('fileBrowserSection');
    const editorSection = document.getElementById('editorSection');

    // --- Helper Functions ---

    /**
     * Updates the status bar message and style.
     * @param {string} message - The message to display.
     * @param {boolean} [isError=false] - True if the message is an error.
     * @param {boolean} [isSuccess=false] - True if the message is a success indicator.
     */
    function updateStatus(message, isError = false, isSuccess = false) {
        statusBar.textContent = `상태: ${message}`;
        statusBar.className = 'status-bar'; // Reset classes
        if (isError) {
            statusBar.classList.add('status-bar-error');
        } else if (isSuccess) {
            statusBar.classList.add('status-bar-success');
        }
        // Log to console for debugging
        console[isError ? 'error' : 'log'](`Status Update: ${message}`);
    }

    /**
     * Shows the specified section and hides others.
     * @param {HTMLElement | null} sectionToShow - The section element to show, or null to hide all.
     */
    function showSection(sectionToShow) {
        [loginSection, repoSection, fileBrowserSection, editorSection].forEach(section => {
            section.classList.add('hidden');
        });
        if (sectionToShow) {
            sectionToShow.classList.remove('hidden');
        }
    }

    /**
     * Encodes a string to Base64, supporting Unicode characters.
     * Required for GitHub API content parameter.
     * @param {string} str - The string to encode.
     * @returns {string} The Base64 encoded string.
     * @throws {Error} If encoding fails.
     */
    function b64EncodeUnicode(str) {
        try {
            // Use TextEncoder for robust UTF-8 encoding, then Base64 encode
            const bytes = new TextEncoder().encode(str);
            let binary = '';
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        } catch (e) {
             console.error("Base64 인코딩 실패:", e);
             updateStatus("Base64 인코딩 중 오류 발생.", true);
             throw new Error("Base64 인코딩 실패");
        }
    }

    /**
     * Decodes a Base64 string, supporting Unicode characters (UTF-8).
     * Required for reading GitHub API content response.
     * @param {string} str - The Base64 encoded string.
     * @returns {string} The decoded string.
     * @throws {Error} If decoding fails or results in invalid UTF-8.
     */
    function b64DecodeUnicode(str) {
        try {
            // Decode Base64
            const binary_string = atob(str);
            // Convert binary string to byte array
            const bytes = new Uint8Array(binary_string.length);
            for (let i = 0; i < binary_string.length; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            // Use TextDecoder for robust UTF-8 decoding
            // The 'fatal: true' option ensures an error is thrown for invalid UTF-8 sequences.
            return new TextDecoder('utf-8', { fatal: true }).decode(bytes);
        } catch (e) {
            console.error("Base64/UTF-8 디코딩 실패:", e);
            updateStatus('Base64 또는 UTF-8 디코딩 중 오류 발생. 파일 내용이 손상되었거나 UTF-8 인코딩이 아닐 수 있습니다.', true);
            // If TextDecoder fails (e.g., invalid UTF-8), re-throw the error.
            // Avoid falling back to potentially incorrect legacy methods.
            throw new Error("Base64/UTF-8 디코딩 실패: " + e.message);
        }
    }

    // --- Hugo Front Matter Parsing/Formatting ---
    // (Keeping the existing parser logic as it handles TOML specifics)

    /**
     * Parses Hugo TOML front matter and separates it from the body content.
     * @param {string} content - The full file content.
     * @returns {object} An object containing parsed front matter fields (title, author, date, etc.) and the body content.
     */
    function parseFrontMatter(content) {
        // Default structure
        const fm = {
            title: '', author: '', date: '', description: '',
            tags: [], categories: [], toc: undefined, // Use undefined for toc initially
            body: content // Default body is the whole content if no FM is found
        };
        // Regex to find TOML front matter block (+++ ... +++)
        const fmRegex = /^\+\+\+\s*([\s\S]*?)\s*\+\+\+([\s\S]*)/;
        const match = content.match(fmRegex);

        if (match && match[1] && match[2] !== undefined) {
            const frontMatterBlock = match[1].trim();
            fm.body = match[2].trimStart(); // Keep leading whitespace for body

            const lines = frontMatterBlock.split('\n');
            let currentKey = null;
            let accumulatingArrayContent = null; // For multi-line arrays

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();

                // --- Handle Multiline Array Accumulation ---
                if (accumulatingArrayContent !== null) {
                    accumulatingArrayContent += "\n" + line; // Append current line
                    if (line.includes(']')) { // Check if the array closes
                        try {
                            const startIndex = accumulatingArrayContent.indexOf('[');
                            const endIndex = accumulatingArrayContent.lastIndexOf(']');
                            if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                                let arrayString = accumulatingArrayContent.substring(startIndex + 1, endIndex).trim();
                                let values = [];
                                if (arrayString) {
                                    // Split by comma, trim, filter comments/empty, remove quotes
                                    values = arrayString.split(',')
                                        .map(item => item.trim())
                                        .filter(item => item && !item.startsWith('#'))
                                        .map(item => {
                                            if (item.startsWith('"') && item.endsWith('"')) return item.substring(1, item.length - 1).replace(/\\"/g, '"');
                                            if (item.startsWith("'") && item.endsWith("'")) return item.substring(1, item.length - 1).replace(/\\'/g, "'");
                                            return item;
                                        });
                                }
                                // Assign only to known array keys
                                if (currentKey === 'tags' || currentKey === 'categories') {
                                    fm[currentKey] = values;
                                } else {
                                     console.warn(`Parsed multiline array for unexpected key '${currentKey}'.`);
                                }
                            } else {
                                throw new Error("Could not find valid closing bracket ']' in accumulated array content.");
                            }
                        } catch (e) {
                            console.error(`Error parsing accumulated array for key ${currentKey}:`, accumulatingArrayContent, e);
                            updateStatus(`Front matter 배열 구문 분석 중 오류 발생 (${currentKey}): ${e.message}`, true);
                            // Default to empty array on error
                            if (currentKey && (currentKey === 'tags' || currentKey === 'categories')) fm[currentKey] = [];
                        } finally {
                            // Reset accumulation state
                            accumulatingArrayContent = null;
                            currentKey = null;
                        }
                    }
                // --- Handle Regular Lines (Key-Value or Start of Array) ---
                } else {
                    if (!trimmedLine || trimmedLine.startsWith('#')) {
                        continue; // Skip empty lines and comments
                    }

                    const eqIndex = trimmedLine.indexOf('=');
                    if (eqIndex > 0) {
                        const key = trimmedLine.substring(0, eqIndex).trim();
                        let valuePart = trimmedLine.substring(eqIndex + 1).trim();

                        // --- Handle Arrays (Single Line or Start of Multiline) ---
                        if ((key === 'tags' || key === 'categories') && valuePart.startsWith('[')) {
                             // Check if it closes on the same line
                             if (valuePart.includes(']') && valuePart.lastIndexOf(']') > valuePart.indexOf('[')) {
                                try {
                                    const startIndex = valuePart.indexOf('[');
                                    const endIndex = valuePart.lastIndexOf(']');
                                    let arrayString = valuePart.substring(startIndex + 1, endIndex).trim();
                                    let values = [];
                                    if (arrayString) {
                                        values = arrayString.split(',')
                                            .map(item => item.trim())
                                            .filter(item => item && !item.startsWith('#'))
                                            .map(item => {
                                                if (item.startsWith('"') && item.endsWith('"')) return item.substring(1, item.length - 1).replace(/\\"/g, '"');
                                                if (item.startsWith("'") && item.endsWith("'")) return item.substring(1, item.length - 1).replace(/\\'/g, "'");
                                                return item;
                                            });
                                    }
                                    fm[key] = values;
                                } catch(e) {
                                    console.error(`Error parsing single-line array for key ${key}:`, valuePart, e);
                                    updateStatus(`Front matter 배열 구문 분석 중 오류 발생 (${key}): ${e.message}`, true);
                                    fm[key] = []; // Default to empty on error
                                }
                            } else { // Start of a multiline array
                                currentKey = key;
                                accumulatingArrayContent = valuePart; // Start accumulating
                                // Edge case: Check if it closes immediately (e.g., 'tags = [', next line ']')
                                // This is handled by the accumulation logic at the start of the next iteration.
                            }
                        // --- Handle Simple Key-Value Pairs (String, Boolean, Date) ---
                        } else {
                            try {
                                let parsedValue = valuePart;
                                // Remove surrounding quotes (handle escaped quotes within)
                                if (parsedValue.startsWith('"') && parsedValue.endsWith('"')) {
                                    parsedValue = parsedValue.substring(1, parsedValue.length - 1).replace(/\\"/g, '"');
                                } else if (parsedValue.startsWith("'") && parsedValue.endsWith("'")) {
                                     parsedValue = parsedValue.substring(1, parsedValue.length - 1).replace(/\\'/g, "'");
                                // Handle TOML booleans
                                } else if (parsedValue === 'true') {
                                    parsedValue = true;
                                } else if (parsedValue === 'false') {
                                    parsedValue = false;
                                }
                                // Assign known keys
                                if (['title', 'author', 'date', 'description', 'toc'].includes(key)) {
                                     // Special handling for toc: only accept boolean true/false
                                     if (key === 'toc') {
                                         if (typeof parsedValue === 'boolean') {
                                            fm[key] = parsedValue;
                                         } else {
                                             console.warn(`Front matter parsing: Expected boolean for 'toc', got:`, parsedValue, "- Ignoring.");
                                             // Do not assign fm.toc if it's not a valid boolean
                                         }
                                     } else {
                                        fm[key] = String(parsedValue); // Treat others as strings (dates are strings in TOML)
                                     }
                                } else {
                                    // Log unknown keys for debugging if needed
                                    // console.log(`Unknown front matter key found: ${key}`);
                                }
                            } catch (parseError) {
                                 console.error(`Error parsing simple front matter line: "${line}"`, parseError);
                                 updateStatus(`Front matter 구문 분석 중 오류 발생: ${line}`, true);
                            }
                        }
                    } else {
                        // Line does not contain '=', might be part of a multiline string (not explicitly handled here) or invalid TOML
                        console.warn(`Invalid front matter line (no '=' found, not inside array): "${trimmedLine}"`);
                    }
                }
            } // End for loop over lines

            // Check if we ended while still accumulating an array (unclosed)
            if (accumulatingArrayContent !== null) {
                console.error(`Front matter parsing ended while inside an unclosed array for key: ${currentKey}`);
                updateStatus(`Front matter 오류: ${currentKey} 배열이 닫히지 않았습니다. 해당 필드는 비어있을 수 있습니다.`, true);
                if (currentKey && (currentKey === 'tags' || currentKey === 'categories')) {
                     fm[currentKey] = []; // Default to empty
                }
            }
        } // End if (match)

        // If 'toc' was never assigned (not found or invalid value), fm.toc remains undefined.
        // The formatting logic and checkbox will handle 'undefined' appropriately (treat as false/omit).
        return fm;
    }

    /**
     * Formats the front matter data object back into a TOML string.
     * @param {object} fmData - The front matter data object.
     * @returns {string} The formatted TOML front matter string.
     */
    function formatFrontMatter(fmData) {
        let fmString = '+++\n';
        // Helper to ensure strings are properly quoted and escaped for TOML
        const formatTomlString = (str) => `"${String(str).replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
        // Helper to format arrays of strings
        const formatTomlArray = (arr) => `[${arr.map(formatTomlString).join(', ')}]`;

        // Order matters somewhat for readability
        if (fmData.title) fmString += `title = ${formatTomlString(fmData.title)}\n`;
        if (fmData.date) fmString += `date = ${formatTomlString(fmData.date)}\n`; // Dates are represented as strings in TOML
        if (fmData.author) fmString += `author = ${formatTomlString(fmData.author)}\n`;
        if (fmData.description) fmString += `description = ${formatTomlString(fmData.description)}\n`;
        if (fmData.categories && fmData.categories.length > 0) fmString += `categories = ${formatTomlArray(fmData.categories)}\n`;
        if (fmData.tags && fmData.tags.length > 0) fmString += `tags = ${formatTomlArray(fmData.tags)}\n`;

        // Add toc = true ONLY if the checkbox was checked (fmData.toc is true).
        // Omit the line if fmData.toc is false or undefined (Hugo typically defaults to false).
        if (fmData.toc === true) {
             fmString += `toc = true\n`;
        }
        // Optionally, explicitly add toc = false if desired when checkbox is unchecked
        // else if (fmData.toc === false) {
        //     fmString += `toc = false\n`;
        // }

        fmString += '+++\n\n'; // Closing delimiter and ensure two newlines before body content
        return fmString;
    }


    /**
     * Generates a Hugo-friendly filename from a title string.
     * Converts to lowercase, replaces spaces with hyphens, removes invalid characters.
     * @param {string} title - The input title.
     * @returns {string} The generated filename with .md extension.
     */
    function generateHugoFilename(title) {
        if (!title || !title.trim()) {
            return 'untitled.md';
        }
        // Keep Hangul, alphanumeric, hyphens, underscores. Remove others.
        const cleanedTitle = title
            .trim()
            .toLowerCase()
            // Remove specific punctuation and symbols not ideal for URLs/filenames
            .replace(/[\\/:\?\*"<>\|#;\$'\{\}\+=~@%^&\(\)\[\]\.!,]/g, '') // Added '!' and '.' removal
            // Replace whitespace (including multiple spaces) with a single hyphen
            .replace(/\s+/g, '-')
            // Remove leading/trailing hyphens
            .replace(/^-+|-+$/g, '');

        // Ensure there's some name left, otherwise default
        return (cleanedTitle || 'untitled') + '.md';
    }

    /**
     * Updates the commit message input field based on the current filename and whether it's an update or create operation.
     */
    function updateCommitMessage() {
        const filename = fileNameInput.value.trim();
        const isUpdate = !!currentFileShaInput.value; // Check if SHA exists (indicates update)

        if (filename) {
             // Use a slightly more descriptive default message
             commitMessageInput.value = isUpdate ? `Update content for ${filename}` : `Create ${filename}`;
             commitMessageInput.placeholder = `예: ${commitMessageInput.value}`; // Show example in placeholder
        } else {
             commitMessageInput.value = ''; // Clear if filename is empty
             commitMessageInput.placeholder = '자동 생성 또는 직접 입력';
        }
    }

    /**
     * Generates and updates the breadcrumb navigation based on the current path.
     */
    function updateBreadcrumb() {
        currentPathBreadcrumb.innerHTML = ''; // Clear existing
        const rootLink = document.createElement('a');
        rootLink.href = '#';
        rootLink.textContent = 'root';
        rootLink.onclick = (e) => { e.preventDefault(); fetchContents(''); };
        currentPathBreadcrumb.appendChild(rootLink);

        const pathParts = currentPath.split('/').filter(p => p); // Filter empty parts
        let accumulatedPath = '';
        pathParts.forEach((part, index) => {
            accumulatedPath += (index > 0 ? '/' : '') + part; // Build path progressively
            const pathSeparator = document.createElement('span');
            pathSeparator.textContent = ' / ';
            currentPathBreadcrumb.appendChild(pathSeparator);

            const partLink = document.createElement('a');
            partLink.href = '#';
            partLink.textContent = part;
            // Capture the path for the closure correctly
            const currentAccumulatedPath = accumulatedPath;
            partLink.onclick = (e) => { e.preventDefault(); fetchContents(currentAccumulatedPath); };
            currentPathBreadcrumb.appendChild(partLink);
        });
         // If path is not empty, add the final non-clickable part
         if (pathParts.length > 0) {
            const pathSeparator = document.createElement('span');
            pathSeparator.textContent = ' / ';
            currentPathBreadcrumb.appendChild(pathSeparator);
            const currentPartStrong = document.createElement('strong');
            currentPartStrong.textContent = pathParts[pathParts.length - 1];
            currentPathBreadcrumb.appendChild(currentPartStrong);
         } else {
            // If at root, make 'root' bold
            rootLink.outerHTML = '<strong>root</strong>'; // Replace the link with bold text
         }
    }

    /**
     * Adds a '..' (Parent Directory) link to the top of the file list if not at the root.
     * @param {string} currentPath - The current directory path.
     */
    function addParentDirectoryLink(currentPath) {
        // Only add if not at the root
         if (currentPath && currentPath !== '') {
             const parentPath = currentPath.includes('/') ? currentPath.substring(0, currentPath.lastIndexOf('/')) : '';
             const li = document.createElement('li');
             li.innerHTML = '<strong>⬆️ .. (상위 폴더)</strong>';
             li.style.cursor = 'pointer';
             li.title = `상위 폴더로 이동: /${parentPath}`;
             li.onclick = () => fetchContents(parentPath);
             // Add to the beginning of the list
             if (fileListUl.firstChild) {
                 fileListUl.insertBefore(li, fileListUl.firstChild);
             } else {
                 fileListUl.appendChild(li);
             }
         }
    }

    /**
     * Clears all fields in the editor form and resets related state.
     */
     function clearEditorFields() {
        fileNameInput.value = '';
        fmTitleInput.value = '';
        fmAuthorInput.value = '';
        fmDateInput.value = '';
        fmDescriptionInput.value = '';
        fmTagsInput.value = '';
        fmCategoriesInput.value = '';
        fmTocCheckbox.checked = false; // Default to unchecked
        fileContentInput.value = '';
        commitMessageInput.value = '';
        commitMessageInput.placeholder = '자동 생성 또는 직접 입력';
        currentFileShaInput.value = ''; // Clear SHA
        currentFilePathInput.value = ''; // Clear path

        // Reset button states
        saveFileButton.disabled = true;
        saveFileButton.textContent = '저장 (생성/수정)';
        deleteFileButton.disabled = true;
        cancelEditButton.disabled = true; // Should be enabled when editor is shown
    }


    // --- Event Handlers ---

    /**
     * Handles the Login button click.
     * Initializes Octokit, validates the PAT by fetching user info, and loads repositories.
     */
    loginButton.addEventListener('click', async () => {
        githubToken = patInput.value.trim();
        if (!githubToken) {
            updateStatus('오류: GitHub Personal Access Token (PAT)를 입력해주세요.', true);
            patInput.focus();
            return;
        }

        // Disable form during login attempt
        patInput.disabled = true;
        loginButton.disabled = true;
        loginButton.textContent = '로딩 중...';
        updateStatus('GitHub 인증 및 저장소 목록 로딩 중...');

        try {
            // Initialize Octokit instance
            octokit = new Octokit({
                auth: githubToken,
                // Optional: Set a custom User-Agent
                // userAgent: 'hugo-octokit-editor/v1.0',
            });

            // 1. Validate PAT by fetching authenticated user data
            // If this fails (e.g., 401), the catch block will handle it.
            const { data: user } = await octokit.rest.users.getAuthenticated();
            console.log("Authenticated as user:", user.login); // Useful for debugging

            // 2. Fetch repositories accessible by the user
            // Use pagination to handle potentially large numbers of repositories.
            const repos = await octokit.paginate(octokit.rest.repos.listForAuthenticatedUser, {
                 // type: 'owner', // Options: 'all', 'owner', 'member' - 'owner' might be too restrictive
                 affiliation: 'owner,collaborator', // Get repos owned or collaborated on
                 per_page: 100, // Max allowed per page
                 sort: 'updated', // Sort by most recently updated
            });

            // Populate the repository dropdown
            repoSelect.innerHTML = '<option value="">-- 저장소 선택 --</option>'; // Reset dropdown with placeholder

            if (repos && repos.length > 0) {
                 repos.forEach(repo => {
                    const option = document.createElement('option');
                    option.value = `${repo.owner.login}/${repo.name}`; // Use full_name format
                    option.textContent = `${repo.full_name} (${repo.private ? 'Private' : 'Public'})`;
                    repoSelect.appendChild(option);
                });
                repoSelect.selectedIndex = 0; // Ensure placeholder is selected
                loadRepoButton.disabled = true; // Disable load button until selection
                updateStatus(`${repos.length}개의 저장소 로드 완료. 목록에서 선택하세요.`, false, true);
                showSection(repoSection); // Show repository selection section
                // Keep login section elements disabled as login was successful
            } else {
                updateStatus('접근 가능한 저장소가 없거나 로드에 실패했습니다. PAT 권한(repo) 또는 저장소 유무를 확인하세요.', true);
                showSection(loginSection); // Stay on login section
                // Re-enable login only if repo list is empty, maybe token is valid but no repos?
                patInput.disabled = false;
                loginButton.disabled = false;
                loginButton.textContent = '저장소 목록 불러오기';
                octokit = null; // Reset octokit as there's nothing to do
            }
        } catch (error) {
             console.error("Login/Repo Fetch Error:", error);
             let errorMsg = `저장소 목록 로딩 실패: ${error.message}`;
             // Provide more specific feedback based on HTTP status
             if (error.status === 401) {
                 errorMsg = `GitHub API 인증 오류 (401): PAT가 유효하지 않거나 필요한 'repo' 권한이 없습니다.`;
                 octokit = null; // Invalidate Octokit instance on auth failure
             } else if (error.status === 403) {
                 // Could be rate limiting, SSO restrictions, IP allow lists, etc.
                 errorMsg = `GitHub API 권한 오류 (403): API 속도 제한, SSO, IP 제한 등의 문제일 수 있습니다. (${error.message})`;
                 // Don't necessarily nullify octokit here, might be temporary
             } else {
                 // General network or other API error
                 errorMsg = `GitHub API 통신 오류 (${error.status || 'N/A'}): ${error.message}`;
             }
             updateStatus(errorMsg, true);
             showSection(loginSection); // Go back to login section on error
             // Reset login form elements only if Octokit failed completely or auth failed
            if (!octokit || error?.status === 401) {
                 patInput.disabled = false;
                 loginButton.disabled = false;
                 loginButton.textContent = '저장소 목록 불러오기';
            } else {
                // If octokit might still be valid (e.g., 403), keep login disabled, but reset button text
                loginButton.textContent = '저장소 목록 불러오기';
            }
        }
        // No finally block needed here as state is handled within try/catch
    });

    /**
     * Handles the Repository selection change.
     * Enables the 'Load Repository' button if a valid repository is selected.
     */
    repoSelect.addEventListener('change', () => {
        loadRepoButton.disabled = repoSelect.value === '';
    });

    /**
     * Handles the 'Load Repository' button click.
     * Sets the selected repository and owner, then fetches the root directory contents.
     */
    loadRepoButton.addEventListener('click', () => {
        const selectedRepoFullName = repoSelect.value;
        if (!selectedRepoFullName || !selectedRepoFullName.includes('/')) {
            updateStatus("오류: 유효하지 않은 저장소 형식입니다.", true);
            return;
        };

        [selectedOwner, selectedRepo] = selectedRepoFullName.split('/');
        currentRepoSpan.textContent = selectedRepoFullName;
        updateStatus(`'${selectedRepoFullName}' 저장소 로딩 중...`);

        // Disable repo selection while loading files
        repoSelect.disabled = true;
        loadRepoButton.disabled = true;

        showSection(fileBrowserSection);
        fetchContents(''); // Fetch root ('') contents
    });

    /**
     * Fetches the contents (files and directories) of a given path within the selected repository.
     * @param {string} path - The directory path to fetch. Use '' for the root.
     */
    async function fetchContents(path) {
        if (!octokit || !selectedOwner || !selectedRepo) {
             updateStatus("오류: Octokit이 초기화되지 않았거나 저장소가 선택되지 않았습니다. 로그인부터 다시 시도하세요.", true);
             // Force back to login if state is invalid
             showSection(loginSection);
             patInput.disabled = false; loginButton.disabled = false; octokit = null;
             return;
        }

        currentPath = path; // Update global current path
        updateBreadcrumb(); // Update navigation breadcrumb
        fileListUl.innerHTML = '<li><em><center>로딩 중...</center></em></li>'; // Show loading indicator
        showSection(fileBrowserSection); // Ensure browser is visible
        editorSection.classList.add('hidden'); // Hide editor when browsing
        createNewFileButton.disabled = true; // Disable 'New File' while loading
        updateStatus(`'${selectedOwner}/${selectedRepo}/${path || 'root'}' 로딩 중...`);

        try {
            // Use octokit.rest.repos.getContent to list directory contents
            const { data: contents } = await octokit.rest.repos.getContent({
                owner: selectedOwner,
                repo: selectedRepo,
                path: path,
                ref: currentBranch, // Specify the branch
                 // Add a cache-busting parameter (optional, but can help with stale data)
                 // GitHub's API caching can be aggressive. This is not foolproof.
                 // _: Date.now() // Using underscore as a common cache buster param name
            });

            // The API returns an object for a single file path, ensure we always work with an array
            const contentList = Array.isArray(contents) ? contents : [contents];

            // Filter out non-file/dir types (like submodules, symlinks) and sort (dirs first, then files alphabetically)
            currentFiles = contentList
                .filter(item => item.type === 'file' || item.type === 'dir')
                .sort((a, b) => {
                    // Sort directories first, then files
                    if (a.type !== b.type) {
                        return a.type === 'dir' ? -1 : 1;
                    }
                    // Sort alphabetically within type (case-insensitive, Korean-aware)
                    return a.name.localeCompare(b.name, 'ko', { sensitivity: 'base' });
                });

            fileListUl.innerHTML = ''; // Clear loading message or previous content

            // Add '..' (Parent Directory) link if not at the root
            addParentDirectoryLink(path);

            // Populate the file list UL
            if (currentFiles.length > 0) {
                currentFiles.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item.name;
                    li.classList.add(item.type); // Add 'file' or 'dir' class for styling
                    li.dataset.path = item.path;
                    li.dataset.type = item.type;
                    li.dataset.sha = item.sha; // Store SHA (useful for file blobs, tree SHA for dirs)

                    if (item.type === 'dir') {
                        li.onclick = () => fetchContents(item.path);
                        li.title = `폴더 열기: ${item.path}`;
                    } else if (item.type === 'file') {
                        // Only allow editing of Markdown files for this Hugo editor
                        const isEditable = /\.md$/i.test(item.name);
                        if (isEditable) {
                             li.title = `파일 수정: ${item.path}`;
                             // Pass the file's path and blob SHA to the fetch function
                             li.onclick = () => fetchFileContent(item.path, item.sha);
                        } else {
                             // Indicate non-editable files visually
                             li.style.cursor = 'default';
                             li.style.color = '#888'; // Grey out text
                             li.title = `Hugo .md 파일만 편집 가능 (${item.name})`;
                             li.onclick = (e) => e.stopPropagation(); // Prevent action if clicked
                        }
                    }
                    fileListUl.appendChild(li);
                });
             } else {
                 // Handle empty directory case
                 const li = document.createElement('li');
                 li.textContent = path === '' ? '(저장소 루트가 비어 있습니다)' : '(폴더가 비어 있습니다)';
                 li.style.fontStyle = 'italic';
                 li.style.color = '#888';
                 li.style.cursor = 'default';
                 fileListUl.appendChild(li);
             }

             updateStatus(`'${selectedOwner}/${selectedRepo}/${path || 'root'}' 로드 완료.`, false, true);

        } catch (error) {
             console.error("Fetch Contents Error:", error);
             let errorMsg = `폴더 내용 로드 실패: ${error.message}`;
              if (error.status === 404) {
                  errorMsg = `경로 '${path || 'root'}'를 찾을 수 없습니다 (404). 저장소, 브랜치(${currentBranch}) 또는 경로를 확인하세요.`;
              } else if (error.status === 403) {
                  errorMsg = `저장소 접근 권한 오류 (403). PAT 권한이나 API 제한을 확인하세요.`;
              } else if (error.status === 401) {
                  errorMsg = `GitHub API 인증 오류 (401): PAT가 만료되었거나 유효하지 않습니다.`;
                  // Force re-login on critical auth error
                  octokit = null;
                  showSection(loginSection);
                  patInput.disabled = false; loginButton.disabled = false;
                  repoSelect.disabled = false; loadRepoButton.disabled = true;
                  return; // Exit function early
              }
             updateStatus(errorMsg, true);
             // Display error in the list area
             fileListUl.innerHTML = `<li class="error" style="cursor: default; background-color: #f8d7da; color: #721c24; padding: 10px;">오류: 폴더 내용을 불러올 수 없습니다. (${error.message})</li>`;
             // Still try to add parent link if possible on error
             addParentDirectoryLink(path);
        } finally {
             // Re-enable 'New File' button and repo controls after loading attempt (success or fail)
             createNewFileButton.disabled = false;
             repoSelect.disabled = false;
             loadRepoButton.disabled = repoSelect.value === '';
        }
    }


    /**
     * Fetches the content of a specific file using its blob SHA.
     * Populates the editor fields with the parsed front matter and body.
     * @param {string} filePath - The full path of the file in the repository.
     * @param {string} fileSha - The blob SHA of the file content.
     */
    async function fetchFileContent(filePath, fileSha) {
        if (!octokit || !selectedOwner || !selectedRepo) {
             updateStatus("오류: Octokit이 초기화되지 않았거나 저장소가 선택되지 않았습니다.", true);
             return;
        }
        updateStatus(`'${filePath}' 파일 내용 로딩 중...`);
        // Disable UI elements during fetch
        createNewFileButton.disabled = true;
        fileListUl.style.pointerEvents = 'none'; // Prevent clicking other files
        clearEditorFields(); // Clear editor before loading new content
        showSection(null); // Hide all sections briefly while loading

        try {
            // Use octokit.rest.git.getBlob - preferred for getting raw file content using blob SHA
            const { data: blobData } = await octokit.rest.git.getBlob({
                owner: selectedOwner,
                repo: selectedRepo,
                file_sha: fileSha // Use the blob SHA provided
            });

            // Validate the response structure
            if (!blobData || typeof blobData.content === 'undefined' || blobData.encoding !== 'base64' || !blobData.sha) {
                 throw new Error('API 응답 형식이 잘못되었습니다 (Blob). Content, SHA, 또는 Encoding 누락.');
            }

            // Check for potential truncation (GitHub blob API limit is 1MB for direct content)
            // The 'size' property gives the total size in bytes.
            const sizeLimit = 1 * 1024 * 1024; // 1 MB
            if (blobData.size > sizeLimit) {
                 updateStatus(`경고: 파일 크기(${ (blobData.size / 1024 / 1024).toFixed(2)} MB)가 1MB를 초과합니다. 내용이 잘리거나 편집/저장 시 문제가 발생할 수 있습니다.`, true); // Use error style for visibility
            }

            // Decode the Base64 content (will throw error if decoding or UTF-8 conversion fails)
            const decodedContent = b64DecodeUnicode(blobData.content);

            // Parse the decoded content into front matter and body
            const parsedData = parseFrontMatter(decodedContent);

            // --- Populate Editor Fields ---
            fileNameInput.value = filePath.substring(filePath.lastIndexOf('/') + 1);
            // Populate Front Matter
            fmTitleInput.value = parsedData.title || '';
            fmAuthorInput.value = parsedData.author || '';
            fmDateInput.value = parsedData.date || '';
            fmDescriptionInput.value = parsedData.description || '';
            fmTagsInput.value = (parsedData.tags || []).join(', '); // Join array back to comma-separated string
            fmCategoriesInput.value = (parsedData.categories || []).join(', ');
            // Handle 'toc' checkbox: checked if true, unchecked otherwise (false or undefined)
            fmTocCheckbox.checked = (parsedData.toc === true);
            // Populate Body Content
            fileContentInput.value = parsedData.body || '';

            // --- Store State for Saving/Deleting ---
            // Use the blob SHA returned by getBlob, which is the SHA of the content itself.
            // This SHA is required for updates and deletes.
            currentFileShaInput.value = blobData.sha;
            currentFilePathInput.value = filePath; // Store the full path of the file being edited

            // --- Update UI State ---
            saveFileButton.textContent = '저장 (수정)';
            saveFileButton.disabled = false;
            deleteFileButton.disabled = false; // Enable delete for existing files
            cancelEditButton.disabled = false; // Enable cancel

            updateCommitMessage(); // Generate default commit message for update

            updateStatus(`'${filePath}' 로드 완료. 편집 가능.`, false, true);
            showSection(editorSection); // Show the populated editor

        } catch (error) {
            console.error("Fetch File Content Error:", error);
            let errorMsg = `파일 내용 로딩 실패 (${filePath}): ${error.message}`;
             if (error.status === 404) {
                 errorMsg = `파일 Blob (SHA: ${fileSha})을(를) 찾을 수 없습니다 (404). 파일이 이동, 삭제 또는 변경되었을 수 있습니다.`;
             } else if (error.status === 403) {
                 errorMsg = `파일 접근 권한 오류 (403).`;
             } else if (error.status === 422) { // Unprocessable Entity, e.g., bad SHA format?
                 errorMsg = `잘못된 요청 (422): SHA 형식이 잘못되었거나 유효하지 않을 수 있습니다. (${error.message})`;
             } else if (error.message.includes('Base64') || error.message.includes('UTF-8')) {
                // Error already logged by b64DecodeUnicode, just show the status.
                errorMsg = `파일 디코딩 실패: ${error.message}`; // Status already updated, but log again.
             } else if (error.message.includes('Blob is too big')) {
                 // Catch explicit "too big" errors if the API returns them
                 errorMsg = `파일이 너무 큽니다 (${filePath}). GitHub API가 내용을 반환하지 못했습니다.`;
             } else if (error.status === 401) {
                  errorMsg = `GitHub API 인증 오류 (401): PAT가 만료되었거나 유효하지 않습니다.`;
                  octokit = null; showSection(loginSection); patInput.disabled = false; loginButton.disabled = false;
                  return; // Exit early
             }
            updateStatus(errorMsg, true);
            showSection(fileBrowserSection); // Go back to browser on error
        } finally {
            // Re-enable file browser interactions regardless of success/failure
            createNewFileButton.disabled = false;
            fileListUl.style.pointerEvents = 'auto';
        }
    }

    /**
     * Handles the 'Create New File' button click.
     * Clears the editor, sets a default date, and prepares the form for creating a new file.
     */
    createNewFileButton.addEventListener('click', () => {
        clearEditorFields(); // Clear fields first

        // Pre-fill date with current local time in ISO 8601 format with timezone offset
        try {
            const now = new Date();
            const offsetMinutes = now.getTimezoneOffset();
            const offsetHours = Math.abs(offsetMinutes / 60);
            const offsetSign = offsetMinutes <= 0 ? '+' : '-'; // Note: getTimezoneOffset is positive for west of UTC
            const timezoneString = `${offsetSign}${String(Math.floor(offsetHours)).padStart(2, '0')}:${String(Math.abs(offsetMinutes % 60)).padStart(2, '0')}`;

            // Create a new date object shifted by the offset to get the correct local time parts
            // Or simply use toISOString() and slice/format if UTC 'Z' is acceptable.
            // Let's create the full ISO string with local offset:
            const pad = (num, width = 2) => String(num).padStart(width, '0');
            const localISOString = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}T${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}${timezoneString}`;
            fmDateInput.value = localISOString;
        } catch (e) {
             console.error("Error generating default date:", e);
             fmDateInput.placeholder = "오류 발생, 직접 입력: YYYY-MM-DDTHH:MM:SSZ";
        }


        // Update state for a "new file" scenario
        currentFileShaInput.value = ''; // Ensure SHA is empty
        currentFilePathInput.value = ''; // Ensure path is empty
        deleteFileButton.disabled = true; // Cannot delete a new, unsaved file
        saveFileButton.textContent = '저장 (생성)';
        // Enable save/cancel. Validation will enforce required fields later.
        saveFileButton.disabled = false;
        cancelEditButton.disabled = false;

        updateCommitMessage(); // Generate initial (empty) commit message

        updateStatus('새 파일 생성 준비 완료. Title을 입력하면 파일명과 커밋 메시지가 자동 생성됩니다.');
        showSection(editorSection);
        fmTitleInput.focus(); // Focus on Title field first
    });


    /**
     * Handles the Save button click (for both creating new files and updating existing ones).
     * Performs validation, formats content, handles potential renames, and calls the GitHub API.
     */
    saveFileButton.addEventListener('click', async () => {
        if (!octokit || !selectedOwner || !selectedRepo) {
             updateStatus("오류: Octokit이 초기화되지 않았거나 저장소가 선택되지 않았습니다.", true);
             return;
        }

        // --- Read data from form ---
        let fileName = fileNameInput.value.trim();
        const fileBodyContent = fileContentInput.value; // Keep raw body content
        let commitMessage = commitMessageInput.value.trim();
        const existingBlobSha = currentFileShaInput.value; // SHA of the blob being edited (if updating)
        const originalFullPath = currentFilePathInput.value; // Full path of the file being edited (if updating)
        const isUpdateOperation = !!existingBlobSha && !!originalFullPath; // True if we started by editing an existing file

        // --- Input Validation ---
        const titleValue = fmTitleInput.value.trim();
        if (!titleValue) {
             updateStatus("오류: Front Matter 'Title'은 필수 항목입니다.", true);
             fmTitleInput.focus(); return;
        }
        if (!fileName) {
            // Try generating from title again if empty
            fileName = generateHugoFilename(titleValue);
            fileNameInput.value = fileName;
            if (!fileName || fileName === '.md') { // Check if generation failed
                 updateStatus('오류: 파일 이름을 입력하거나 유효한 Title을 입력해주세요.', true);
                 fileNameInput.focus(); return;
            }
        }
        if (fileName.includes('/')) {
             updateStatus("오류: 파일 이름에는 슬래시('/')를 포함할 수 없습니다. 경로는 탐색기에서 선택된 폴더 위치로 결정됩니다.", true);
             fileNameInput.focus(); return;
        }
        if (!fileName.toLowerCase().endsWith('.md')) {
              // Auto-correct by appending '.md'
              fileName += '.md';
              fileNameInput.value = fileName; // Update the input field visually
              updateStatus("경고: 파일 확장자가 .md가 아니므로 '.md'를 추가했습니다.", false); // Use neutral status
         }
         const dateValue = fmDateInput.value.trim();
         if (!dateValue) {
             updateStatus("오류: Front Matter 'Date'는 필수 항목입니다.", true);
             fmDateInput.focus(); return;
         }
         // Stricter regex for ISO 8601 Date format (YYYY-MM-DDTHH:MM:SS followed by Z or +/-HH:MM offset)
         if (!/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2})$/i.test(dateValue)) {
              updateStatus("오류: 'Date' 형식이 올바르지 않습니다 (YYYY-MM-DDTHH:MM:SSZ 또는 YYYY-MM-DDTHH:MM:SS+/-HH:MM 권장).", true);
              fmDateInput.focus(); return;
         }
         // Regenerate commit message if empty or still default, *before* final check
         const defaultCreateMsg = `Create ${fileName}`;
         const defaultUpdateMsg = `Update content for ${fileName}`;
         if (!commitMessage || commitMessage === defaultCreateMsg || commitMessage === defaultUpdateMsg) {
             updateCommitMessage(); // Ensure it's up-to-date based on current filename/operation type
             commitMessage = commitMessageInput.value.trim(); // Re-read
         }
         if (!commitMessage) {
             // If still empty after trying to update, prompt user
             updateStatus("오류: 커밋 메시지를 입력해주세요.", true);
             commitMessageInput.focus(); return;
         }
        // --- End Validation ---

        // Construct Front Matter Data Object from inputs
        const fmData = {
            title: titleValue,
            author: fmAuthorInput.value.trim(),
            date: dateValue,
            description: fmDescriptionInput.value.trim(),
            tags: fmTagsInput.value.split(',').map(t => t.trim()).filter(t => t), // Split, trim, filter empty
            categories: fmCategoriesInput.value.split(',').map(c => c.trim()).filter(c => c),
            toc: fmTocCheckbox.checked // Pass the boolean state directly
        };

        // Format the complete file content (Front Matter + Body)
        let finalContent;
        try {
            const frontMatterString = formatFrontMatter(fmData);
            finalContent = frontMatterString + fileBodyContent; // Combine FM + Body
        } catch (formatError) {
             updateStatus(`Front Matter 생성 오류: ${formatError.message}`, true);
             return;
        }

        // Determine the target path for saving the file
        const targetBasePath = currentPath ? currentPath + '/' : ''; // Base path from the file browser's current location
        const targetFullPath = targetBasePath + fileName; // The final path for the create/update operation

        // *** Handle Potential Rename ***
        // A rename occurs if:
        // 1. It's an update operation (we started by editing an existing file).
        // 2. The target path (based on currentPath + fileNameInput) is DIFFERENT from the original file path.
        const isRename = isUpdateOperation && (targetFullPath !== originalFullPath);

        if (isRename) {
             // Explain the situation clearly: GitHub API creates a new file, doesn't move/rename atomically.
             if (!confirm(`파일 이름 또는 경로가 변경되었습니다.\n\n기존 파일: '${originalFullPath}'\n새 파일 경로: '${targetFullPath}'\n\nGitHub API는 직접적인 이름 변경/이동을 지원하지 않습니다. 이 작업은 새 경로에 파일을 **생성**합니다.\n\n⚠️ 경고: 기존 파일 ('${originalFullPath}')은 자동으로 삭제되지 않습니다! 저장 후 필요하다면 직접 삭제해야 합니다.\n\n계속 진행하여 새 위치에 파일을 생성하시겠습니까?`)) {
                 updateStatus("이름 변경/이동 작업 취소됨.", false);
                 return; // Stop the save operation
             }
             // If user confirms, adjust commit message for clarity if using default
             const oldFilenameOnly = originalFullPath.substring(originalFullPath.lastIndexOf('/') + 1);
             const defaultRenameCommit = `Create ${fileName} (from ${oldFilenameOnly})`;
             if (commitMessage === `Update content for ${oldFilenameOnly}`) { // Check against old default update message
                 commitMessageInput.value = defaultRenameCommit;
                 commitMessage = defaultRenameCommit; // Use the new message
             }
             updateStatus("이름 변경 확인됨. 새 경로에 파일을 생성합니다...", false);
        }

        updateStatus(`'${targetFullPath}' 저장 중...`);
        // Disable all editor buttons during API call
        saveFileButton.disabled = true;
        cancelEditButton.disabled = true;
        deleteFileButton.disabled = true;

        // Encode the final content to Base64
        let encodedContent;
        try {
            encodedContent = b64EncodeUnicode(finalContent);
        } catch(encodeError) {
            updateStatus(`파일 내용 인코딩 실패: ${encodeError.message}`, true);
            saveFileButton.disabled = false; // Re-enable buttons on early failure
            cancelEditButton.disabled = false;
            // Re-enable delete only if it was an update attempt (not rename)
            deleteFileButton.disabled = !(isUpdateOperation && !isRename);
            return;
        }

        try {
            // Prepare parameters for Octokit's createOrUpdateFileContents method
            const params = {
                owner: selectedOwner,
                repo: selectedRepo,
                path: targetFullPath, // The path where the file should be created or updated
                message: commitMessage, // The commit message
                content: encodedContent, // The Base64 encoded content
                branch: currentBranch // The target branch
            };

            // *** Crucial: Add the blob SHA *only* if updating an existing file at the *same* path ***
            // - If it's a create operation (isUpdateOperation = false), omit SHA.
            // - If it's a rename operation (isRename = true), omit SHA (because we're creating at a new path).
            // - Only include SHA if updating the file at its original path (isUpdateOperation = true AND isRename = false).
            if (isUpdateOperation && !isRename) {
                params.sha = existingBlobSha; // Provide the SHA of the blob being replaced
            }

            // Call the GitHub API
            const { data: result } = await octokit.rest.repos.createOrUpdateFileContents(params);

            // Determine action type for status message
            const action = isUpdateOperation ? (isRename ? '이름 변경으로 생성' : '수정') : '생성';
            updateStatus(`'${targetFullPath}' ${action} 완료. 새 SHA: ${result?.content?.sha}`, false, true); // Success

            // Clear editor and return to the file browser
            clearEditorFields();
            showSection(fileBrowserSection);
            // Refresh file list in the directory where the file was saved/created
            // Use targetBasePath which corresponds to the directory view needed
            fetchContents(targetBasePath.endsWith('/') ? targetBasePath.slice(0, -1) : targetBasePath);

            // If it was a rename, remind the user again to delete the old file
            if (isRename) {
                 alert(`파일 '${targetFullPath}'이(가) 성공적으로 생성되었습니다.\n\n알림: 기존 파일 '${originalFullPath}'은(는) 삭제되지 않았습니다. 더 이상 필요하지 않다면 수동으로 삭제해주세요.`);
            }

        } catch (error) {
            console.error("Save File Error:", error);
            let errorMsg = `파일 저장 실패 (${targetFullPath}): ${error.message}`;
            if (error.status === 409) { // Conflict - SHA mismatch (file changed on server) or branch out of date
                errorMsg = `파일 저장 충돌 (409): 파일이 서버에서 변경되었거나 브랜치가 최신 상태가 아닐 수 있습니다. 페이지를 새로고침하고 다시 시도하세요.`;
            } else if (error.status === 422) { // Unprocessable Entity - Validation error on GitHub's side (e.g., empty file, bad path)
                errorMsg = `잘못된 데이터 또는 요청 (422): ${error.message}. `;
                // Try to get more specific details from the response if available
                if (error.response?.data?.message) {
                     errorMsg += `GitHub 메시지: ${error.response.data.message}`;
                }
                if (error.response?.data?.errors) {
                     try { // Safely access nested errors
                       errorMsg += ` 세부 정보: ${JSON.stringify(error.response.data.errors)}`;
                     } catch (jsonError) { /* Ignore if cannot stringify */ }
                 }
            } else if (error.status === 404 && isUpdateOperation && !isRename) {
                 // Trying to update a file (with correct path) but the provided SHA is not found
                 errorMsg = `파일 수정 실패 (404): 원본 파일(SHA: ${existingBlobSha})을 찾을 수 없거나 SHA가 일치하지 않습니다. 파일이 삭제되었거나 다른 변경사항과 충돌했을 수 있습니다. 새로고침 후 다시 시도하세요.`;
            } else if (error.status === 403) {
                  errorMsg = `파일 저장 권한 오류 (403): 이 저장소 또는 경로에 파일을 쓰거나 수정할 권한이 없습니다.`;
            } else if (error.status === 401) {
                  errorMsg = `GitHub API 인증 오류 (401): PAT가 만료되었거나 유효하지 않습니다.`;
                  octokit = null; showSection(loginSection); patInput.disabled = false; loginButton.disabled = false;
                  return; // Exit early
            }
            updateStatus(errorMsg, true);

            // Re-enable buttons on failure, allowing user to retry or cancel
            saveFileButton.disabled = false;
            cancelEditButton.disabled = false;
            // Only re-enable delete if it was an update (not rename or create) attempt that failed
            deleteFileButton.disabled = !(isUpdateOperation && !isRename);
        }
    });

    /**
     * Handles the Delete button click.
     * Confirms deletion and calls the GitHub API to delete the file.
     */
    deleteFileButton.addEventListener('click', async () => {
        if (!octokit || !selectedOwner || !selectedRepo) {
             updateStatus("오류: Octokit이 초기화되지 않았거나 저장소가 선택되지 않았습니다.", true);
             return;
        }

        const filePathToDelete = currentFilePathInput.value;
        const fileShaToDelete = currentFileShaInput.value; // This is the blob SHA from the loaded file state
        const filenameOnly = filePathToDelete ? filePathToDelete.substring(filePathToDelete.lastIndexOf('/') + 1) : '알 수 없는 파일';

        // Ensure we have the necessary info from the loaded file state
        if (!filePathToDelete || !fileShaToDelete) {
            updateStatus('오류: 삭제할 파일 정보(경로 또는 SHA)가 없습니다. 파일을 다시 로드한 후 시도해주세요.', true);
            return;
        }

        // Confirmation dialog with strong warning
        if (!confirm(`정말로 '${filenameOnly}' 파일을 삭제하시겠습니까?\n경로: ${filePathToDelete}\n\n⚠️ 경고: 이 작업은 되돌릴 수 없습니다! GitHub 저장소에서 파일이 영구적으로 제거됩니다.`)) {
            updateStatus('파일 삭제 작업 취소됨.', false);
            return;
        }

        // Determine commit message for deletion
        let commitMessage = commitMessageInput.value.trim();
         // Use a standard delete message if the current one seems irrelevant (e.g., left over from editing)
         // Or if it's empty.
         if (!commitMessage || commitMessage.toLowerCase().startsWith('update ') || commitMessage.toLowerCase().startsWith('create ')) {
             commitMessage = `Delete ${filenameOnly} via web editor`;
             // No need to update the input field visually as the editor will be cleared on success.
         }

        updateStatus(`'${filePathToDelete}' 삭제 중...`);
        // Disable all editor buttons during deletion API call
        saveFileButton.disabled = true;
        cancelEditButton.disabled = true;
        deleteFileButton.disabled = true;

        try {
            // Use octokit.rest.repos.deleteFile API call
            await octokit.rest.repos.deleteFile({
                owner: selectedOwner,
                repo: selectedRepo,
                path: filePathToDelete,   // The full path to the file
                message: commitMessage,   // Commit message for the deletion
                sha: fileShaToDelete,     // REQUIRED: The blob SHA of the file being deleted
                branch: currentBranch     // The branch where the deletion should occur
            });

            updateStatus(`'${filePathToDelete}' 삭제 완료.`, false, true); // Success
            clearEditorFields(); // Clear the editor state
            showSection(fileBrowserSection); // Go back to the file browser
            // Refresh the file list in the directory where the file was deleted
            fetchContents(currentPath);

        } catch (error) {
            console.error("Delete File Error:", error);
            let errorMsg = `파일 삭제 실패 (${filePathToDelete}): ${error.message}`;
             if (error.status === 404) {
                 // File not found - might be due to incorrect SHA (file changed) or already deleted
                 errorMsg = `삭제할 파일 '${filePathToDelete}' (SHA: ${fileShaToDelete})을(를) 찾을 수 없거나 SHA가 일치하지 않습니다 (404). 이미 삭제되었거나 내용이 변경되었을 수 있습니다.`;
             } else if (error.status === 409) { // Conflict - SHA mismatch most likely
                 errorMsg = `파일 삭제 충돌 (409): 파일이 서버에서 변경되었을 수 있습니다 (SHA 불일치). 페이지를 새로고침하고 다시 시도하세요.`;
             } else if (error.status === 422) { // Unprocessable Entity - Often missing required parameters like SHA
                  errorMsg = `잘못된 삭제 요청 (422): 필수 파라미터(SHA 등)가 누락되었거나 형식이 잘못되었을 수 있습니다. (${error.message})`;
             } else if (error.status === 403) {
                  errorMsg = `파일 삭제 권한 오류 (403): 이 파일을 삭제할 권한이 없습니다.`;
             } else if (error.status === 401) {
                  errorMsg = `GitHub API 인증 오류 (401): PAT가 만료되었거나 유효하지 않습니다.`;
                  octokit = null; showSection(loginSection); patInput.disabled = false; loginButton.disabled = false;
                  return; // Exit early
             }
            updateStatus(errorMsg, true);

            // On delete failure, the file likely still exists in the editor state.
            // Re-enable Cancel and Delete (if not a 404) to allow user action.
            // Keep Save disabled as the state might be inconsistent.
            cancelEditButton.disabled = false;
            // Only re-enable delete if it wasn't a 404 (file not found / already deleted)
            deleteFileButton.disabled = (error.status === 404);
            // Keep save disabled
            saveFileButton.disabled = true;
        }
    });

    /**
     * Handles the Cancel button click.
     * Clears the editor and returns to the file browser, asking for confirmation if changes were made.
     */
    cancelEditButton.addEventListener('click', () => {
        // Simple check if there's potentially unsaved content (title, body, or if editing an existing file)
        const hasUnsavedContent = fmTitleInput.value || fileContentInput.value || currentFileShaInput.value;
        let confirmed = true; // Assume confirmed if no content

        if (hasUnsavedContent) {
             confirmed = confirm("편집 중인 내용이 있습니다. 저장하지 않고 취소하시겠습니까?");
        }

        if (confirmed) {
            clearEditorFields();
            updateStatus('편집 작업 취소됨.');
            showSection(fileBrowserSection);
            // No need to refresh file list here usually, unless user cancelled 'new file'
            // Consider adding fetchContents(currentPath) if needed, but might be slow.
        }
    });

    // --- Event listeners for automatic updates based on input ---

    /**
     * Auto-generates filename and updates commit message when the Title changes.
     */
    fmTitleInput.addEventListener('input', () => {
         const title = fmTitleInput.value;
         const generatedFilename = generateHugoFilename(title);
         // Only update filename if title is not empty, otherwise keep potentially manually edited name
         if (title.trim()) {
              fileNameInput.value = generatedFilename;
         }
         updateCommitMessage(); // Update commit message based on new filename/title/operation type
    });

    /**
     * Updates commit message if the user manually edits the filename.
     */
    fileNameInput.addEventListener('input', () => {
         updateCommitMessage(); // Reflect manual filename changes in commit message
    });


    // --- Initial State Setup ---
    clearEditorFields(); // Ensure editor is clear on load
    showSection(loginSection); // Start at the login section
    updateStatus('시작: GitHub PAT를 입력하고 저장소를 선택하세요.');

</script>

</body>
</html>
