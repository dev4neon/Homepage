<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub ÌååÏùº ÏóêÎîîÌÑ∞ (Octokit + Hugo) - Tokyo Night</title>

    <!-- TUI Editor CSS -->
    <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />

    <style>
        /* Tokyo Night Palette (Inspired by Risotto Theme) */
        :root {
            --bg: #1a1b26;          /* Background */
            --bg-alt: #24283b;      /* Slightly lighter background (sections, inputs) */
            --bg-hover: #292e42;    /* Hover background, Code Block Background */
            --fg: #c0caf5;          /* Foreground / Default Text */
            --fg-dim: #a9b1d6;      /* Slightly dimmer text */
            --grey: #565f89;        /* Comments, Dim UI elements */
            --border: #414868;      /* Borders, Separators */

            --blue: #7aa2f7;        /* Primary Accent (Buttons, Links, h2) */
            --cyan: #7dcfff;        /* Secondary Accent (File icons?) */
            --purple: #bb9af7;      /* Tertiary Accent */
            --green: #9ece6a;       /* Success */
            --orange: #ff9e64;      /* Warnings, Folder icons */
            --red: #f7768e;         /* Errors, Delete button */
            --yellow: #e0af68;      /* Optional accent */

            --button-fg: #1f2335;   /* Text on buttons for contrast */
        }

        body {
            font-family: sans-serif;
            line-height: 1.6;
            padding: 0px;
            background-color: var(--bg);
            color: var(--fg);
            margin: 0; /* Ensure no default margin */
        }
        .container {
            max-width: 900px;
            margin: 20px auto; /* Add some margin */
            padding: 0 10px; /* Add horizontal padding */
        }

        #header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px; /* Increased margin */
            flex-wrap: wrap;
            gap: 10px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 15px;
            padding-left: 10px; /* Match container padding */
            padding-right: 10px;
        }

        #header-container h1 {
            margin-bottom: 0;
            margin-right: 15px;
            flex-grow: 1;
            font-size: 1.8em;
            color: var(--fg); /* Main text color */
        }

        #header-container #logoutButton {
             margin: 0;
             padding: 8px 15px;
             font-size: 0.9rem;
             white-space: nowrap;
             flex-shrink: 0;
             background-color: var(--grey); /* Dimmer button for logout */
             color: var(--fg);
        }
        #header-container #logoutButton:hover:not(:disabled) {
             background-color: var(--border); /* Slightly lighter dim */
        }

        .section {
            padding: 20px; /* Increased padding */
            margin-bottom: 20px;
            border: 1px solid var(--border);
            border-radius: 5px;
            background-color: var(--bg-alt); /* Section background */
            box-shadow: none; /* Remove shadow, use border in dark mode */
        }
        h1 { margin-bottom: 30px; color: var(--fg); }
        h2, h3 { color: var(--blue); } /* Use primary accent for h2 */
        h2 {
            border-bottom: 2px solid var(--border);
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        h3 {
            margin-top: 25px;
            margin-bottom: 15px;
            color: var(--purple); /* Use tertiary accent for h3 */
            font-size: 1.2em;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--fg-dim); /* Slightly dimmer text for labels */
        }
        input[type="text"], input[type="password"], select, textarea {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid var(--border);
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1rem;
            background-color: var(--bg); /* Darker input background */
            color: var(--fg); /* Light text */
        }
        input::placeholder, textarea::placeholder {
            color: var(--grey); /* Dim placeholder text */
            opacity: 1; /* Firefox */
        }

        button {
            padding: 12px 18px;
            background-color: var(--blue); /* Primary accent */
            color: var(--button-fg); /* Dark text for contrast on blue */
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            margin-top: 10px;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.2s ease;
            vertical-align: middle;
        }
        button:hover:not(:disabled) {
            background-color: #5d87d7; /* Slightly darker blue */
        }
        /* *** MODIFIED: Removed cursor: not-allowed; *** */
        button:disabled {
            background-color: var(--border); /* Muted background */
            color: var(--grey); /* Muted text */
            /* cursor: not-allowed; */ /* Removed this line */
        }
        #fileList ul {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 4px;
            background-color: var(--bg); /* Match input background */
        }
        #fileList li {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: background-color 0.2s ease;
            color: var(--fg-dim); /* Dimmer text for file list items */
        }
        #fileList li:last-child { border-bottom: none; }
        #fileList li:hover { background-color: var(--bg-hover); } /* Hover effect */
        #fileList li::before { margin-right: 10px; font-size: 1.1em; }
        #fileList li.dir::before { content: 'üìÅ'; color: var(--orange); } /* Orange for folders */
        #fileList li.file::before { content: 'üìÑ'; color: var(--cyan); }  /* Cyan for files */
        #fileList li strong { font-weight: bold; color: var(--blue); } /* Blue for folder/file names? */
        #fileList li em { color: var(--grey); font-style: italic; } /* Dim color for empty message */

        /* *** Added: Explicit cursor for non-editable files *** */
        #fileList li.file:not([style*="cursor: pointer"]) {
            cursor: default; /* Ensure non-editable files have default cursor */
        }


        #statusBar {
            margin-top: 20px;
            padding: 12px;
            background-color: var(--bg-alt); /* Matches section bg */
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--fg-dim);
            text-align: center;
            font-size: 0.95em;
        }
        .hidden { display: none !important; }
        .status-bar-error {
            color: var(--red) !important;
            background-color: rgba(247, 118, 142, 0.1) !important; /* Faint red background */
            border: 1px solid var(--red) !important;
            font-weight: bold;
        }
        .status-bar-success {
            color: var(--green) !important;
            background-color: rgba(158, 206, 106, 0.1) !important; /* Faint green background */
            border: 1px solid var(--green) !important;
        }
        .warning {
            color: var(--orange);
            background-color: rgba(255, 158, 100, 0.1); /* Faint orange background */
            border: 1px solid var(--orange);
            border-left: 4px solid var(--orange);
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .warning strong { color: var(--orange); } /* Ensure strong text inherits color */
        .error { /* Error message style (e.g., in file list) */
            color: var(--red);
            font-weight: bold;
            border-left: 4px solid var(--red);
            padding: 10px;
            background-color: rgba(247, 118, 142, 0.1);
            border-radius: 4px;
            margin-bottom: 15px;
        }
        .breadcrumb {
            margin-bottom: 15px;
            font-size: 0.95em;
            color: var(--grey); /* Dim text for path */
            background-color: var(--bg); /* Darker background */
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid var(--border);
        }
        .breadcrumb strong { color: var(--fg); } /* Main text color for current part */
        .breadcrumb a { text-decoration: none; color: var(--cyan); } /* Cyan for links */
        .breadcrumb a:hover { text-decoration: underline; color: var(--blue); } /* Blue on hover */
        .breadcrumb span { margin: 0 5px; color: var(--border); } /* Dimmer separator */
        hr { margin: 25px 0; border: 0; border-top: 1px solid var(--border); }

        label[for="fmTocCheckbox"] {
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 10px;
            font-weight: normal;
            color: var(--fg-dim); /* Match other labels */
        }
        input[type="checkbox"] {
            margin-right: 8px;
            vertical-align: middle;
            width: auto;
            accent-color: var(--blue); /* Use accent color for checkbox */
        }

        .controls-container {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        /* Specific Button Styles */
        #deleteFileButton {
             background-color: var(--red); /* Red for delete */
             color: var(--bg); /* Dark text for contrast */
        }
        #deleteFileButton:hover:not(:disabled) {
             background-color: #d65a70; /* Darker red */
        }
        #cancelEditButton {
             background-color: var(--grey); /* Dimmer button */
             color: var(--fg);
        }
         #cancelEditButton:hover:not(:disabled) {
             background-color: var(--border);
        }

        /* --- TUI Editor Dark Theme Adjustments --- */
        .toastui-editor-defaultUI {
            border-color: var(--border) !important;
            background-color: var(--bg-alt);
        }
        .toastui-editor-defaultUI .ProseMirror,
        .toastui-editor-md-container .toastui-editor-md-preview {
             background-color: var(--bg) !important;
             /* color: var(--fg) !important; */ /* Base color set below */
        }
        /* Mode switch tabs */
        .toastui-editor-mode-switch {
            background-color: var(--bg-alt);
            border-top-color: var(--border) !important;
        }
        .toastui-editor-mode-switch button {
            color: var(--grey) !important;
            border-color: var(--border) !important;
        }
         .toastui-editor-mode-switch button.active {
             color: var(--fg) !important;
             background-color: var(--bg) !important;
             border-bottom-color: var(--bg) !important; /* Hide bottom border */
         }
         /* Scrollbars (might need vendor prefixes) */
        .toastui-editor-contents::-webkit-scrollbar,
        .toastui-editor-md-preview::-webkit-scrollbar {
            width: 8px;
        }
        .toastui-editor-contents::-webkit-scrollbar-track,
        .toastui-editor-md-preview::-webkit-scrollbar-track {
            background: var(--bg-alt);
        }
        .toastui-editor-contents::-webkit-scrollbar-thumb,
        .toastui-editor-md-preview::-webkit-scrollbar-thumb {
            background-color: var(--grey);
            border-radius: 4px;
            border: 2px solid var(--bg-alt);
        }

        /* --- Force Text Color in TUI Editor Content Areas --- */
        /* Set base color for the main content containers */
        .toastui-editor-md-container .ProseMirror,
        .toastui-editor-ww-container .ProseMirror,
        .toastui-editor-md-preview {
            color: var(--fg) !important; /* Default text color */
        }

        /* Target common text elements within the content areas */
        /* This is safer than '*' but still quite broad */
        .toastui-editor-md-container .ProseMirror p,
        .toastui-editor-md-container .ProseMirror li,
        .toastui-editor-md-container .ProseMirror h1,
        .toastui-editor-md-container .ProseMirror h2,
        .toastui-editor-md-container .ProseMirror h3,
        .toastui-editor-md-container .ProseMirror h4,
        .toastui-editor-md-container .ProseMirror h5,
        .toastui-editor-md-container .ProseMirror h6,
        .toastui-editor-md-container .ProseMirror span:not([class*="cm-"]), /* Avoid overriding CodeMirror spans */
        .toastui-editor-md-container .ProseMirror div,
        .toastui-editor-ww-container .ProseMirror p,
        .toastui-editor-ww-container .ProseMirror li,
        .toastui-editor-ww-container .ProseMirror h1,
        .toastui-editor-ww-container .ProseMirror h2,
        .toastui-editor-ww-container .ProseMirror h3,
        .toastui-editor-ww-container .ProseMirror h4,
        .toastui-editor-ww-container .ProseMirror h5,
        .toastui-editor-ww-container .ProseMirror h6,
        .toastui-editor-ww-container .ProseMirror span,
        .toastui-editor-ww-container .ProseMirror div,
        .toastui-editor-md-preview p,
        .toastui-editor-md-preview li,
        .toastui-editor-md-preview h1,
        .toastui-editor-md-preview h2,
        .toastui-editor-md-preview h3,
        .toastui-editor-md-preview h4,
        .toastui-editor-md-preview h5,
        .toastui-editor-md-preview h6,
        .toastui-editor-md-preview span,
        .toastui-editor-md-preview div {
            color: var(--fg) !important;
        }

        /* --- Preserve/Override Specific Element Colors --- */
        /* Links */
        .toastui-editor-md-container .ProseMirror a,
        .toastui-editor-ww-container .ProseMirror a,
        .toastui-editor-md-preview a {
            color: var(--blue) !important; /* Keep links blue */
        }
        .toastui-editor-md-container .ProseMirror a:hover,
        .toastui-editor-ww-container .ProseMirror a:hover,
        .toastui-editor-md-preview a:hover {
            color: var(--cyan) !important; /* Lighter blue/cyan on hover */
        }

        /* Code Blocks and Inline Code */
        /* *** MODIFIED: Change pre background color *** */
        .toastui-editor-md-preview pre,
        .toastui-editor-ww-container .ProseMirror pre { /* Also target pre in WYSIWYG */
             background-color: var(--bg-hover) !important; /* Use the desired dark grey-blue */
             border: 1px solid var(--border) !important;
             padding: 1em !important;
             border-radius: 4px !important;
             color: var(--fg-dim) !important; /* Slightly dimmer text for code blocks */
             overflow-x: auto; /* Ensure horizontal scroll for long lines */
        }
        /* Inline code in preview */
        .toastui-editor-md-preview code,
        .toastui-editor-ww-container .ProseMirror code { /* Also target inline code in WYSIWYG */
            background-color: rgba(122, 162, 247, 0.15) !important; /* Faint blue background */
            color: var(--cyan) !important; /* Cyan text for inline code */
            padding: 0.2em 0.4em !important;
            border-radius: 3px !important;
            font-size: 90% !important;
            vertical-align: middle;
        }
         /* Code *inside* a pre block should not have the inline style */
         .toastui-editor-md-preview pre > code,
         .toastui-editor-ww-container .ProseMirror pre > code { /* Also target code inside pre in WYSIWYG */
            background-color: transparent !important;
            color: inherit !important; /* Inherit from pre */
            padding: 0 !important;
            border-radius: 0 !important;
            font-size: inherit !important;
            border: none !important;
        }

        /* Ensure cursors are visible */
        .toastui-editor-md-container .ProseMirror .cm-cursor { border-left: 1px solid var(--fg) !important; }
        .toastui-editor-ww-container .ProseMirror-yewrap-cursor { background-color: var(--fg) !important; }
        .toastui-editor-ww-container .ProseMirror-gapcursor span { border-color: var(--fg) !important; }
        .cm-fat-cursor .cm-cursor { background: var(--blue) !important; border-left: none !important; opacity: 0.6; } /* Block cursor style */

        /* Adjust selection background */
        .cm-selectionBackground, ::selection {
             background-color: rgba(122, 162, 247, 0.2) !important; /* Faint blue selection */
        }
        .toastui-editor-md-container .ProseMirror-selectednode,
        .toastui-editor-ww-container .ProseMirror-selectednode {
             background-color: rgba(122, 162, 247, 0.2) !important; /* Selected node in WYSIWYG/MD */
        }


        @media (max-width: 600px) {
            .container {
                margin: 10px;
                padding: 0 5px;
            }
             #header-container {
                 flex-direction: column;
                 align-items: flex-start;
                 padding-bottom: 10px;
                 padding-left: 5px;
                 padding-right: 5px;
             }
             #header-container h1 {
                 font-size: 1.6em;
                 margin-right: 0;
                 margin-bottom: 10px;
             }
              #header-container #logoutButton {
                   width: 100%;
                   margin-top: 5px;
                   text-align: center;
              }

            .section { padding: 15px; }
            h2 { font-size: 1.3em; }
            h3 { font-size: 1.1em; }

            .controls-container {
                flex-direction: column;
                align-items: stretch;
            }
            .controls-container button {
                 width: 100%;
                 margin-right: 0;
                 margin-bottom: 10px;
            }
            .controls-container button:last-child {
                margin-bottom: 0;
            }

            input[type="text"], input[type="password"], select, textarea { padding: 10px; }
            #fileList ul { max-height: 250px; }
        }
    </style>
</head>
<body>

<div class="container">
    <div id="header-container">
        <h1>GitHub md ÏóêÎîîÌÑ∞</h1>
        <button id="logoutButton" class="hidden">Î°úÍ∑∏ÏïÑÏõÉ</button>
    </div>

    <div id="loginSection" class="section">
        <h2>1. GitHub Î°úÍ∑∏Ïù∏ (Octokit ÏÇ¨Ïö©)</h2>
        <div class="warning">
            <strong>Ï£ºÏùò:</strong> Personal Access Token (PAT)ÏùÑ Î∏åÎùºÏö∞Ï†ÄÏóê Ï†ÄÏû•ÌïòÍ±∞ÎÇò ÏûÖÎ†•ÌïòÎäî Í≤ÉÏùÄ Î≥¥ÏïàÏÉÅ ÏúÑÌóòÌï† Ïàò ÏûàÏäµÎãàÎã§. Î∞òÎìúÏãú Ïã†Î¢∞Ìï† Ïàò ÏûàÎäî ÌôòÍ≤ΩÏóêÏÑú Í∞úÏù∏Ï†ÅÏù∏ Ïö©ÎèÑÎ°úÎßå ÏÇ¨Ïö©ÌïòÍ≥†, ÌÜ†ÌÅ∞Ïù¥ Ïô∏Î∂ÄÏóê ÎÖ∏Ï∂úÎêòÏßÄ ÏïäÎèÑÎ°ù Í∞ÅÎ≥ÑÌûà Ï£ºÏùòÌïòÏÑ∏Ïöî. <strong>Ïù¥ ÌÜ†ÌÅ∞ÏùÄ Î∏åÎùºÏö∞Ï†ÄÎ•º Îã´ÏïÑÎèÑ Ïú†ÏßÄÎê† Ïàò ÏûàÏúºÎØÄÎ°ú (`localStorage` ÏÇ¨Ïö©), ÏÇ¨Ïö© ÌõÑÏóêÎäî Î∞òÎìúÏãú 'Î°úÍ∑∏ÏïÑÏõÉ ÌïòÍ∏∞' Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Í±∞ÎÇò Î∏åÎùºÏö∞Ï†ÄÏùò Ï†ÄÏû•Îêú ÏÇ¨Ïù¥Ìä∏ Îç∞Ïù¥ÌÑ∞Î•º ÏßÅÏ†ë ÏÇ≠Ï†úÌïòÏÑ∏Ïöî.</strong> ÌÜ†ÌÅ∞ÏóêÎäî <strong>'repo'</strong> Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.
        </div>
        <label for="patInput">Personal Access Token (PAT):</label>
        <input type="password" id="patInput" placeholder="GitHub PAT ÏûÖÎ†• (repo Í∂åÌïú ÌïÑÏöî)">
        <div class="controls-container">
             <button id="loginButton">Î°úÍ∑∏Ïù∏</button>
        </div>
    </div>

    <div id="repoSection" class="section hidden">
        <h2>2. Ï†ÄÏû•ÏÜå ÏÑ†ÌÉù</h2>
        <label for="repoSelect">Ï†ÄÏû•ÏÜå:</label>
        <select id="repoSelect"></select>
        <div class="controls-container">
            <button id="loadRepoButton" disabled>ÌååÏùº Î™©Î°ù Î∂àÎü¨Ïò§Í∏∞</button>
        </div>
    </div>

    <div id="fileBrowserSection" class="section hidden">
        <h2>3. ÌååÏùº ÌÉêÏÉâÍ∏∞</h2>
        <div><strong>ÌòÑÏû¨ Ï†ÄÏû•ÏÜå:</strong> <span id="currentRepo"></span></div>
        <div class="breadcrumb"><strong>Í≤ΩÎ°ú:</strong> <span id="currentPathBreadcrumb">/</span></div>
        <div id="fileList">
            <ul></ul>
        </div>
         <div class="controls-container">
            <button id="createNewFileButton">ÏÉà ÌååÏùº ÎßåÎì§Í∏∞ (Hugo)</button>
        </div>
    </div>

    <div id="editorSection" class="section hidden">
        <h2>4. ÌååÏùº Ìé∏ÏßëÍ∏∞ / Front Matter (TOML)</h2>
        <input type="hidden" id="currentFileSha">
        <input type="hidden" id="currentFilePathInput">

         <label for="fmTitleInput">Title (ÌïÑÏàò, ÌååÏùºÎ™Ö ÏÉùÏÑ±Ïóê ÏÇ¨Ïö©):</label>
         <input type="text" id="fmTitleInput" placeholder="Í≤åÏãúÎ¨º Ï†úÎ™©">

         <label for="fileNameInput">ÌååÏùº Ïù¥Î¶Ñ (ÏûêÎèô ÏÉùÏÑ±/Ìé∏Ïßë Í∞ÄÎä•, ÌôïÏû•Ïûê .md Í≥†Ï†ï):</label>
         <input type="text" id="fileNameInput" placeholder="my-new-post.md (Title ÏûÖÎ†• Ïãú ÏûêÎèô ÏÉùÏÑ±)">

        <hr>
        <h3>Hugo Front Matter (TOML)</h3>
        <label for="fmAuthorInput">Author:</label>
        <input type="text" id="fmAuthorInput" placeholder="ÏûëÏÑ±Ïûê (ÏÑ†ÌÉù ÏÇ¨Ìï≠)">

        <label for="fmDateInput">Date (ÌïÑÏàò, YYYY-MM-DDTHH:MM:SSZ ÌòïÏãù Í∂åÏû•):</label>
        <input type="text" id="fmDateInput" placeholder="Ïòà: 2023-10-27T15:04:05+09:00 ÎòêÎäî 2023-10-27T06:04:05Z">

        <label for="fmDescriptionInput">Description:</label>
        <input type="text" id="fmDescriptionInput" placeholder="Í∞ÑÎã®Ìïú ÏÑ§Î™Ö (ÏÑ†ÌÉù ÏÇ¨Ìï≠)">

        <label for="fmTagsInput">Tags (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ):</label>
        <input type="text" id="fmTagsInput" placeholder="Ïòà: web, development, github">

        <label for="fmCategoriesInput">Categories (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ):</label>
        <input type="text" id="fmCategoriesInput" placeholder="Ïòà: tech, programming">

        <div>
             <input type="checkbox" id="fmTocCheckbox">
             <label for="fmTocCheckbox">Table of Contents (TOC) ÏÉùÏÑ±</label>
        </div>
        <hr>

        <label for="tuiEditorContainer">ÌååÏùº ÎÇ¥Ïö© (Î≥∏Î¨∏ - Markdown Îì±):</label>
        <!-- Replaced textarea with this div for TUI Editor -->
        <div id="tuiEditorContainer" style="margin-bottom: 15px;"></div>

        <hr>
        <label for="commitMessageInput">Ïª§Î∞ã Î©îÏãúÏßÄ (ÏûêÎèô ÏÉùÏÑ±/Ìé∏Ïßë Í∞ÄÎä•):</label>
        <input type="text" id="commitMessageInput" placeholder="ÏûêÎèô ÏÉùÏÑ± ÎòêÎäî ÏßÅÏ†ë ÏûÖÎ†•">

        <div class="controls-container">
            <button id="saveFileButton">Ï†ÄÏû• (ÏÉùÏÑ±/ÏàòÏ†ï)</button>
            <button id="deleteFileButton">ÏÇ≠Ï†ú</button> <!-- Style overridden by CSS rule -->
            <button id="cancelEditButton">Ï∑®ÏÜå</button> <!-- Style overridden by CSS rule -->
        </div>
    </div>

    <div id="statusBar">ÏÉÅÌÉú: ÎåÄÍ∏∞ Ï§ë...</div>

</div>

<!-- TUI Editor JavaScript (load before your module script) -->
<script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>

<script type="module">
    import { Octokit } from "https://esm.sh/octokit";

    let octokit = null;
    let selectedOwner = null;
    let selectedRepo = null;
    let currentPath = '';
    let currentFiles = [];
    let currentBranch = 'main'; // Or detect default branch later
    const PAT_STORAGE_KEY = 'githubPat';

    // --- Element References ---
    const patInput = document.getElementById('patInput');
    const loginButton = document.getElementById('loginButton');
    const logoutButton = document.getElementById('logoutButton');
    const repoSelect = document.getElementById('repoSelect');
    const loadRepoButton = document.getElementById('loadRepoButton');
    const fileListUl = document.querySelector('#fileList ul');
    const currentRepoSpan = document.getElementById('currentRepo');
    const currentPathBreadcrumb = document.getElementById('currentPathBreadcrumb');
    const fileNameInput = document.getElementById('fileNameInput');
    const fmTitleInput = document.getElementById('fmTitleInput');
    const fmAuthorInput = document.getElementById('fmAuthorInput');
    const fmDateInput = document.getElementById('fmDateInput');
    const fmDescriptionInput = document.getElementById('fmDescriptionInput');
    const fmTagsInput = document.getElementById('fmTagsInput');
    const fmCategoriesInput = document.getElementById('fmCategoriesInput');
    const fmTocCheckbox = document.getElementById('fmTocCheckbox');
    const commitMessageInput = document.getElementById('commitMessageInput');
    const currentFileShaInput = document.getElementById('currentFileSha');
    const currentFilePathInput = document.getElementById('currentFilePathInput');
    const saveFileButton = document.getElementById('saveFileButton');
    const deleteFileButton = document.getElementById('deleteFileButton');
    const cancelEditButton = document.getElementById('cancelEditButton');
    const createNewFileButton = document.getElementById('createNewFileButton');
    const statusBar = document.getElementById('statusBar');
    const loginSection = document.getElementById('loginSection');
    const repoSection = document.getElementById('repoSection');
    const fileBrowserSection = document.getElementById('fileBrowserSection');
    const editorSection = document.getElementById('editorSection');
    const tuiEditorElement = document.getElementById('tuiEditorContainer'); // Get editor container

    // --- TUI Editor Instance ---
    let tuiEditorInstance = null;

    // --- Initialize TUI Editor ---
    function initializeTuiEditor() {
        if (tuiEditorElement && !tuiEditorInstance) { // Initialize only once
             try {
                 tuiEditorInstance = new toastui.Editor({
                     el: tuiEditorElement,
                     height: '450px', // Adjust height as needed
                     initialEditType: 'markdown',
                     previewStyle: 'tab', // Or 'tab'
                     initialValue: '', // Start empty
                     theme: 'dark' // Apply dark theme
                 });
                 console.log("TUI Editor initialized.");
             } catch (error) {
                 console.error("Failed to initialize TUI Editor:", error);
                 updateStatus("Ïò§Î•ò: TUI ÏóêÎîîÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®ÌïòÍ±∞ÎÇò ÏΩòÏÜîÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.", true);
                 if (editorSection) editorSection.classList.add('hidden');
                 if (tuiEditorElement) tuiEditorElement.innerHTML = '<p class="error">TUI Editor Î°úÎìú Ïã§Ìå®.</p>';
             }
        } else if (!tuiEditorElement) {
            console.error("TUI Editor container element (#tuiEditorContainer) not found in the DOM.");
             updateStatus("Ïò§Î•ò: TUI Editor Ïª®ÌÖåÏù¥ÎÑà ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", true);
        }
    }

    // --- Helper Functions (updateStatus, showSection, b64Encode/Decode, parse/formatFrontMatter, generateHugoFilename, etc.) ---
    function updateStatus(message, isError = false, isSuccess = false) {
        statusBar.textContent = `ÏÉÅÌÉú: ${message}`;
        statusBar.classList.remove('status-bar-error', 'status-bar-success');
        if (isError) statusBar.classList.add('status-bar-error');
        else if (isSuccess) statusBar.classList.add('status-bar-success');
        console[isError ? 'error' : 'log'](`Status Update: ${message}`);
    }

    function showSection(sectionToShow) {
        [loginSection, repoSection, fileBrowserSection, editorSection].forEach(section => {
            if (section) section.classList.add('hidden');
        });
        if (sectionToShow) {
            sectionToShow.classList.remove('hidden');
            // Initialize TUI Editor when the editor section is shown for the first time
            if (sectionToShow === editorSection) {
                initializeTuiEditor();
            }
        }
    }

     function b64EncodeUnicode(str) {
        try {
            const bytes = new TextEncoder().encode(str);
            let binary = '';
            for (let i = 0; i < bytes.length; i++) { binary += String.fromCharCode(bytes[i]); }
            return btoa(binary);
        } catch (e) {
             console.error("Base64 Ïù∏ÏΩîÎî© Ïã§Ìå®:", e); updateStatus("Base64 Ïù∏ÏΩîÎî© Ï§ë Ïò§Î•ò Î∞úÏÉù.", true); throw new Error("Base64 Ïù∏ÏΩîÎî© Ïã§Ìå®");
        }
    }

    function b64DecodeUnicode(str) {
        try {
            const binary_string = atob(str);
            const bytes = new Uint8Array(binary_string.length);
            for (let i = 0; i < binary_string.length; i++) { bytes[i] = binary_string.charCodeAt(i); }
            return new TextDecoder('utf-8', { fatal: true }).decode(bytes);
        } catch (e) {
            console.error("Base64/UTF-8 ÎîîÏΩîÎî© Ïã§Ìå®:", e);
            let userMessage = 'Base64 ÎòêÎäî UTF-8 ÎîîÏΩîÎî© Ï§ë Ïò§Î•ò Î∞úÏÉù. ';
            if (e instanceof DOMException && e.name === 'InvalidCharacterError') { userMessage += 'Base64 Î¨∏ÏûêÏó¥Ïù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.'; }
            else if (e instanceof TypeError && e.message.includes('invalid character')) { userMessage += 'Base64 Î¨∏ÏûêÏó¥Ïù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.'; }
            else if (e instanceof Error && e.message.includes('URI malformed')) { userMessage += 'ÌååÏùº ÎÇ¥Ïö©Ïóê ÏûòÎ™ªÎêú UTF-8 ÏãúÌÄÄÏä§Í∞Ä Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.'; }
            else if (e instanceof TypeError && e.message.includes('decode')) { userMessage += 'ÌååÏùº ÎÇ¥Ïö©Ïóê ÏûòÎ™ªÎêú UTF-8 ÏãúÌÄÄÏä§Í∞Ä Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.'; }
            else { userMessage += `(${e.message})`; }
             updateStatus(userMessage, true); throw new Error("Base64/UTF-8 ÎîîÏΩîÎî© Ïã§Ìå®: " + e.message);
        }
    }

     function parseFrontMatter(content) {
        const fm = { title: '', author: '', date: '', description: '', tags: [], categories: [], toc: undefined, body: content };
        const fmRegex = /^\+\+\+([\s\S]*?)^\+\+\+([\s\S]*)/m;
        const match = content.match(fmRegex);

        if (match && match[1] !== undefined && match[2] !== undefined) {
            const frontMatterBlock = match[1].trim();
            fm.body = match[2].trimStart();
            const lines = frontMatterBlock.split('\n');
            let currentKey = null;
            let accumulatingArrayContent = null;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i]; const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.startsWith('#')) continue;
                if (accumulatingArrayContent !== null) {
                    accumulatingArrayContent += "\n" + line;
                    if (line.includes(']')) {
                        const startIndex = accumulatingArrayContent.indexOf('['); const endIndex = accumulatingArrayContent.lastIndexOf(']');
                        if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                            try {
                                let arrayString = accumulatingArrayContent.substring(startIndex + 1, endIndex).trim(); let values = [];
                                if (arrayString) {
                                    values = arrayString.split(',').map(item => item.trim()).filter(item => item && !item.startsWith('#')).map(item => {
                                        if (item.startsWith('"') && item.endsWith('"')) return item.substring(1, item.length - 1).replace(/\\"/g, '"');
                                        if (item.startsWith("'") && item.endsWith("'")) return item.substring(1, item.length - 1).replace(/\\'/g, "'");
                                        return item;
                                    });
                                }
                                if (currentKey === 'tags' || currentKey === 'categories') { fm[currentKey] = values; }
                            } catch (e) { console.error(`Error parsing accumulated multi-line array for key ${currentKey}:`, accumulatingArrayContent, e); updateStatus(`Front matter multi-line Î∞∞Ïó¥ Íµ¨Î¨∏ Î∂ÑÏÑù Ï§ë Ïò§Î•ò Î∞úÏÉù (${currentKey}): ${e.message}`, true); if (currentKey && (currentKey === 'tags' || currentKey === 'categories')) fm[currentKey] = [];
                            } finally { accumulatingArrayContent = null; currentKey = null; }
                        }
                    }
                } else {
                    const eqIndex = trimmedLine.indexOf('=');
                    if (eqIndex > 0) {
                        const key = trimmedLine.substring(0, eqIndex).trim(); let valuePart = trimmedLine.substring(eqIndex + 1).trim();
                        if ((key === 'tags' || key === 'categories') && valuePart.startsWith('[')) {
                             const firstBracket = valuePart.indexOf('['); const lastBracket = valuePart.lastIndexOf(']');
                             if (lastBracket > firstBracket) {
                                try {
                                    let arrayString = valuePart.substring(firstBracket + 1, lastBracket).trim(); let values = [];
                                    if (arrayString) {
                                         values = arrayString.split(',').map(item => item.trim()).filter(item => item && !item.startsWith('#')).map(item => {
                                            if (item.startsWith('"') && item.endsWith('"')) return item.substring(1, item.length - 1).replace(/\\"/g, '"');
                                            if (item.startsWith("'") && item.endsWith("'")) return item.substring(1, item.length - 1).replace(/\\'/g, "'");
                                            return item;
                                        });
                                    } fm[key] = values;
                                } catch(e) { console.error(`Error parsing single-line array for key ${key}:`, valuePart, e); updateStatus(`Front matter Î∞∞Ïó¥ Íµ¨Î¨∏ Î∂ÑÏÑù Ï§ë Ïò§Î•ò Î∞úÏÉù (${key}): ${e.message}`, true); fm[key] = []; }
                            } else { currentKey = key; accumulatingArrayContent = valuePart; }
                        } else {
                            try {
                                let parsedValue = valuePart;
                                if (parsedValue.startsWith('"') && parsedValue.endsWith('"')) { parsedValue = parsedValue.substring(1, parsedValue.length - 1).replace(/\\"/g, '"'); }
                                else if (parsedValue.startsWith("'") && parsedValue.endsWith("'")) { parsedValue = parsedValue.substring(1, parsedValue.length - 1).replace(/\\'/g, "'"); }
                                else if (parsedValue === 'true') { parsedValue = true; }
                                else if (parsedValue === 'false') { parsedValue = false; }
                                if (['title', 'author', 'date', 'description', 'toc'].includes(key)) {
                                     if (key === 'toc') { if (typeof parsedValue === 'boolean') { fm[key] = parsedValue; } else { console.warn(`FM parsing: Expected boolean for 'toc', got:`, parsedValue, `Ignoring.`); }}
                                     else { fm[key] = String(parsedValue); }
                                }
                            } catch (parseError) { console.error(`Error parsing simple front matter line: "${line}"`, parseError); updateStatus(`Front matter Íµ¨Î¨∏ Î∂ÑÏÑù Ï§ë Ïò§Î•ò Î∞úÏÉù: ${line}`, true); }
                        }
                    } else { console.warn(`Invalid front matter line (no '=' found, ignoring): "${trimmedLine}"`); }
                }
            }
            if (accumulatingArrayContent !== null) { console.error(`Front matter parsing ended unexpectedly inside an unclosed array for key: ${currentKey}`); updateStatus(`Front matter Ïò§Î•ò: ${currentKey} Î∞∞Ïó¥Ïù¥ Îã´ÌûàÏßÄ ÏïäÏïòÏäµÎãàÎã§.`, true); if (currentKey && (currentKey === 'tags' || currentKey === 'categories')) { fm[currentKey] = []; }}
        } else { console.log("No TOML front matter detected or block is malformed."); }
        return fm;
    }

     function formatFrontMatter(fmData) {
        let fmString = '+++\n';
        const formatTomlString = (str) => `"${String(str).replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
        const formatTomlArray = (arr) => `[${arr.map(formatTomlString).join(', ')}]`;
        if (fmData.title) fmString += `title = ${formatTomlString(fmData.title)}\n`;
        if (fmData.date) fmString += `date = ${formatTomlString(fmData.date)}\n`;
        if (fmData.author) fmString += `author = ${formatTomlString(fmData.author)}\n`;
        if (fmData.description) fmString += `description = ${formatTomlString(fmData.description)}\n`;
        if (fmData.categories && fmData.categories.length > 0) fmString += `categories = ${formatTomlArray(fmData.categories)}\n`;
        if (fmData.tags && fmData.tags.length > 0) fmString += `tags = ${formatTomlArray(fmData.tags)}\n`;
        if (fmData.toc === true) fmString += `toc = true\n`;
        if (fmString === '+++\n') fmString += '\n'; // Ensure newline even if empty
        fmString += '+++\n\n';
        return fmString;
    }

    function generateHugoFilename(title) {
        if (!title || typeof title !== 'string' || !title.trim()) return 'untitled.md';
        let filename = title.trim().toLowerCase();
        filename = filename.replace(/[\\/:\?\*"<>\|#;\$'\{\}\+=~@%^&\(\)\[\]\.!,`]/g, '');
        filename = filename.replace(/\s+/g, '-');
        filename = filename.replace(/^-+|-+$/g, '');
        filename = filename || 'untitled';
        return filename + '.md';
    }

    function updateCommitMessage() {
        const filename = fileNameInput.value.trim();
        const isUpdate = !!currentFileShaInput.value;
        const originalPath = currentFilePathInput.value;
        const currentFullPath = (currentPath ? currentPath + '/' : '') + filename;
        const isRename = isUpdate && originalPath && filename && (originalPath !== currentFullPath);
        let action = isUpdate ? (isRename ? "Rename/create" : "Update") : "Create";
        let baseFilename = filename || (isUpdate ? originalPath.split('/').pop() : "new file");
        if (baseFilename) {
             let message = `${action} ${baseFilename}`;
             if (isRename) { message = `Create ${filename} (renamed from ${originalPath.split('/').pop()})`; }
             commitMessageInput.value = message; commitMessageInput.placeholder = `Ïòà: ${message}`;
        } else { commitMessageInput.value = ''; commitMessageInput.placeholder = 'ÏûêÎèô ÏÉùÏÑ± ÎòêÎäî ÏßÅÏ†ë ÏûÖÎ†•'; }
    }

    function updateBreadcrumb() {
        const breadcrumbContainer = document.getElementById('currentPathBreadcrumb');
        breadcrumbContainer.innerHTML = '';
        const rootLink = document.createElement('a'); rootLink.href = '#'; rootLink.textContent = 'root'; rootLink.onclick = (e) => { e.preventDefault(); fetchContents(''); }; breadcrumbContainer.appendChild(rootLink);
        const pathParts = currentPath.split('/').filter(p => p); let accumulatedPath = '';
        pathParts.forEach((part, index) => {
            const linkPath = (accumulatedPath ? accumulatedPath + '/' : '') + part;
            const pathSeparator = document.createElement('span'); pathSeparator.textContent = ' / '; breadcrumbContainer.appendChild(pathSeparator);
            if (index < pathParts.length - 1) {
                const partLink = document.createElement('a'); partLink.href = '#'; partLink.textContent = part; partLink.onclick = ((pathForLink) => (e) => { e.preventDefault(); fetchContents(pathForLink); })(linkPath); breadcrumbContainer.appendChild(partLink);
            } else { const currentPartStrong = document.createElement('strong'); currentPartStrong.textContent = part; breadcrumbContainer.appendChild(currentPartStrong); }
            accumulatedPath = linkPath;
        });
        if (pathParts.length === 0) { rootLink.outerHTML = '<strong>root</strong>'; }
    }

     function addParentDirectoryLink(currentDirPath) {
         if (currentDirPath && currentDirPath !== '') {
             const parentPath = currentDirPath.includes('/') ? currentDirPath.substring(0, currentDirPath.lastIndexOf('/')) : '';
             const li = document.createElement('li'); li.innerHTML = '<strong>‚¨ÜÔ∏è .. (ÏÉÅÏúÑ Ìè¥Îçî)</strong>'; li.style.cursor = 'pointer'; li.title = `ÏÉÅÏúÑ Ìè¥ÎçîÎ°ú Ïù¥Îèô: /${parentPath}`; li.onclick = () => fetchContents(parentPath);
             if (fileListUl.firstChild) { fileListUl.insertBefore(li, fileListUl.firstChild); } else { fileListUl.appendChild(li); }
         }
    }

    function clearEditorFields() {
        fileNameInput.value = '';
        fmTitleInput.value = '';
        fmAuthorInput.value = '';
        fmDateInput.value = '';
        fmDescriptionInput.value = '';
        fmTagsInput.value = '';
        fmCategoriesInput.value = '';
        fmTocCheckbox.checked = false;
        // Clear TUI Editor content
        if (tuiEditorInstance) {
            tuiEditorInstance.setMarkdown('', false); // Clear content without moving cursor
        }
        commitMessageInput.value = '';
        commitMessageInput.placeholder = 'ÏûêÎèô ÏÉùÏÑ± ÎòêÎäî ÏßÅÏ†ë ÏûÖÎ†•';
        currentFileShaInput.value = '';
        currentFilePathInput.value = '';
        saveFileButton.disabled = true;
        saveFileButton.textContent = 'Ï†ÄÏû• (ÏÉùÏÑ±/ÏàòÏ†ï)';
        deleteFileButton.disabled = true;
        cancelEditButton.disabled = true;
    }

    function handleLogout() {
        console.log("Logging out: Clearing PAT and reloading...");
        localStorage.removeItem(PAT_STORAGE_KEY);
        octokit = null;
        location.replace(location.pathname + location.search);
    }

    function resetToLoginScreen(tokenToKeepInInput = '') {
         showSection(loginSection);
         patInput.disabled = false; patInput.value = tokenToKeepInInput;
         if (!patInput.value) patInput.placeholder = "GitHub PAT ÏûÖÎ†• (repo Í∂åÌïú ÌïÑÏöî)";
         loginButton.disabled = false; loginButton.textContent = 'Î°úÍ∑∏Ïù∏';
         logoutButton.classList.add('hidden');
         repoSection.classList.add('hidden'); fileBrowserSection.classList.add('hidden'); editorSection.classList.add('hidden');
         repoSelect.innerHTML = ''; repoSelect.disabled = true; loadRepoButton.disabled = true;
         if(createNewFileButton) createNewFileButton.disabled = true;
         selectedOwner = null; selectedRepo = null; currentPath = ''; currentFiles = [];
         if (currentRepoSpan) currentRepoSpan.textContent = '';
         if (currentPathBreadcrumb) updateBreadcrumb();
         if (fileListUl) fileListUl.innerHTML = '';
         octokit = null; clearEditorFields();
    }

    async function authenticateAndLoadRepos(token, isAutoLogin = false) {
        if (!token) {
            console.error("Authentication attempt with no token provided.");
            if (!isAutoLogin) { updateStatus('Ïò§Î•ò: GitHub PATÍ∞Ä Ï†úÍ≥µÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.', true); patInput.disabled = false; loginButton.disabled = false; loginButton.textContent = 'Î°úÍ∑∏Ïù∏'; showSection(loginSection); }
            else { resetToLoginScreen(); showSection(loginSection); }
            return;
        }
        patInput.disabled = true; loginButton.disabled = true; loginButton.textContent = 'Î°úÎî© Ï§ë...'; logoutButton.classList.add('hidden'); repoSelect.disabled = true; loadRepoButton.disabled = true;
        const statusMsg = isAutoLogin ? 'Ï†ÄÏû•Îêú PATÎ°ú Ïù∏Ï¶ù Î∞è Ï†ÄÏû•ÏÜå Î™©Î°ù Î°úÎî© Ï§ë...' : 'GitHub Ïù∏Ï¶ù Î∞è Ï†ÄÏû•ÏÜå Î™©Î°ù Î°úÎî© Ï§ë...'; updateStatus(statusMsg); let clearTokenOnAuthFailure = false;
        try {
            octokit = new Octokit({ auth: token });
            const { data: user } = await octokit.rest.users.getAuthenticated();
            console.log("Authenticated successfully as user:", user.login); logoutButton.classList.remove('hidden'); updateStatus(`ÏÇ¨Ïö©Ïûê '${user.login}' Ïù∏Ï¶ù ÏôÑÎ£å. Ï†ÄÏû•ÏÜå Î™©Î°ù Î°úÎî© Ï§ë...`);
            const repos = await octokit.paginate(octokit.rest.repos.listForAuthenticatedUser, { type: 'all', sort: 'updated', per_page: 100 });
            repoSelect.innerHTML = '<option value="">-- Ï†ÄÏû•ÏÜå ÏÑ†ÌÉù --</option>';
            if (repos && repos.length > 0) {
                repos.forEach(repo => { const option = document.createElement('option'); option.value = `${repo.owner.login}/${repo.name}`; option.textContent = `${repo.full_name} (${repo.private ? 'Private' : 'Public'})`; repoSelect.appendChild(option); });
                 if (!isAutoLogin) { localStorage.setItem(PAT_STORAGE_KEY, token); }
                showSection(repoSection); repoSelect.disabled = false; loadRepoButton.disabled = true; updateStatus(`${repos.length}Í∞úÏùò Ï†ëÍ∑º Í∞ÄÎä•Ìïú Ï†ÄÏû•ÏÜå Î°úÎìú ÏôÑÎ£å. Ï†ÄÏû•ÏÜåÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.`, false, true);
                patInput.value = '********'; patInput.disabled = true; loginButton.textContent = 'Ïù∏Ï¶ù ÏôÑÎ£å'; loginButton.disabled = true;
            } else {
                 if (!isAutoLogin) { localStorage.setItem(PAT_STORAGE_KEY, token); } updateStatus('Ïù∏Ï¶ù ÏÑ±Í≥µ, ÌïòÏßÄÎßå Ï†ëÍ∑º Í∞ÄÎä•Ìïú Ï†ÄÏû•ÏÜåÍ∞Ä ÏóÜÏäµÎãàÎã§. PATÏóê `repo` Í∂åÌïúÏù¥ ÏûàÎäîÏßÄ, ÎòêÎäî ÏÜåÏÜçÎêú Ï†ÄÏû•ÏÜåÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî.', true);
                showSection(repoSection); repoSelect.disabled = true; loadRepoButton.disabled = true; patInput.value = '********'; patInput.disabled = true; loginButton.textContent = 'Ïù∏Ï¶ù ÏôÑÎ£å'; loginButton.disabled = true;
            }
        } catch (error) {
            console.error("Authentication or Repository Fetch Error:", error); let errorMsg = `Ïù∏Ï¶ù ÎòêÎäî Ï†ÄÏû•ÏÜå Î°úÎî© Ï§ë Ïò§Î•ò Î∞úÏÉù: ${error.message}`; octokit = null;
            if (error.status === 401) { errorMsg = `GitHub API Ïù∏Ï¶ù Ïò§Î•ò (401): PATÍ∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÍ±∞ÎÇò ÌïÑÏöîÌïú 'repo' Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§. PATÎ•º ÌôïÏù∏ÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî.`; clearTokenOnAuthFailure = true; }
            else if (error.status === 403) { errorMsg = `GitHub API Ï†ëÍ∑º Ïò§Î•ò (403): Í∂åÌïú Î¨∏Ï†ú ÎòêÎäî API ÏÜçÎèÑ Ï†úÌïúÏùº Ïàò ÏûàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌïòÍ±∞ÎÇò GitHub ÏÑ§Ï†ïÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.`; }
            else if (error.status === 404) { errorMsg = `GitHub API ÏóîÎìúÌè¨Ïù∏Ìä∏ Ïò§Î•ò (404): ÏÇ¨Ïö©Ïûê ÎòêÎäî Ïù∏Ï¶ù Í¥ÄÎ†® ÏóîÎìúÌè¨Ïù∏Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`; }
            else { errorMsg = `GitHub API ÌÜµÏã† Ïò§Î•ò (${error.status || 'Network Error'}): ${error.message}. Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ Î∞è GitHub ÏÉÅÌÉúÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.`; }
            updateStatus(errorMsg, true);
            if (clearTokenOnAuthFailure) { localStorage.removeItem(PAT_STORAGE_KEY); resetToLoginScreen(''); }
            else { resetToLoginScreen(isAutoLogin ? '' : token); }
             showSection(loginSection); logoutButton.classList.add('hidden');
        }
    }

    // --- Event Listeners (Login, Logout, Repo Select/Load) ---
    loginButton.addEventListener('click', () => {
        const tokenFromInput = patInput.value.trim();
        if (!tokenFromInput) { updateStatus('Ïò§Î•ò: GitHub Personal Access Token (PAT)Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.', true); patInput.focus(); return; }
        authenticateAndLoadRepos(tokenFromInput, false);
    });
    logoutButton.addEventListener('click', handleLogout);
    repoSelect.addEventListener('change', () => { loadRepoButton.disabled = repoSelect.value === ''; });
    loadRepoButton.addEventListener('click', () => {
        const selectedRepoFullName = repoSelect.value;
        if (!selectedRepoFullName || !selectedRepoFullName.includes('/')) { updateStatus("Ïò§Î•ò: Ïú†Ìö®Ìïú Ï†ÄÏû•ÏÜåÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.", true); return; };
        if (!octokit || !localStorage.getItem(PAT_STORAGE_KEY)) { updateStatus("Ïò§Î•ò: Ïù∏Ï¶ù Ï†ïÎ≥¥Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.", true); handleLogout(); return; }
        [selectedOwner, selectedRepo] = selectedRepoFullName.split('/');
        if(currentRepoSpan) currentRepoSpan.textContent = selectedRepoFullName;
        updateStatus(`'${selectedRepoFullName}' Ï†ÄÏû•ÏÜåÏùò Î£®Ìä∏ Ìè¥Îçî Î°úÎî© Ï§ë...`); repoSelect.disabled = true; loadRepoButton.disabled = true; fileBrowserSection.classList.add('hidden'); editorSection.classList.add('hidden');
        fetchContents('');
    });

    // --- Core Logic Functions (fetchContents, fetchFileContent) ---
     async function fetchContents(path) {
         const token = localStorage.getItem(PAT_STORAGE_KEY); if (!token || !octokit) { updateStatus("Ïò§Î•ò: Ïù∏Ï¶ù Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§. Î°úÍ∑∏ÏïÑÏõÉÌï©ÎãàÎã§.", true); handleLogout(); return; }
         if (!selectedOwner || !selectedRepo) { updateStatus("Ïò§Î•ò: Ï†ÄÏû•ÏÜå Ï†ïÎ≥¥Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ï†ÄÏû•ÏÜåÎ•º Î®ºÏ†Ä ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", true); showSection(repoSection); repoSelect.disabled = false; loadRepoButton.disabled = repoSelect.value === ''; return; }
        currentPath = path; updateBreadcrumb(); fileListUl.innerHTML = `<li><em><center>Ìè¥Îçî ÎÇ¥Ïö© Î°úÎî© Ï§ë...</center></em></li>`; fileListUl.style.pointerEvents = 'none'; showSection(fileBrowserSection); editorSection.classList.add('hidden'); createNewFileButton.disabled = true; updateStatus(`'${selectedOwner}/${selectedRepo}/${path || 'root'}' ÎÇ¥Ïö© Î°úÎî© Ï§ë...`);
        try {
            const { data: contents } = await octokit.rest.repos.getContent({ owner: selectedOwner, repo: selectedRepo, path: path, ref: currentBranch });
            const contentList = Array.isArray(contents) ? contents : [contents];
            currentFiles = contentList.filter(item => item.type === 'file' || item.type === 'dir').sort((a, b) => { if (a.type !== b.type) return a.type === 'dir' ? -1 : 1; return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }); });
            fileListUl.innerHTML = ''; addParentDirectoryLink(path);
            if (currentFiles.length > 0) {
                currentFiles.forEach(item => {
                    const li = document.createElement('li'); li.textContent = item.name; li.classList.add(item.type); li.dataset.path = item.path; li.dataset.type = item.type; li.dataset.sha = item.sha;
                    if (item.type === 'dir') { li.onclick = () => fetchContents(item.path); li.title = `Ìè¥Îçî Ïó¥Í∏∞: ${item.path}`; }
                    else if (item.type === 'file') {
                        const isEditable = /\.md$/i.test(item.name);
                        if (isEditable) { li.title = `ÌååÏùº ÏàòÏ†ï: ${item.path}`; li.style.cursor = 'pointer'; li.onclick = () => fetchFileContent(item.path, item.sha); }
                        else { li.style.cursor = 'default'; li.style.color = 'var(--grey)'; li.title = `Ïù¥ ÏóêÎîîÌÑ∞Îäî Hugo .md ÌååÏùºÎßå Ìé∏Ïßë Í∞ÄÎä• (${item.name})`; li.onclick = (e) => e.stopPropagation(); }
                    } fileListUl.appendChild(li);
                });
             } else { const li = document.createElement('li'); li.innerHTML = `<em><center>${path === '' ? '(Ï†ÄÏû•ÏÜå Î£®Ìä∏Í∞Ä ÎπÑÏñ¥ ÏûàÏäµÎãàÎã§)' : '(Ìè¥ÎçîÍ∞Ä ÎπÑÏñ¥ ÏûàÏäµÎãàÎã§)'}</center></em>`; li.style.cursor = 'default'; fileListUl.appendChild(li); }
             updateStatus(`'${selectedOwner}/${selectedRepo}/${path || 'root'}' Î°úÎìú ÏôÑÎ£å.`, false, true);
        } catch (error) {
             console.error("Fetch Contents Error:", error); let errorMsg = `Ìè¥Îçî ÎÇ¥Ïö© Î°úÎìú Ïã§Ìå® (${path || 'root'}): ${error.message}`;
              if (error.status === 404) { errorMsg = `Í≤ΩÎ°ú '${path || 'root'}'ÏùÑ(Î•º) Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§ (404). Ï†ÄÏû•ÏÜå ÎòêÎäî Î∏åÎûúÏπòÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.`; }
              else if (error.status === 403) { errorMsg = `Ïù¥ Ï†ÄÏû•ÏÜå ÎòêÎäî Í≤ΩÎ°úÏóê Ï†ëÍ∑ºÌï† Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§ (403). PAT Í∂åÌïúÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.`; }
              else if (error.status === 401) { errorMsg = `GitHub API Ïù∏Ï¶ù Ïò§Î•ò (401): PATÍ∞Ä ÎßåÎ£åÎêòÏóàÍ±∞ÎÇò Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§. Î°úÍ∑∏ÏïÑÏõÉÌï©ÎãàÎã§.`; updateStatus(errorMsg, true); handleLogout(); return; }
             updateStatus(errorMsg, true); fileListUl.innerHTML = ''; addParentDirectoryLink(path); const errorLi = document.createElement('li'); errorLi.className = 'error'; errorLi.style.cursor = 'default'; errorLi.textContent = `Ïò§Î•ò: Ìè¥Îçî ÎÇ¥Ïö©ÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§. (${error.message})`; fileListUl.appendChild(errorLi);
        } finally {
             if (octokit) { createNewFileButton.disabled = false; repoSelect.disabled = false; loadRepoButton.disabled = repoSelect.value === ''; }
             if (fileListUl) fileListUl.style.pointerEvents = 'auto';
        }
    }

    async function fetchFileContent(filePath, fileSha) {
         if (!octokit) { handleLogout(); return; }
         if (!selectedOwner || !selectedRepo) { updateStatus("Ïò§Î•ò: Ï†ÄÏû•ÏÜå Ï†ïÎ≥¥Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.", true); showSection(repoSection); return; }

        updateStatus(`'${filePath}' ÌååÏùº ÎÇ¥Ïö© Î°úÎî© Ï§ë...`);
        createNewFileButton.disabled = true;
        if (fileListUl) fileListUl.style.pointerEvents = 'none';

        // *** CHANGE 1: Clear fields *before* potentially showing the editor section ***
        clearEditorFields();

        // *** CHANGE 2: Show editor section *before* trying to set content ***
        // This ensures initializeTuiEditor() is called by showSection if needed
        showSection(editorSection);

        try {
             const { data: blobData } = await octokit.rest.git.getBlob({ owner: selectedOwner, repo: selectedRepo, file_sha: fileSha });
             if (!blobData || typeof blobData.content === 'undefined' || blobData.encoding !== 'base64' || !blobData.sha) {
                throw new Error('API ÏùëÎãµ ÌòïÏãùÏù¥ ÏûòÎ™ªÎêòÏóàÏäµÎãàÎã§ (Blob). ÎÇ¥Ïö©Ïù¥ÎÇò Ïù∏ÏΩîÎî© ÏÜçÏÑ±Ïù¥ ÏóÜÏäµÎãàÎã§.');
             }
             const sizeLimit = 1 * 1024 * 1024;
             if (blobData.size > sizeLimit) {
                updateStatus(`Í≤ΩÍ≥†: ÌååÏùº ÌÅ¨Í∏∞(${(blobData.size / 1024 / 1024).toFixed(2)} MB)Í∞Ä Ïª§ÏÑú Î°úÎî©/Ï†ÄÏû•Ïù¥ ÎäêÎ¶¥ Ïàò ÏûàÏäµÎãàÎã§.`, false); // Changed to non-error status
             }

             const decodedContent = b64DecodeUnicode(blobData.content);
             const parsedData = parseFrontMatter(decodedContent);

             // Populate form fields first
             fileNameInput.value = filePath.substring(filePath.lastIndexOf('/') + 1);
             fmTitleInput.value = parsedData.title || '';
             fmAuthorInput.value = parsedData.author || '';
             fmDateInput.value = parsedData.date || '';
             fmDescriptionInput.value = parsedData.description || '';
             fmTagsInput.value = (parsedData.tags || []).join(', ');
             fmCategoriesInput.value = (parsedData.categories || []).join(', ');
             fmTocCheckbox.checked = (parsedData.toc === true);

             // *** CHANGE 3: Now it's safe to set content because showSection has run ***
             if (tuiEditorInstance) {
                 tuiEditorInstance.setMarkdown(parsedData.body || '', false); // Set content without moving cursor
             } else {
                 // This case should be much rarer now, but good to keep a check
                 console.error("TUI Editor not initialized when trying to set content, even after showing section.");
                 updateStatus("Ïò§Î•ò: ÏóêÎîîÌÑ∞Í∞Ä Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïÑ ÎÇ¥Ïö©ÏùÑ ÌëúÏãúÌï† Ïàò ÏóÜÏäµÎãàÎã§. ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ®ÏùÑ ÏãúÎèÑÌïòÏÑ∏Ïöî.", true);
                 showSection(fileBrowserSection); // Go back if editor initialization really failed
                 return;
             }

             // Update state and controls
             currentFileShaInput.value = blobData.sha;
             currentFilePathInput.value = filePath;
             saveFileButton.textContent = 'Ï†ÄÏû• (ÏàòÏ†ï)';
             saveFileButton.disabled = false;
             deleteFileButton.disabled = false;
             cancelEditButton.disabled = false;
             updateCommitMessage();

             updateStatus(`'${filePath}' Î°úÎìú ÏôÑÎ£å. Ìé∏Ïßë Í∞ÄÎä•Ìï©ÎãàÎã§.`, false, true);
             // showSection(editorSection); // Already called earlier

        } catch (error) {
            console.error(`Fetch File Content Error (${filePath}, SHA: ${fileSha}):`, error);
            let errorMsg = `ÌååÏùº ÎÇ¥Ïö© Î°úÎî© Ïã§Ìå® (${filePath}): ${error.message}`;
             // --- More specific error messages ---
             if (error.status === 404) { errorMsg = `ÌååÏùº Blob (SHA: ${fileSha})ÏùÑ(Î•º) Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§ (404). ÌååÏùºÏù¥ ÏÇ≠Ï†úÎêòÏóàÍ±∞ÎÇò SHAÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.`; }
             else if (error.status === 403) { errorMsg = `Ïù¥ ÌååÏùº BlobÏóê Ï†ëÍ∑ºÌï† Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§ (403).`; }
             else if (error.status === 422) { errorMsg = `ÏûòÎ™ªÎêú ÏöîÏ≤≠ (422): SHA '${fileSha}' ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§.`; }
             else if (error.message.includes('Base64') || error.message.includes('UTF-8') || error.message.includes('decode')) { errorMsg = `ÌååÏùº ÎîîÏΩîÎî© Ïã§Ìå®: ${error.message}`; }
             else if (error.message.includes('Blob is too big')) { errorMsg = `GitHub API Ïò§Î•ò: ÌååÏùº ÎÇ¥Ïö©Ïù¥ ÎÑàÎ¨¥ ÌÅΩÎãàÎã§ (GitHub Ï†úÌïú Ï¥àÍ≥º).`; }
             else if (error.status === 401) { errorMsg = `GitHub API Ïù∏Ï¶ù Ïò§Î•ò (401): PAT ÎßåÎ£åÎê®. Î°úÍ∑∏ÏïÑÏõÉÌï©ÎãàÎã§.`; updateStatus(errorMsg, true); handleLogout(); return; }
             // --- Generic message for other errors ---
             // else { errorMsg = `ÌååÏùº ÎÇ¥Ïö© Î°úÎî© Ï§ë ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•ò: ${error.message}`; } // Already covered by default

            updateStatus(errorMsg, true);
            // *** CHANGE 4: Ensure we hide the editor and show the browser on error ***
            showSection(fileBrowserSection);
        } finally {
            // Re-enable controls that were disabled at the start
            if (octokit) {
                createNewFileButton.disabled = false;
                 if (fileListUl) fileListUl.style.pointerEvents = 'auto';
            }
        }
    }

    // --- Editor Actions (Create New, Save, Delete, Cancel) ---
    createNewFileButton.addEventListener('click', () => {
        if (!octokit) { handleLogout(); return; }
        clearEditorFields(); // Resets form and TUI editor content
        try {
            const now = new Date(); const offsetMinutes = now.getTimezoneOffset(); const offsetSign = offsetMinutes <= 0 ? '+' : '-'; const offsetHoursAbs = Math.abs(offsetMinutes / 60); const offsetMinsAbs = Math.abs(offsetMinutes % 60); const timezoneString = offsetMinutes === 0 ? 'Z' : `${offsetSign}${String(Math.floor(offsetHoursAbs)).padStart(2, '0')}:${String(offsetMinsAbs).padStart(2, '0')}`; const pad = (num) => String(num).padStart(2, '0'); const localISOString = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}T${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}${timezoneString}`; fmDateInput.value = localISOString;
        } catch (e) { console.error("Error generating default date:", e); fmDateInput.placeholder = 'YYYY-MM-DDTHH:MM:SSZ ÌòïÏãùÏúºÎ°ú ÏßÅÏ†ë ÏûÖÎ†•ÌïòÏÑ∏Ïöî'; }
        currentFileShaInput.value = ''; currentFilePathInput.value = ''; deleteFileButton.disabled = true; saveFileButton.textContent = 'Ï†ÄÏû• (ÏÉùÏÑ±)'; saveFileButton.disabled = false; cancelEditButton.disabled = false; updateCommitMessage(); updateStatus('ÏÉà ÌååÏùº ÏÉùÏÑ± Ï§ÄÎπÑ ÏôÑÎ£å. Title ÏûÖÎ†• Ïãú ÌååÏùºÎ™Ö/Ïª§Î∞ã ÏûêÎèô ÏÉùÏÑ±.');
        showSection(editorSection); // Show editor (will ensure TUI is initialized)
        fmTitleInput.focus();
    });

     saveFileButton.addEventListener('click', async () => {
         if (!octokit) { handleLogout(); return; } if (!selectedOwner || !selectedRepo) { updateStatus("Ïò§Î•ò: Ï†ÄÏû•Ìï† Ï†ÄÏû•ÏÜåÍ∞Ä ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.", true); showSection(repoSection); return; }

         // Get body content from TUI Editor
         let fileBodyContent = '';
         if (tuiEditorInstance) {
             fileBodyContent = tuiEditorInstance.getMarkdown();
         } else {
              updateStatus("Ïò§Î•ò: TUI ÏóêÎîîÌÑ∞ Ïù∏Ïä§ÌÑ¥Ïä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏñ¥ ÎÇ¥Ïö©ÏùÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.", true); return;
         }

         let fileName = fileNameInput.value.trim(); let commitMessage = commitMessageInput.value.trim(); const existingBlobSha = currentFileShaInput.value; const originalFullPath = currentFilePathInput.value; const isUpdateOperation = !!existingBlobSha && !!originalFullPath;
         const titleValue = fmTitleInput.value.trim(); if (!titleValue) { updateStatus("Ïò§Î•ò: Front Matter 'Title'ÏùÄ ÌïÑÏàò Ìï≠Î™©ÏûÖÎãàÎã§.", true); fmTitleInput.focus(); return; }
         if (!fileName) {
             fileName = generateHugoFilename(titleValue); fileNameInput.value = fileName;
             if (!fileName || fileName === '.md') { updateStatus('Ïò§Î•ò: Ï†úÎ™©ÏúºÎ°úÎ∂ÄÌÑ∞ Ïú†Ìö®Ìïú ÌååÏùº Ïù¥Î¶ÑÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§.', true); fileNameInput.focus(); return; }
             updateCommitMessage(); commitMessage = commitMessageInput.value.trim();
         }
         if (fileName.includes('/')) { updateStatus("Ïò§Î•ò: ÌååÏùº Ïù¥Î¶ÑÏóêÎäî Ïä¨ÎûòÏãú('/')Î•º Ìè¨Ìï®Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Í≤ΩÎ°úÎäî ÌååÏùº ÌÉêÏÉâÍ∏∞ÏóêÏÑú ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", true); fileNameInput.focus(); return; }
         if (!fileName.toLowerCase().endsWith('.md')) { fileName += '.md'; fileNameInput.value = fileName; updateStatus("Í≤ΩÍ≥†: ÌååÏùº Ïù¥Î¶ÑÏóê '.md' ÌôïÏû•ÏûêÍ∞Ä ÏûêÎèôÏúºÎ°ú Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.", false); updateCommitMessage(); commitMessage = commitMessageInput.value.trim(); }
         const dateValue = fmDateInput.value.trim(); if (!dateValue) { updateStatus("Ïò§Î•ò: Front Matter 'Date'Îäî ÌïÑÏàò Ìï≠Î™©ÏûÖÎãàÎã§.", true); fmDateInput.focus(); return; }
         if (!/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2})$/i.test(dateValue)) { updateStatus("Ïò§Î•ò: 'Date' ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§ (YYYY-MM-DDTHH:MM:SSZ ÎòêÎäî YYYY-MM-DDTHH:MM:SS+/-HH:MM ÌòïÏãù Í∂åÏû•).", true); fmDateInput.focus(); return; }
         const defaultCreateMsg = `Create ${fileName}`; const defaultUpdateMsg = `Update content for ${fileName}`;
         if (!commitMessage || commitMessage === defaultCreateMsg || commitMessage === defaultUpdateMsg) { updateCommitMessage(); commitMessage = commitMessageInput.value.trim(); }
         if (!commitMessage) { updateStatus("Ïò§Î•ò: Ïª§Î∞ã Î©îÏãúÏßÄÎ•º ÏûÖÎ†•Ìï¥Ïïº Ìï©ÎãàÎã§.", true); commitMessageInput.focus(); return; }

         const fmData = { title: titleValue, author: fmAuthorInput.value.trim(), date: dateValue, description: fmDescriptionInput.value.trim(), tags: fmTagsInput.value.split(',').map(t => t.trim()).filter(t => t), categories: fmCategoriesInput.value.split(',').map(c => c.trim()).filter(c => c), toc: fmTocCheckbox.checked };
         let finalContent; try { finalContent = formatFrontMatter(fmData) + fileBodyContent; } catch (formatError) { updateStatus(`Front Matter ÏÉùÏÑ± Ï§ë Ïò§Î•ò Î∞úÏÉù: ${formatError.message}`, true); return; }

         const targetBasePath = currentPath ? currentPath + '/' : ''; const targetFullPath = targetBasePath + fileName; const isRename = isUpdateOperation && (targetFullPath !== originalFullPath);
         if (isRename) {
              if (!confirm(`ÌååÏùº Ïù¥Î¶Ñ ÎòêÎäî Í≤ΩÎ°úÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.\n\nÍ∏∞Ï°¥ Í≤ΩÎ°ú: '${originalFullPath}'\nÏÉà Í≤ΩÎ°ú: '${targetFullPath}'\n\nÏÉà Í≤ΩÎ°úÏóê ÌååÏùºÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§ (Í∏∞Ï°¥ ÌååÏùºÏùÄ ÏÇ≠Ï†úÎêòÏßÄ ÏïäÏäµÎãàÎã§).\nÍ≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) { updateStatus("Ïù¥Î¶Ñ Î≥ÄÍ≤Ω/ÌååÏùº ÏÉùÏÑ± ÏûëÏóÖÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.", false); return; }
              const oldFilenameOnly = originalFullPath.substring(originalFullPath.lastIndexOf('/') + 1); const defaultRenameCommit = `Create ${fileName} (renamed from ${oldFilenameOnly})`;
              if (commitMessage === `Update content for ${oldFilenameOnly}` || commitMessage === `Update ${oldFilenameOnly}`) { // Check older format too
                  commitMessageInput.value = defaultRenameCommit; commitMessage = defaultRenameCommit;
              }
              updateStatus("ÌååÏùº Ïù¥Î¶Ñ Î≥ÄÍ≤Ω ÌôïÏù∏Îê®. ÏÉà Í≤ΩÎ°úÏóê ÏÉùÏÑ± Ï§ë...", false);
         }
         updateStatus(`'${targetFullPath}' Ï†ÄÏû• Ï§ë...`); saveFileButton.disabled = true; cancelEditButton.disabled = true; deleteFileButton.disabled = true;
         let encodedContent; try { encodedContent = b64EncodeUnicode(finalContent); } catch(encodeError) { updateStatus(`ÌååÏùº ÎÇ¥Ïö© Ïù∏ÏΩîÎî© Ïã§Ìå®: ${encodeError.message}`, true); saveFileButton.disabled = false; cancelEditButton.disabled = false; deleteFileButton.disabled = isUpdateOperation && !isRename; return; }
         try {
             const params = { owner: selectedOwner, repo: selectedRepo, path: targetFullPath, message: commitMessage, content: encodedContent, branch: currentBranch };
             // IMPORTANT: Only include SHA if updating the *same* path
             if (isUpdateOperation && !isRename) {
                 params.sha = existingBlobSha;
             }
             const { data: result } = await octokit.rest.repos.createOrUpdateFileContents(params);
             const action = isUpdateOperation ? (isRename ? 'Ïù¥Î¶Ñ Î≥ÄÍ≤ΩÏúºÎ°ú ÏÉùÏÑ±' : 'ÏàòÏ†ï') : 'ÏÉùÏÑ±';
             updateStatus(`'${targetFullPath}' ${action} ÏôÑÎ£å. Ïª§Î∞ã SHA: ${result?.commit?.sha?.substring(0, 7)}`, false, true);
             clearEditorFields(); showSection(fileBrowserSection);
             const refreshPath = targetBasePath.endsWith('/') ? targetBasePath.slice(0, -1) : targetBasePath; fetchContents(refreshPath || '');
             if (isRename) { alert(`ÌååÏùº '${targetFullPath}' ÏÉùÏÑ±(Ïù¥Î¶Ñ Î≥ÄÍ≤Ω) ÏÑ±Í≥µ.\n\nÏïåÎ¶º: Í∏∞Ï°¥ ÌååÏùº '${originalFullPath}'ÏùÄ(Îäî) ÏÇ≠Ï†úÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ÌïÑÏöîÏãú ÏßÅÏ†ë ÏÇ≠Ï†úÌï¥Ï£ºÏÑ∏Ïöî.`); }
         } catch (error) {
             console.error("Save File Error:", error); let errorMsg = `ÌååÏùº Ï†ÄÏû• Ïã§Ìå® (${targetFullPath}): ${error.message}`;
             if (error.status === 409) { errorMsg = `ÌååÏùº Ï†ÄÏû• Ï∂©Îèå (409): ÌååÏùºÏù¥ ÏÑúÎ≤ÑÏóêÏÑú Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®ÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî.`; }
             else if (error.status === 422) { errorMsg = `ÏûòÎ™ªÎêú ÏöîÏ≤≠ (422): Ïª§Î∞ã Î©îÏãúÏßÄ, Í≤ΩÎ°ú, ÎÇ¥Ïö© ÎòêÎäî SHA(${existingBlobSha})Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§.`; if (isUpdateOperation && !isRename) errorMsg += ` Í∏∞Ï°¥ ÌååÏùº SHAÍ∞Ä Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî.`; }
             else if (error.status === 404 && isUpdateOperation && !isRename) { errorMsg = `ÏóÖÎç∞Ïù¥Ìä∏ ÎåÄÏÉÅ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå (404): ÏõêÎ≥∏ ÌååÏùº '${originalFullPath}' (SHA: ${existingBlobSha})Ïù¥ ÏÇ≠Ï†úÎêòÏóàÍ±∞ÎÇò Í≤ΩÎ°úÍ∞Ä Ïù¥ÎèôÌñàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.`; }
             else if (error.status === 403) { errorMsg = `ÌååÏùº Ï†ÄÏû• Í∂åÌïú Ïò§Î•ò (403): Ïù¥ Ï†ÄÏû•ÏÜå ÎòêÎäî Î∏åÎûúÏπòÏóê Ïì∞Í∏∞ Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.`; }
             else if (error.status === 401) { errorMsg = `GitHub API Ïù∏Ï¶ù Ïò§Î•ò (401): PATÍ∞Ä ÎßåÎ£åÎêòÏóàÍ±∞ÎÇò Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§. Î°úÍ∑∏ÏïÑÏõÉÌï©ÎãàÎã§.`; updateStatus(errorMsg, true); handleLogout(); return; }
             else if (error.message.toLowerCase().includes('empty path')) { errorMsg = `ÌååÏùº Ï†ÄÏû• Ïã§Ìå®: ÌååÏùº Í≤ΩÎ°ú(Ïù¥Î¶Ñ)Í∞Ä ÎπÑÏñ¥ ÏûàÏäµÎãàÎã§. ÌååÏùº Ïù¥Î¶ÑÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.` }
             updateStatus(errorMsg, true); saveFileButton.disabled = false; cancelEditButton.disabled = false; deleteFileButton.disabled = !(isUpdateOperation && !isRename);
         }
     });

    deleteFileButton.addEventListener('click', async () => {
         if (!octokit) { handleLogout(); return; } if (!selectedOwner || !selectedRepo) { updateStatus("Ïò§Î•ò: ÏÇ≠Ï†úÌï† Ï†ÄÏû•ÏÜåÍ∞Ä ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.", true); showSection(repoSection); return; }
        const filePathToDelete = currentFilePathInput.value; const fileShaToDelete = currentFileShaInput.value; const filenameOnly = filePathToDelete ? filePathToDelete.substring(filePathToDelete.lastIndexOf('/') + 1) : 'Ïïå Ïàò ÏóÜÎäî ÌååÏùº';
        if (!filePathToDelete || !fileShaToDelete) { updateStatus("Ïò§Î•ò: ÏÇ≠Ï†úÌï† ÌååÏùºÏùò Í≤ΩÎ°ú ÎòêÎäî SHA Ï†ïÎ≥¥Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§. ÌååÏùºÏùÑ Îã§Ïãú Î°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.", true); return; }
        if (!confirm(`Ï†ïÎßêÎ°ú '${filenameOnly}' ÌååÏùºÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?\nÏù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§!`)) { updateStatus("ÌååÏùº ÏÇ≠Ï†ú ÏûëÏóÖÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.", false); return; }
        let commitMessage = commitMessageInput.value.trim();
        if (!commitMessage || commitMessage.toLowerCase().startsWith('update ') || commitMessage.toLowerCase().startsWith('create ') || commitMessage.toLowerCase().startsWith('rename/create ')) { commitMessage = `Delete ${filenameOnly}`; commitMessageInput.value = commitMessage; }
         if (!commitMessage) { updateStatus("Ïò§Î•ò: ÏÇ≠Ï†ú ÏûëÏóÖÏùÑ ÏúÑÌïú Ïª§Î∞ã Î©îÏãúÏßÄÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.", true); commitMessageInput.focus(); return; }
        updateStatus(`'${filePathToDelete}' ÏÇ≠Ï†ú Ï§ë...`); saveFileButton.disabled = true; cancelEditButton.disabled = true; deleteFileButton.disabled = true;
        try {
            await octokit.rest.repos.deleteFile({ owner: selectedOwner, repo: selectedRepo, path: filePathToDelete, message: commitMessage, sha: fileShaToDelete, branch: currentBranch });
            updateStatus(`'${filePathToDelete}' ÏÇ≠Ï†ú ÏôÑÎ£å.`, false, true); clearEditorFields(); showSection(fileBrowserSection);
            const parentDir = filePathToDelete.includes('/') ? filePathToDelete.substring(0, filePathToDelete.lastIndexOf('/')) : ''; fetchContents(parentDir);
        } catch (error) {
            console.error("Delete File Error:", error); let errorMsg = `ÌååÏùº ÏÇ≠Ï†ú Ïã§Ìå® (${filePathToDelete}): ${error.message}`;
             if (error.status === 404) { errorMsg = `ÏÇ≠Ï†úÌï† ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå (404) ÎòêÎäî ÌååÏùº ÎÇ¥Ïö©Ïù¥ Î≥ÄÍ≤ΩÎê® (SHA: ${fileShaToDelete}). ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®ÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî.`; }
             else if (error.status === 409) { errorMsg = `ÏÇ≠Ï†ú Ï§ë Ï∂©Îèå Î∞úÏÉù (409). Îã§Î•∏ Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ ÏûàÏóàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.`; }
             else if (error.status === 422) { errorMsg = `ÏûòÎ™ªÎêú ÏöîÏ≤≠ (422): ÏÇ≠Ï†úÏóê ÌïÑÏöîÌïú Ï†ïÎ≥¥ (Í≤ΩÎ°ú, SHA Îì±)Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§.`; }
             else if (error.status === 403) { errorMsg = `ÌååÏùº ÏÇ≠Ï†ú Í∂åÌïú Ïò§Î•ò (403): Ïù¥ Ï†ÄÏû•ÏÜå ÎòêÎäî Î∏åÎûúÏπòÏóê ÏÇ≠Ï†ú Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.`; }
             else if (error.status === 401) { errorMsg = `GitHub API Ïù∏Ï¶ù Ïò§Î•ò (401): PATÍ∞Ä ÎßåÎ£åÎêòÏóàÍ±∞ÎÇò Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§. Î°úÍ∑∏ÏïÑÏõÉÌï©ÎãàÎã§.`; updateStatus(errorMsg, true); handleLogout(); return; }
            updateStatus(errorMsg, true); saveFileButton.disabled = true; cancelEditButton.disabled = false; deleteFileButton.disabled = (error.status === 404);
        }
    });

    cancelEditButton.addEventListener('click', () => {
        if (!octokit) { resetToLoginScreen(); return; }
        const isNewFile = !currentFileShaInput.value && !currentFilePathInput.value;
        let hasUnsavedContent = false;
         // Check TUI Editor content along with title/filename
         if (tuiEditorInstance) {
             const editorContent = tuiEditorInstance.getMarkdown().trim();
             hasUnsavedContent = isNewFile
                ? (fmTitleInput.value.trim() || editorContent || fileNameInput.value.trim())
                : (fmTitleInput.value.trim() || editorContent); // Simpler check for existing files, focus on title/body
                 // Add more checks if needed, e.g., compare original content if stored
         } else {
             // Fallback check if editor isn't available
             hasUnsavedContent = isNewFile
                ? (fmTitleInput.value.trim() || fileNameInput.value.trim())
                : (fmTitleInput.value.trim());
         }
        let confirmed = true; if (hasUnsavedContent) { confirmed = confirm("Ìé∏Ïßë Ï§ëÏù∏ ÎÇ¥Ïö©Ïù¥ ÏûàÏäµÎãàÎã§. Ï†ÄÏû•ÌïòÏßÄ ÏïäÍ≥† Ï∑®ÏÜåÌïòÏãúÍ≤†ÏäµÎãàÍπå?"); }
        if (confirmed) { clearEditorFields(); updateStatus('Ìé∏Ïßë ÏûëÏóÖ Ï∑®ÏÜåÎê®.'); showSection(fileBrowserSection); }
        else { updateStatus('Ï∑®ÏÜå ÏûëÏóÖ Ï§ëÎã®Îê®.'); }
    });

    // --- Input Event Listeners (Auto-generate filename/commit msg) ---
     fmTitleInput.addEventListener('input', () => {
         const title = fmTitleInput.value; const isNewFile = !currentFileShaInput.value; const currentFilename = fileNameInput.value.trim();
         // Only auto-generate if new file OR filename is empty
         if (isNewFile || !currentFilename) {
             if (title.trim()) { fileNameInput.value = generateHugoFilename(title); }
             else { fileNameInput.value = ''; } // Clear filename if title is cleared
         }
         updateCommitMessage(); // Update commit msg whenever title changes
    });
    // Update commit message if filename is manually changed
    fileNameInput.addEventListener('input', updateCommitMessage);

    // --- Application Initialization ---
    function initializeApp() {
        console.log("Initializing GitHub Editor...");
        clearEditorFields(); // Clears form fields and attempts to clear TUI Editor if initialized
        logoutButton.classList.add('hidden');
        const storedPat = localStorage.getItem(PAT_STORAGE_KEY);
        if (storedPat) {
            console.log("Stored PAT found. Attempting auto-login...");
            patInput.value = '********'; patInput.disabled = true; loginButton.disabled = true; loginButton.textContent = 'ÏûêÎèô Î°úÍ∑∏Ïù∏ Ï§ë...';
            authenticateAndLoadRepos(storedPat, true);
        } else {
            console.log("No stored PAT found. Displaying login screen.");
            resetToLoginScreen();
            updateStatus('ÏãúÏûë: GitHub Personal Access Token (PAT)Î•º ÏûÖÎ†•ÌïòÍ≥† Î°úÍ∑∏Ïù∏ÌïòÏÑ∏Ïöî.');
        }
        // TUI Editor is initialized lazily when the editor section is shown
    }

    // --- Storage Event Listener ---
    window.addEventListener('storage', (event) => {
        if (event.key === PAT_STORAGE_KEY) {
            if (event.newValue === null && octokit) {
                console.log('Logout detected from another tab via storage event.');
                updateStatus('Îã§Î•∏ ÌÉ≠ ÎòêÎäî Ï∞ΩÏóêÏÑú Î°úÍ∑∏ÏïÑÏõÉÎêòÏóàÏäµÎãàÎã§. Ïù¥ Ï∞ΩÎèÑ Î°úÍ∑∏ÏïÑÏõÉÎê©ÎãàÎã§.', false);
                 setTimeout(handleLogout, 1500);
            }
        }
    });

    // Start the application
    initializeApp();

</script>

</body>
</html>