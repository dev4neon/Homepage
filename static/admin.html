<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub 파일 에디터 (PAT)</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        .container { max-width: 900px; margin: auto; }
        .section { margin-bottom: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], input[type="password"], select, textarea {
            width: calc(100% - 22px); /* Adjust for padding */
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        textarea { height: 300px; font-family: monospace; }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #fileList ul { list-style: none; padding: 0; }
        #fileList li { padding: 5px 0; border-bottom: 1px solid #eee; cursor: pointer; }
        #fileList li:hover { background-color: #f0f0f0; }
        #fileList li.dir::before { content: '📁 '; }
        #fileList li.file::before { content: '📄 '; }
        #statusBar { margin-top: 15px; color: #555; font-style: italic; }
        .hidden { display: none; }
        .error { color: red; font-weight: bold; }
        .breadcrumb a { text-decoration: none; color: #007bff; }
        .breadcrumb a:hover { text-decoration: underline; }
        .breadcrumb span { margin: 0 5px; color: #888; }
    </style>
</head>
<body>

<div class="container">
    <h1>GitHub 파일 에디터 (PAT 사용)</h1>

    <!-- 1. Login Section -->
    <div id="loginSection" class="section">
        <h2>1. GitHub 로그인</h2>
        <p class="error"><strong>경고:</strong> Personal Access Token을 브라우저에 입력하는 것은 보안상 위험합니다. 개인적인 용도로만 사용하고 토큰 관리에 유의하세요.</p>
        <label for="patInput">Personal Access Token (PAT):</label>
        <input type="password" id="patInput" placeholder="repo 권한이 있는 PAT 입력">
        <button id="loginButton">저장소 목록 불러오기</button>
    </div>

    <!-- 2. Repository Selection -->
    <div id="repoSection" class="section hidden">
        <h2>2. 저장소 선택</h2>
        <label for="repoSelect">저장소:</label>
        <select id="repoSelect"></select>
        <button id="loadRepoButton" disabled>파일 목록 불러오기</button>
    </div>

    <!-- 3. File Browser -->
    <div id="fileBrowserSection" class="section hidden">
        <h2>3. 파일 탐색기</h2>
        <div><strong>현재 저장소:</strong> <span id="currentRepo"></span></div>
        <div class="breadcrumb"><strong>경로:</strong> <span id="currentPathBreadcrumb">/</span></div>
        <div id="fileList">
            <ul></ul>
        </div>
        <button id="createNewFileButton">새 파일 만들기</button>
    </div>

    <!-- 4. File Editor -->
    <div id="editorSection" class="section hidden">
        <h2>4. 파일 편집기</h2>
        <input type="hidden" id="currentFileSha">
        <input type="hidden" id="currentFilePathInput">

        <label for="fileNameInput">파일 경로 (현재 폴더 기준):</label>
        <input type="text" id="fileNameInput" placeholder="예: new-file.md">

        <label for="fileContentInput">파일 내용:</label>
        <textarea id="fileContentInput"></textarea>

        <label for="commitMessageInput">커밋 메시지:</label>
        <input type="text" id="commitMessageInput" placeholder="예: 파일 생성 또는 수정">

        <button id="saveFileButton">저장 (생성/수정)</button>
        <button id="deleteFileButton">삭제</button>
        <button id="cancelEditButton">취소</button>
    </div>

    <!-- Status Bar -->
    <div id="statusBar">상태: 대기 중...</div>

</div>

<script>
    const GITHUB_API_BASE = 'https://api.github.com';
    let githubToken = null;
    let selectedOwner = null;
    let selectedRepo = null;
    let currentPath = ''; // 현재 탐색 중인 경로
    let currentFiles = []; // 현재 경로의 파일/폴더 목록 캐시

    // --- DOM Elements ---
    const patInput = document.getElementById('patInput');
    const loginButton = document.getElementById('loginButton');
    const repoSelect = document.getElementById('repoSelect');
    const loadRepoButton = document.getElementById('loadRepoButton');
    const fileListUl = document.querySelector('#fileList ul');
    const currentRepoSpan = document.getElementById('currentRepo');
    const currentPathBreadcrumb = document.getElementById('currentPathBreadcrumb');
    const fileNameInput = document.getElementById('fileNameInput');
    const fileContentInput = document.getElementById('fileContentInput');
    const commitMessageInput = document.getElementById('commitMessageInput');
    const currentFileShaInput = document.getElementById('currentFileSha');
    const currentFilePathInput = document.getElementById('currentFilePathInput');
    const saveFileButton = document.getElementById('saveFileButton');
    const deleteFileButton = document.getElementById('deleteFileButton');
    const cancelEditButton = document.getElementById('cancelEditButton');
    const createNewFileButton = document.getElementById('createNewFileButton');
    const statusBar = document.getElementById('statusBar');

    // --- Sections ---
    const loginSection = document.getElementById('loginSection');
    const repoSection = document.getElementById('repoSection');
    const fileBrowserSection = document.getElementById('fileBrowserSection');
    const editorSection = document.getElementById('editorSection');

    // --- Helper Functions ---
    function updateStatus(message, isError = false) {
        statusBar.textContent = `상태: ${message}`;
        statusBar.className = isError ? 'error' : '';
        console.log(message);
    }

    function showSection(sectionToShow) {
        [loginSection, repoSection, fileBrowserSection, editorSection].forEach(section => {
            section.classList.add('hidden');
        });
        if (sectionToShow) {
            sectionToShow.classList.remove('hidden');
        }
    }

    async function githubApiRequest(endpoint, options = {}) {
        if (!githubToken) {
            throw new Error('GitHub PAT가 설정되지 않았습니다.');
        }

        const url = endpoint.startsWith('http') ? endpoint : `${GITHUB_API_BASE}${endpoint}`;
        const headers = {
            'Authorization': `Bearer ${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            ...options.headers,
        };

        // POST, PUT, DELETE 요청 시 Content-Type 설정
        if (options.method && ['POST', 'PUT', 'DELETE'].includes(options.method.toUpperCase()) && options.body) {
            headers['Content-Type'] = 'application/json';
        }

        updateStatus('GitHub API 요청 중...');
        try {
            const response = await fetch(url, { ...options, headers });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: '알 수 없는 오류' }));
                // PAT가 유효하지 않거나 권한이 없을 때 (401 Unauthorized) 사용자에게 피드백
                if (response.status === 401) {
                     throw new Error(`GitHub API 인증 오류 (${response.status}): PAT가 유효하지 않거나 필요한 권한(repo)이 없습니다.`);
                }
                throw new Error(`GitHub API 오류 (${response.status}): ${errorData.message || response.statusText}`);
            }
             // DELETE 요청은 내용이 없을 수 있음
            if (response.status === 204 || response.headers.get('Content-Length') === '0') {
                 updateStatus('GitHub API 요청 성공.');
                 return null; // No content
            }
            const data = await response.json();
            updateStatus('GitHub API 요청 성공.');
            return data;
        } catch (error) {
            updateStatus(`오류: ${error.message}`, true);
            // 인증 오류 시 로그인 버튼 활성화하여 재시도 유도
            if (error.message.includes('인증 오류')) {
                patInput.disabled = false;
                loginButton.disabled = false;
                showSection(loginSection); // 로그인 섹션으로 되돌림
            }
            throw error; // Re-throw for further handling
        }
    }

    // Base64 인코딩/디코딩 (UTF-8 지원)
    function b64EncodeUnicode(str) {
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
            return String.fromCharCode('0x' + p1);
        }));
    }

    function b64DecodeUnicode(str) {
        // 먼저 atob로 디코딩 시도
        let decoded_string;
        try {
             decoded_string = atob(str);
        } catch (e) {
             console.error("Base64 디코딩 실패 (atob):", e);
             // 디코딩 실패 시 원본 문자열이나 빈 문자열 반환, 혹은 오류 처리
             updateStatus('Base64 디코딩 중 오류 발생. 파일 내용이 손상되었을 수 있습니다.', true);
             return "[디코딩 오류]"; // 사용자에게 오류 표시
        }

        // UTF-8 변환 시도
        try {
            return decodeURIComponent(decoded_string.split('').map(function(c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
        } catch (e) {
             console.error("UTF-8 디코딩 실패:", e);
             updateStatus('UTF-8 디코딩 중 오류 발생. 파일이 UTF-8이 아닐 수 있습니다.', true);
             // UTF-8 변환 실패 시 atob 결과라도 반환 (깨질 수 있음)
             return decoded_string;
        }
    }


    // 경로 Breadcrumb 생성
    function updateBreadcrumb() {
        currentPathBreadcrumb.innerHTML = ''; // Clear existing
        const pathParts = currentPath.split('/').filter(p => p); // 빈 요소 제거
        const rootLink = document.createElement('a');
        rootLink.href = '#';
        rootLink.textContent = '/';
        rootLink.onclick = (e) => { e.preventDefault(); fetchContents(''); };
        currentPathBreadcrumb.appendChild(rootLink);

        let accumulatedPath = '';
        pathParts.forEach((part, index) => {
            accumulatedPath += (accumulatedPath ? '/' : '') + part;
            const pathSpan = document.createElement('span');
            pathSpan.textContent = '>';
            currentPathBreadcrumb.appendChild(pathSpan);

            const partLink = document.createElement('a');
            partLink.href = '#';
            partLink.textContent = part;
            // 클로저를 사용하여 올바른 경로 전달
            const currentAccumulatedPath = accumulatedPath;
            partLink.onclick = (e) => { e.preventDefault(); fetchContents(currentAccumulatedPath); };
            currentPathBreadcrumb.appendChild(partLink);
        });
         // 마지막에 슬래시 추가 (루트가 아닐 경우)
        if (currentPath) {
             const trailingSlash = document.createElement('span');
             trailingSlash.textContent = '/';
             currentPathBreadcrumb.appendChild(trailingSlash);
        }
    }


    // --- Event Handlers ---

    // 1. Login
    loginButton.addEventListener('click', async () => {
        githubToken = patInput.value.trim();
        if (!githubToken) {
            updateStatus('PAT를 입력해주세요.', true);
            return;
        }
        patInput.disabled = true;
        loginButton.disabled = true;
        loadRepoButton.disabled = true; // 로딩 중에는 비활성화
        updateStatus('저장소 목록 로딩 중...');
        try {
            // /user/repos 는 인증된 사용자의 모든 저장소를 가져옵니다.
            // 페이지네이션을 고려하여 최대 100개까지 요청 (필요시 반복 요청 구현)
            // sort=updated: 최근 업데이트된 저장소 순으로 정렬 (더 관련성 높을 수 있음)
            const repos = await githubApiRequest('/user/repos?per_page=100&sort=updated');

            repoSelect.innerHTML = '<option value="">-- 저장소 선택 --</option>'; // Clear previous options

            if (repos && repos.length > 0) {
                 repos.forEach(repo => {
                    const option = document.createElement('option');
                    option.value = `${repo.owner.login}/${repo.name}`;
                    option.textContent = repo.full_name;
                    repoSelect.appendChild(option);
                });

                // --- 수정된 부분 ---
                // 첫 번째 저장소를 기본으로 선택
                repoSelect.selectedIndex = 1;
                // 첫 번째 저장소가 선택되었으므로 '파일 목록 불러오기' 버튼 활성화
                loadRepoButton.disabled = false;
                // --- 수정 끝 ---

                updateStatus(`${repos.length}개의 저장소 목록 로드 완료.`);

            } else {
                updateStatus('접근 가능한 저장소가 없거나 로드에 실패했습니다.', true);
                // 저장소가 없으면 '파일 목록 불러오기' 버튼 비활성화 유지
                loadRepoButton.disabled = true;
            }

            showSection(repoSection); // 저장소 선택 섹션 표시
            repoSection.classList.remove('hidden');

        } catch (error) {
            // githubApiRequest 함수 내에서 이미 상태 업데이트 및 오류 처리가 이루어짐
            // 추가적인 UI 복구 로직이 필요하다면 여기에 작성 (예: 로그인 버튼 재활성화)
            // patInput.disabled = false; // githubApiRequest에서 처리하도록 변경
            // loginButton.disabled = false; // githubApiRequest에서 처리하도록 변경
        }
    });

    // 2. Repository Selection
    repoSelect.addEventListener('change', () => {
        // '-- 저장소 선택 --'이 아니면 버튼 활성화, 그렇지 않으면 비활성화
        loadRepoButton.disabled = repoSelect.value === '';
    });

    loadRepoButton.addEventListener('click', () => {
        const selectedRepoFullName = repoSelect.value;
        if (!selectedRepoFullName) return;

        [selectedOwner, selectedRepo] = selectedRepoFullName.split('/');
        currentRepoSpan.textContent = selectedRepoFullName;
        updateStatus(`'${selectedRepoFullName}' 저장소 파일 목록 로딩...`);
        showSection(fileBrowserSection); // Show file browser
        fetchContents(''); // Load root directory
    });

    // 3. Fetch Repository Contents (Files/Folders)
    async function fetchContents(path) {
        currentPath = path;
        updateBreadcrumb(); // Update breadcrumb based on the new path
        fileListUl.innerHTML = ''; // Clear previous list
        updateStatus(`'${selectedOwner}/${selectedRepo}/${path}' 로딩 중...`);
        showSection(fileBrowserSection); // Make sure browser is visible

        try {
            // 경로가 비어 있으면 루트를 의미, API 요청 시 슬래시 제거
            const requestPath = path ? path : '';
            const contents = await githubApiRequest(`/repos/${selectedOwner}/${selectedRepo}/contents/${requestPath}`);
            currentFiles = contents.sort((a, b) => { // Sort: folders first, then by name
                if (a.type === b.type) {
                    return a.name.localeCompare(b.name);
                }
                return a.type === 'dir' ? -1 : 1;
            });

            // Add '..' (Up directory) link if not in root
            if (path !== '') {
                const parentPath = path.includes('/') ? path.substring(0, path.lastIndexOf('/')) : ''; // 루트로 갈 경우 빈 문자열
                const li = document.createElement('li');
                li.textContent = '⬆️ .. (상위 폴더)';
                li.style.cursor = 'pointer';
                li.style.fontWeight = 'bold';
                li.onclick = () => fetchContents(parentPath);
                fileListUl.appendChild(li);
            }

            // Populate file/directory list
            if (currentFiles.length > 0) {
                currentFiles.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item.name;
                    li.classList.add(item.type); // Add 'dir' or 'file' class
                    li.dataset.path = item.path;
                    li.dataset.type = item.type;
                    li.dataset.sha = item.sha; // Store sha for later use (especially for files)

                    if (item.type === 'dir') {
                        li.onclick = () => fetchContents(item.path);
                    } else if (item.type === 'file') {
                        li.onclick = () => fetchFileContent(item.path, item.sha);
                    }
                    fileListUl.appendChild(li);
                });
             } else {
                 const li = document.createElement('li');
                 li.textContent = '(폴더가 비어 있습니다)';
                 li.style.fontStyle = 'italic';
                 li.style.color = '#888';
                 fileListUl.appendChild(li);
             }
             updateStatus(`'${selectedOwner}/${selectedRepo}/${path || '/'}' 로드 완료.`);
        } catch (error) {
            updateStatus(`파일 목록 로딩 실패 (${path || '/'}): ${error.message}`, true);
            // Optionally show the browser section even on error to allow navigation back
            showSection(fileBrowserSection);
        }
    }

    // 4. Fetch File Content
    async function fetchFileContent(filePath, fileSha) {
        updateStatus(`'${filePath}' 파일 내용 로딩 중...`);
        showSection(null); // 로딩 중에는 잠시 섹션 숨김 (선택 사항)
        try {
            const fileData = await githubApiRequest(`/repos/${selectedOwner}/${selectedRepo}/contents/${filePath}`);

            if (fileData.type !== 'file') {
                 throw new Error('요청한 경로는 파일이 아닙니다.');
            }
            if (fileData.encoding !== 'base64') {
                // GitHub API는 큰 파일의 경우 content를 포함하지 않을 수 있음
                if (fileData.content === undefined && fileData.download_url) {
                     updateStatus(`파일이 너무 커서 직접 로드할 수 없습니다. (${fileData.size} bytes)`, true);
                     // 에디터 대신 다운로드 링크를 보여주거나 다른 처리
                     showSection(fileBrowserSection); // 브라우저로 복귀
                     alert(`파일이 너무 커서(${fileData.size} bytes) 에디터로 열 수 없습니다.\n다운로드 URL: ${fileData.download_url}`);
                     return; // 함수 종료
                } else {
                    throw new Error('지원하지 않는 인코딩입니다: ' + fileData.encoding);
                }
            }
            if (fileData.content === undefined || fileData.sha === undefined) {
                 throw new Error('API 응답에 content 또는 sha가 없습니다.');
            }

            const decodedContent = b64DecodeUnicode(fileData.content);

            // Populate editor
            fileNameInput.value = filePath.substring(filePath.lastIndexOf('/') + 1); // Extract filename
            fileContentInput.value = decodedContent;
            commitMessageInput.value = `Update ${fileNameInput.value}`; // Default commit message
            currentFileShaInput.value = fileData.sha; // Store SHA for update/delete
            currentFilePathInput.value = filePath; // Store full path

            // Enable/disable delete button based on whether it's an existing file
            deleteFileButton.disabled = false;
            saveFileButton.textContent = '저장 (수정)';
            saveFileButton.disabled = false; // 저장 버튼 활성화
            cancelEditButton.disabled = false; // 취소 버튼 활성화

            updateStatus(`'${filePath}' 로드 완료.`);
            showSection(editorSection); // Show editor

        } catch (error) {
            updateStatus(`파일 내용 로딩 실패 (${filePath}): ${error.message}`, true);
            showSection(fileBrowserSection); // Go back to browser on error
        }
    }

    // 5. Show Create New File Form
    createNewFileButton.addEventListener('click', () => {
        fileNameInput.value = '';
        fileContentInput.value = '';
        commitMessageInput.value = 'Create new file';
        currentFileShaInput.value = ''; // No SHA for new file
        currentFilePathInput.value = ''; // Path will be constructed on save

        deleteFileButton.disabled = true; // Cannot delete a new file
        saveFileButton.textContent = '저장 (생성)';
        saveFileButton.disabled = false; // 저장 버튼 활성화
        cancelEditButton.disabled = false; // 취소 버튼 활성화


        updateStatus('새 파일 생성 준비 완료.');
        showSection(editorSection);
        fileNameInput.focus();
    });


    // 6. Save File (Create or Update)
    saveFileButton.addEventListener('click', async () => {
        const fileName = fileNameInput.value.trim();
        const fileContent = fileContentInput.value;
        let commitMessage = commitMessageInput.value.trim();
        const existingSha = currentFileShaInput.value; // SHA for updates
        const isUpdate = !!existingSha;
        // 파일 이름을 기준으로 할 지, currentFilePathInput 기준으로 할지 명확히 함
        // 여기서는 에디터의 파일 이름 입력값을 기준으로 새 경로 생성
        const targetFileName = fileName; // 사용자가 입력한 이름 사용
        // 수정일 경우 원래 경로에서 파일 이름만 변경될 수도 있으므로, 현재 경로(currentPath)를 기준으로 함
        let fullPath;

        if (!targetFileName) {
            updateStatus('파일 이름을 입력해주세요.', true);
            fileNameInput.focus();
            return;
        }

        // 파일 이름에 슬래시 포함 여부 확인 (하위 폴더 생성 방지 또는 명시적 허용 필요)
        if (targetFileName.includes('/')) {
             updateStatus("파일 이름에 슬래시('/')를 포함할 수 없습니다.", true);
             fileNameInput.focus();
             return;
        }


        if (isUpdate) {
            // 수정 시에는 원본 파일의 경로를 사용해야 함
            fullPath = currentFilePathInput.value;
             // 사용자가 파일 이름을 변경했는지 확인 (필수는 아님, UX 개선 가능)
            const originalFileName = fullPath.substring(fullPath.lastIndexOf('/') + 1);
            if (targetFileName !== originalFileName) {
                // 파일 이름 변경은 '이동'으로 간주될 수 있어 복잡함. 여기서는 단순 업데이트만 지원.
                 // 필요하다면 이름 변경 로직 추가 (삭제 후 생성 or Move API)
                if (!confirm(`파일 이름을 '${originalFileName}'에서 '${targetFileName}'(으)로 변경하시겠습니까? 이는 새 파일을 생성하고 이전 파일을 삭제하는 것과 유사하게 동작할 수 있습니다.`)) {
                     fileNameInput.value = originalFileName; // 원래 이름으로 복원
                     return; // 취소
                }
                 // 실제 이름 변경 로직은 GitHub API에 Move 기능이 없으므로,
                 // 여기서는 새 이름으로 '생성(PUT)'만 시도합니다.
                 // GitHub는 동일 SHA가 아니면 덮어쓰기로 처리할 것입니다.
                 // 만약 이동(rename)을 정확히 구현하려면 delete 후 create 필요.
                 // 여기서는 일단 PUT 요청으로 처리하고, 커밋 메시지에 반영 고려.
                 commitMessage = commitMessage || `Rename ${originalFileName} to ${targetFileName} and update content`;
                 // fullPath는 *현재* 저장하려는 경로. 여기서는 파일 이름만 변경된 상태로 사용
                 const basePath = currentPath ? currentPath + '/' : '';
                 fullPath = basePath + targetFileName;
                 // 중요: 이 경우 sha를 보내면 안될 수도 있음(새 파일 생성으로 간주). API 테스트 필요.
                 // 안전하게 하려면 isUpdate를 false로 취급하거나, 명시적 Rename 지원 필요.
                 // 여기서는 일단 기존 로직(sha 포함 PUT) 유지하나, 실패 가능성 인지.
                 // Update: GitHub PUT contents API는 경로 변경 시 자동으로 이동(rename) 처리함. SHA 필요.
                 console.warn("파일 이름 변경 시도:", originalFileName, "->", targetFileName);
            }

        } else {
            // 생성 시에는 현재 폴더(currentPath)에 새 파일 이름 결합
            fullPath = (currentPath ? currentPath + '/' : '') + targetFileName;
        }


        if (!commitMessage) {
            commitMessage = isUpdate ? `Update ${targetFileName}` : `Create ${targetFileName}`;
        }

        updateStatus(`'${fullPath}' 저장 중...`);
        saveFileButton.disabled = true;
        cancelEditButton.disabled = true;
        deleteFileButton.disabled = true;

        try {
            const encodedContent = b64EncodeUnicode(fileContent);
            const body = {
                message: commitMessage,
                content: encodedContent,
                branch: 'main' // TODO: 브랜치 선택 기능 추가
            };

            // 수정(Update)일 경우에만 SHA 추가
            if (isUpdate) {
                 // 파일 경로가 에디터 로드 시점과 다른지 최종 확인 (이름 변경 케이스는 위에서 처리)
                 if (currentFilePathInput.value !== fullPath && fileNameInput.value === fullPath.substring(fullPath.lastIndexOf('/') + 1)) {
                    // 경로 자체는 동일한데, currentFilePathInput이 다른 경우? -> 로직 오류 가능성
                    console.error("Internal state mismatch: currentFilePathInput vs constructed fullPath");
                    // throw new Error("내부 상태 오류 발생. 페이지를 새로고침하고 다시 시도하세요.");
                    // 일단 진행하되 경고 남김
                 }
                body.sha = existingSha;
            }

            // API 요청 (생성/수정 모두 PUT 사용)
            const result = await githubApiRequest(`/repos/${selectedOwner}/${selectedRepo}/contents/${fullPath}`, {
                method: 'PUT',
                body: JSON.stringify(body)
            });

            updateStatus(`'${fullPath}' ${isUpdate ? '수정' : '생성'} 완료.`);
            // 저장 성공 시 파일 브라우저로 돌아가서 현재 경로 새로고침
            fetchContents(currentPath); // 저장된 파일이 있는 폴더 새로고침

        } catch (error) {
            updateStatus(`파일 저장 실패 (${fullPath}): ${error.message}`, true);
            // 실패 시 버튼 다시 활성화 (삭제 버튼은 원래 상태 따라감)
            saveFileButton.disabled = false;
            cancelEditButton.disabled = false;
            deleteFileButton.disabled = !isUpdate; // 수정 중이었을 때만 삭제 버튼 활성화
        }
        // finally 블록 불필요 (성공/실패 모두 처리됨)
    });

    // 7. Delete File
    deleteFileButton.addEventListener('click', async () => {
        const filePathToDelete = currentFilePathInput.value;
        const fileShaToDelete = currentFileShaInput.value;

        if (!filePathToDelete || !fileShaToDelete) {
            updateStatus('삭제할 파일 정보가 올바르지 않습니다.', true);
            return;
        }

        if (!confirm(`정말로 '${filePathToDelete}' 파일을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.`)) {
            return;
        }

        let commitMessage = commitMessageInput.value.trim();
         // 커밋 메시지가 비어있거나, 'update' 관련 메시지이면 기본 삭제 메시지로 변경
         if (!commitMessage || commitMessage.toLowerCase().startsWith('update')) {
             commitMessage = `Delete ${filePathToDelete.substring(filePathToDelete.lastIndexOf('/') + 1)}`;
         }


        updateStatus(`'${filePathToDelete}' 삭제 중...`);
        saveFileButton.disabled = true;
        cancelEditButton.disabled = true;
        deleteFileButton.disabled = true;

        try {
            await githubApiRequest(`/repos/${selectedOwner}/${selectedRepo}/contents/${filePathToDelete}`, {
                method: 'DELETE',
                body: JSON.stringify({
                    message: commitMessage,
                    sha: fileShaToDelete,
                    branch: 'main' // TODO: 브랜치 선택 기능 추가
                })
            });

            updateStatus(`'${filePathToDelete}' 삭제 완료.`);
            // 삭제 성공 시 파일 브라우저로 돌아가서 현재 경로 새로고침
            fetchContents(currentPath); // 파일이 삭제된 폴더 새로고침

        } catch (error) {
            updateStatus(`파일 삭제 실패 (${filePathToDelete}): ${error.message}`, true);
             // 실패 시 버튼 다시 활성화 (삭제 버튼 포함)
            saveFileButton.disabled = false;
            cancelEditButton.disabled = false;
            deleteFileButton.disabled = false; // 삭제 실패 시 다시 시도 가능하도록 활성화
        }
    });

    // 8. Cancel Edit
    cancelEditButton.addEventListener('click', () => {
        updateStatus('편집 취소됨.');
        // 에디터 내용 초기화하고 파일 브라우저 섹션 표시
        fileNameInput.value = '';
        fileContentInput.value = '';
        commitMessageInput.value = '';
        currentFileShaInput.value = '';
        currentFilePathInput.value = '';
        showSection(fileBrowserSection);
        // 브라우저 내용을 다시 로드할 필요는 없음 (변경사항 없었음)
    });


    // --- Initial State ---
    showSection(loginSection); // Start with login section
    updateStatus('시작: GitHub PAT를 입력하세요.');

</script>

</body>
</html>