<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub 파일 에디터 (PAT)</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        .container { max-width: 900px; margin: auto; }
        .section { margin-bottom: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], input[type="password"], select, textarea {
            width: calc(100% - 22px); /* Adjust for padding */
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        textarea { height: 300px; font-family: monospace; }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #fileList ul { list-style: none; padding: 0; }
        #fileList li { padding: 5px 0; border-bottom: 1px solid #eee; cursor: pointer; }
        #fileList li:hover { background-color: #f0f0f0; }
        #fileList li.dir::before { content: '📁 '; }
        #fileList li.file::before { content: '📄 '; }
        #statusBar { margin-top: 15px; color: #555; font-style: italic; }
        .hidden { display: none; }
        .error { color: red; font-weight: bold; }
        .breadcrumb a { text-decoration: none; color: #007bff; }
        .breadcrumb a:hover { text-decoration: underline; }
        .breadcrumb span { margin: 0 5px; color: #888; }
    </style>
</head>
<body>

<div class="container">
    <h1>GitHub 파일 에디터 (PAT 사용)</h1>

    <!-- 1. Login Section -->
    <div id="loginSection" class="section">
        <h2>1. GitHub 로그인</h2>
        <p class="error"><strong>경고:</strong> Personal Access Token을 브라우저에 입력하는 것은 보안상 위험합니다. 개인적인 용도로만 사용하고 토큰 관리에 유의하세요.</p>
        <label for="patInput">Personal Access Token (PAT):</label>
        <input type="password" id="patInput" placeholder="repo 권한이 있는 PAT 입력">
        <button id="loginButton">저장소 목록 불러오기</button>
    </div>

    <!-- 2. Repository Selection -->
    <div id="repoSection" class="section hidden">
        <h2>2. 저장소 선택</h2>
        <label for="repoSelect">저장소:</label>
        <select id="repoSelect"></select>
        <button id="loadRepoButton" disabled>파일 목록 불러오기</button>
    </div>

    <!-- 3. File Browser -->
    <div id="fileBrowserSection" class="section hidden">
        <h2>3. 파일 탐색기</h2>
        <div><strong>현재 저장소:</strong> <span id="currentRepo"></span></div>
        <div class="breadcrumb"><strong>경로:</strong> <span id="currentPathBreadcrumb">/</span></div>
        <div id="fileList">
            <ul></ul>
        </div>
        <button id="createNewFileButton">새 파일 만들기</button>
    </div>

    <!-- 4. File Editor -->
    <div id="editorSection" class="section hidden">
        <h2>4. 파일 편집기</h2>
        <input type="hidden" id="currentFileSha">
        <input type="hidden" id="currentFilePathInput">

        <label for="fileNameInput">파일 경로 (현재 폴더 기준):</label>
        <input type="text" id="fileNameInput" placeholder="예: new-file.md">

        <label for="fileContentInput">파일 내용:</label>
        <textarea id="fileContentInput"></textarea>

        <label for="commitMessageInput">커밋 메시지:</label>
        <input type="text" id="commitMessageInput" placeholder="예: 파일 생성 또는 수정">

        <button id="saveFileButton">저장 (생성/수정)</button>
        <button id="deleteFileButton">삭제</button>
        <button id="cancelEditButton">취소</button>
    </div>

    <!-- Status Bar -->
    <div id="statusBar">상태: 대기 중...</div>

</div>

<script>
    const GITHUB_API_BASE = 'https://api.github.com';
    let githubToken = null;
    let selectedOwner = null;
    let selectedRepo = null;
    let currentPath = ''; // 현재 탐색 중인 경로
    let currentFiles = []; // 현재 경로의 파일/폴더 목록 캐시

    // --- DOM Elements ---
    const patInput = document.getElementById('patInput');
    const loginButton = document.getElementById('loginButton');
    const repoSelect = document.getElementById('repoSelect');
    const loadRepoButton = document.getElementById('loadRepoButton');
    const fileListUl = document.querySelector('#fileList ul');
    const currentRepoSpan = document.getElementById('currentRepo');
    const currentPathBreadcrumb = document.getElementById('currentPathBreadcrumb');
    const fileNameInput = document.getElementById('fileNameInput');
    const fileContentInput = document.getElementById('fileContentInput');
    const commitMessageInput = document.getElementById('commitMessageInput');
    const currentFileShaInput = document.getElementById('currentFileSha');
    const currentFilePathInput = document.getElementById('currentFilePathInput');
    const saveFileButton = document.getElementById('saveFileButton');
    const deleteFileButton = document.getElementById('deleteFileButton');
    const cancelEditButton = document.getElementById('cancelEditButton');
    const createNewFileButton = document.getElementById('createNewFileButton');
    const statusBar = document.getElementById('statusBar');

    // --- Sections ---
    const loginSection = document.getElementById('loginSection');
    const repoSection = document.getElementById('repoSection');
    const fileBrowserSection = document.getElementById('fileBrowserSection');
    const editorSection = document.getElementById('editorSection');

    // --- Helper Functions ---
    function updateStatus(message, isError = false) {
        statusBar.textContent = `상태: ${message}`;
        statusBar.className = isError ? 'error' : '';
        console.log(message);
    }

    function showSection(sectionToShow) {
        [loginSection, repoSection, fileBrowserSection, editorSection].forEach(section => {
            section.classList.add('hidden');
        });
        if (sectionToShow) {
            sectionToShow.classList.remove('hidden');
        }
    }

    async function githubApiRequest(endpoint, options = {}) {
        if (!githubToken) {
            throw new Error('GitHub PAT가 설정되지 않았습니다.');
        }

        const url = endpoint.startsWith('http') ? endpoint : `${GITHUB_API_BASE}${endpoint}`;
        const headers = {
            'Authorization': `Bearer ${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            ...options.headers,
        };

        // POST, PUT, DELETE 요청 시 Content-Type 설정
        if (options.method && ['POST', 'PUT', 'DELETE'].includes(options.method.toUpperCase()) && options.body) {
            headers['Content-Type'] = 'application/json';
        }

        updateStatus('GitHub API 요청 중...');
        try {
            const response = await fetch(url, { ...options, headers });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: '알 수 없는 오류' }));
                throw new Error(`GitHub API 오류 (${response.status}): ${errorData.message || response.statusText}`);
            }
             // DELETE 요청은 내용이 없을 수 있음
            if (response.status === 204 || response.headers.get('Content-Length') === '0') {
                 updateStatus('GitHub API 요청 성공.');
                 return null; // No content
            }
            const data = await response.json();
            updateStatus('GitHub API 요청 성공.');
            return data;
        } catch (error) {
            updateStatus(`오류: ${error.message}`, true);
            throw error; // Re-throw for further handling
        }
    }

    // Base64 인코딩/디코딩 (UTF-8 지원)
    function b64EncodeUnicode(str) {
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
            return String.fromCharCode('0x' + p1);
        }));
    }

    function b64DecodeUnicode(str) {
        return decodeURIComponent(atob(str).split('').map(function(c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
    }

    // 경로 Breadcrumb 생성
    function updateBreadcrumb() {
        currentPathBreadcrumb.innerHTML = ''; // Clear existing
        const pathParts = currentPath.split('/').filter(p => p); // 빈 요소 제거
        const rootLink = document.createElement('a');
        rootLink.href = '#';
        rootLink.textContent = '/';
        rootLink.onclick = (e) => { e.preventDefault(); fetchContents(''); };
        currentPathBreadcrumb.appendChild(rootLink);

        let accumulatedPath = '';
        pathParts.forEach((part, index) => {
            accumulatedPath += (accumulatedPath ? '/' : '') + part;
            const pathSpan = document.createElement('span');
            pathSpan.textContent = '>';
            currentPathBreadcrumb.appendChild(pathSpan);

            const partLink = document.createElement('a');
            partLink.href = '#';
            partLink.textContent = part;
            // 클로저를 사용하여 올바른 경로 전달
            const currentAccumulatedPath = accumulatedPath;
            partLink.onclick = (e) => { e.preventDefault(); fetchContents(currentAccumulatedPath); };
            currentPathBreadcrumb.appendChild(partLink);
        });
         // 마지막에 슬래시 추가 (루트가 아닐 경우)
        if (currentPath) {
             const trailingSlash = document.createElement('span');
             trailingSlash.textContent = '/';
             currentPathBreadcrumb.appendChild(trailingSlash);
        }
    }


    // --- Event Handlers ---

    // 1. Login
    loginButton.addEventListener('click', async () => {
        githubToken = patInput.value.trim();
        if (!githubToken) {
            updateStatus('PAT를 입력해주세요.', true);
            return;
        }
        patInput.disabled = true;
        loginButton.disabled = true;
        updateStatus('저장소 목록 로딩 중...');
        try {
            // /user/repos 는 인증된 사용자의 모든 저장소를 가져옵니다.
            // 페이지네이션을 고려하여 최대 100개까지 요청 (필요시 반복 요청 구현)
            const repos = await githubApiRequest('/user/repos?per_page=100&sort=updated');
            repoSelect.innerHTML = '<option value="">-- 저장소 선택 --</option>'; // Clear previous options
            repos.forEach(repo => {
                const option = document.createElement('option');
                option.value = `${repo.owner.login}/${repo.name}`;
                option.textContent = repo.full_name;
                repoSelect.appendChild(option);
            });
            updateStatus('저장소 목록 로드 완료.');
            showSection(repoSection);
            loadRepoButton.disabled = false;
            repoSection.classList.remove('hidden'); // Show repo section
        } catch (error) {
            updateStatus(`저장소 목록 로딩 실패: ${error.message}`, true);
            patInput.disabled = false;
            loginButton.disabled = false;
        }
    });

    // 2. Repository Selection
    repoSelect.addEventListener('change', () => {
        loadRepoButton.disabled = repoSelect.value === '';
    });

    loadRepoButton.addEventListener('click', () => {
        const selectedRepoFullName = repoSelect.value;
        if (!selectedRepoFullName) return;

        [selectedOwner, selectedRepo] = selectedRepoFullName.split('/');
        currentRepoSpan.textContent = selectedRepoFullName;
        updateStatus(`'${selectedRepoFullName}' 저장소 파일 목록 로딩...`);
        showSection(fileBrowserSection); // Show file browser
        fetchContents(''); // Load root directory
    });

    // 3. Fetch Repository Contents (Files/Folders)
    async function fetchContents(path) {
        currentPath = path;
        updateBreadcrumb(); // Update breadcrumb based on the new path
        fileListUl.innerHTML = ''; // Clear previous list
        updateStatus(`'${selectedOwner}/${selectedRepo}/${path}' 로딩 중...`);
        showSection(fileBrowserSection); // Make sure browser is visible

        try {
            const contents = await githubApiRequest(`/repos/${selectedOwner}/${selectedRepo}/contents/${path}`);
            currentFiles = contents.sort((a, b) => { // Sort: folders first, then by name
                if (a.type === b.type) {
                    return a.name.localeCompare(b.name);
                }
                return a.type === 'dir' ? -1 : 1;
            });

            // Add '..' (Up directory) link if not in root
            if (path !== '') {
                const parentPath = path.substring(0, path.lastIndexOf('/'));
                const li = document.createElement('li');
                li.textContent = '⬆️ .. (상위 폴더)';
                li.style.cursor = 'pointer';
                li.style.fontWeight = 'bold';
                li.onclick = () => fetchContents(parentPath);
                fileListUl.appendChild(li);
            }

            // Populate file/directory list
            currentFiles.forEach(item => {
                const li = document.createElement('li');
                li.textContent = item.name;
                li.classList.add(item.type); // Add 'dir' or 'file' class
                li.dataset.path = item.path;
                li.dataset.type = item.type;
                li.dataset.sha = item.sha; // Store sha for later use (especially for files)

                if (item.type === 'dir') {
                    li.onclick = () => fetchContents(item.path);
                } else if (item.type === 'file') {
                    li.onclick = () => fetchFileContent(item.path, item.sha);
                }
                fileListUl.appendChild(li);
            });
             updateStatus(`'${selectedOwner}/${selectedRepo}/${path}' 로드 완료.`);
        } catch (error) {
            updateStatus(`파일 목록 로딩 실패 (${path}): ${error.message}`, true);
            // Optionally show the browser section even on error to allow navigation back
            showSection(fileBrowserSection);
        }
    }

    // 4. Fetch File Content
    async function fetchFileContent(filePath, fileSha) {
        updateStatus(`'${filePath}' 파일 내용 로딩 중...`);
        try {
            const fileData = await githubApiRequest(`/repos/${selectedOwner}/${selectedRepo}/contents/${filePath}`);

            if (fileData.encoding !== 'base64') {
                throw new Error('지원하지 않는 인코딩입니다: ' + fileData.encoding);
            }
            if (fileData.content === undefined || fileData.sha === undefined) {
                 throw new Error('API 응답에 content 또는 sha가 없습니다.');
            }

            const decodedContent = b64DecodeUnicode(fileData.content);

            // Populate editor
            fileNameInput.value = filePath.substring(filePath.lastIndexOf('/') + 1); // Extract filename
            fileContentInput.value = decodedContent;
            commitMessageInput.value = `Update ${fileNameInput.value}`; // Default commit message
            currentFileShaInput.value = fileData.sha; // Store SHA for update/delete
            currentFilePathInput.value = filePath; // Store full path

            // Enable/disable delete button based on whether it's an existing file
            deleteFileButton.disabled = false;
            saveFileButton.textContent = '저장 (수정)';

            updateStatus(`'${filePath}' 로드 완료.`);
            showSection(editorSection); // Show editor

        } catch (error) {
            updateStatus(`파일 내용 로딩 실패 (${filePath}): ${error.message}`, true);
            showSection(fileBrowserSection); // Go back to browser on error
        }
    }

    // 5. Show Create New File Form
    createNewFileButton.addEventListener('click', () => {
        fileNameInput.value = '';
        fileContentInput.value = '';
        commitMessageInput.value = 'Create new file';
        currentFileShaInput.value = ''; // No SHA for new file
        currentFilePathInput.value = ''; // Path will be constructed on save

        deleteFileButton.disabled = true; // Cannot delete a new file
        saveFileButton.textContent = '저장 (생성)';

        updateStatus('새 파일 생성 준비 완료.');
        showSection(editorSection);
        fileNameInput.focus();
    });


    // 6. Save File (Create or Update)
    saveFileButton.addEventListener('click', async () => {
        const fileName = fileNameInput.value.trim();
        const fileContent = fileContentInput.value;
        let commitMessage = commitMessageInput.value.trim();
        const existingSha = currentFileShaInput.value; // SHA for updates
        const isUpdate = !!existingSha;

        if (!fileName) {
            updateStatus('파일 이름을 입력해주세요.', true);
            return;
        }
        if (!commitMessage) {
            commitMessage = isUpdate ? `Update ${fileName}` : `Create ${fileName}`;
        }

        // Construct the full path relative to the current directory
        const fullPath = (currentPath ? currentPath + '/' : '') + fileName;

        updateStatus(`'${fullPath}' 저장 중...`);
        saveFileButton.disabled = true;
        cancelEditButton.disabled = true;
        deleteFileButton.disabled = true;

        try {
            const encodedContent = b64EncodeUnicode(fileContent);
            const body = {
                message: commitMessage,
                content: encodedContent,
                branch: null // Use default branch (TODO: Add branch selection)
            };

            // Add SHA only if updating an existing file
            if (isUpdate) {
                 // Verify the path hasn't changed unexpectedly during editing
                 if (fullPath !== currentFilePathInput.value) {
                      throw new Error("파일 경로가 편집 중 변경되었습니다. 수정을 취소하고 다시 시도하세요.");
                 }
                body.sha = existingSha;
            }

            await githubApiRequest(`/repos/${selectedOwner}/${selectedRepo}/contents/${fullPath}`, {
                method: 'PUT',
                body: JSON.stringify(body)
            });

            updateStatus(`'${fullPath}' ${isUpdate ? '수정' : '생성'} 완료.`);
            // Go back to the file browser and refresh the current directory
            fetchContents(currentPath);

        } catch (error) {
            updateStatus(`파일 저장 실패 (${fullPath}): ${error.message}`, true);
        } finally {
            saveFileButton.disabled = false;
            cancelEditButton.disabled = false;
             // Re-enable delete only if it was an update initially
            deleteFileButton.disabled = !isUpdate;
            // Don't automatically hide editor on failure, let user retry/cancel
        }
    });

    // 7. Delete File
    deleteFileButton.addEventListener('click', async () => {
        const filePathToDelete = currentFilePathInput.value;
        const fileShaToDelete = currentFileShaInput.value;

        if (!filePathToDelete || !fileShaToDelete) {
            updateStatus('삭제할 파일 정보가 올바르지 않습니다.', true);
            return;
        }

        if (!confirm(`정말로 '${filePathToDelete}' 파일을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.`)) {
            return;
        }

        let commitMessage = commitMessageInput.value.trim();
         if (!commitMessage || !commitMessage.toLowerCase().includes('delete') ) {
             commitMessage = `Delete ${filePathToDelete}`;
         }


        updateStatus(`'${filePathToDelete}' 삭제 중...`);
        saveFileButton.disabled = true;
        cancelEditButton.disabled = true;
        deleteFileButton.disabled = true;

        try {
            await githubApiRequest(`/repos/${selectedOwner}/${selectedRepo}/contents/${filePathToDelete}`, {
                method: 'DELETE',
                body: JSON.stringify({
                    message: commitMessage,
                    sha: fileShaToDelete,
                    branch: null // Use default branch
                })
            });

            updateStatus(`'${filePathToDelete}' 삭제 완료.`);
            // Go back to the file browser and refresh the current directory
            fetchContents(currentPath);

        } catch (error) {
            updateStatus(`파일 삭제 실패 (${filePathToDelete}): ${error.message}`, true);
             // Re-enable buttons on failure
            saveFileButton.disabled = false;
            cancelEditButton.disabled = false;
            deleteFileButton.disabled = false;
        }
        // No finally needed here as success navigates away
    });

    // 8. Cancel Edit
    cancelEditButton.addEventListener('click', () => {
        updateStatus('편집 취소됨.');
        // Just show the file browser, don't necessarily reload it
        showSection(fileBrowserSection);
        // Clear editor state (optional, but good practice)
        fileNameInput.value = '';
        fileContentInput.value = '';
        commitMessageInput.value = '';
        currentFileShaInput.value = '';
        currentFilePathInput.value = '';
    });


    // --- Initial State ---
    showSection(loginSection); // Start with login section
    updateStatus('시작: GitHub PAT를 입력하세요.');

</script>

</body>
</html>